{"version":3,"sources":["../node_modules/gammacv/dist/index.es.js","../lib/utils.js","../lib/index.js","example.js"],"names":["genetateTransformMatrix","sortPoints","points","canvas","center","A","B","C","D","i","length","angleBetweenLines","line1","line2","dx1","dy1","dx2","dy2","d","l2","Math","acos","sqrt","transfromPoint","px","py","transformation","m","xs","ys","xs0","ys0","ws","sc","get","rect","dstBounds","transformMatrix","pad","ax","ay","bx","by","cx","cy","dx","dy","shape","perspective_4point_transform","dst","src_x0","src_y0","dst_x0","dst_y0","src_x1","src_y1","dst_x1","dst_y1","src_x2","src_y2","dst_x2","dst_y2","src_x3","src_y3","dst_x3","dst_y3","nd4","t1","t2","t4","t5","t6","t7","t8","t9","t10","t11","t14","t15","t16","t18","t20","t21","t24","t25","t26","t27","t28","t30","t32","t35","t41","t42","t43","t46","t48","t51","t55","Hr0","Hr1","Hr2","Hr3","Hr4","Hr5","Hr6","Hr7","Hl0","Hl1","Hl2","Hl3","Hl4","Hl5","Hl6","Hl7","t12","t23","t31","t44","t47","t49","t50","mat","data","eps","between","a","b","c","Line","Intersection","l1","x1","y1","x2","y2","x3","y3","x4","y4","x","y","isNaN","ArrayBuffer","Float32Array","Array","isArray","push","undefined","w","h","maxDistance","maxAngles","set","angle","atan","PI","v","arr","prototype","slice","call","BYTES_PER_ELEMENT","Rect","Distance","r1","r2","distance","vecLength","Infinity","TriangleS","abs","args","NUM_ELEMENTS","s1","area","toArray","l3","l4","sorted","distA","distB","distC","distD","distE","distF","angleA","angleB","angleC","angleD","p","P","num","matrix","p1","p2","p3","p4","TypedPool","Type","poolSize","dataStore","size","cb","ctx","map","type","Error","clear","GraphNode","GlobalCountIncrease","GlobalNodesCount","name","id","GLUniform","gl","program","dtype","location","getUniformLocation","value","uniform1i","uniform1f","uniform2fv","uniform3fv","uniform4fv","uniformMatrix3fv","uniformMatrix4fv","GLBuffer","getAttribLocation","createBuffer","empty","parseInt","exec","enableVertexAttribArray","bind","bufferData","ELEMENT_ARRAY_BUFFER","Uint16Array","STATIC_DRAW","ARRAY_BUFFER","bindBuffer","vertexAttribPointer","FLOAT","disableVertexAttribArray","deleteBuffer","vertexShader","errorStart","getOffset","line","l","repeat","prepareSourceLines","source","lines","split","targetLength","toString","text","padStart","calcErrorStats","errors","errCount","warnCount","injectAll","kernel","error","useStyles","errorText","shortErrors","fullTextStyle","startsWith","substr","errorsStats","offset","lineNo","index","preErrorLine","sS","splice","join","processError","kernelName","prepared","stats","group","log","firstError","groupCollapsed","fullText","groupEnd","err","warn","parameters","testFloatTextures","document","createElement","getContext","getExtension","frameBuffer","createFramebuffer","texture","createTexture","MAX_TEXTURE_SIZE","getParameter","bindTexture","TEXTURE_2D","texImage2D","RGBA","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","frameBufferComplete","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","noError","readPixels","getError","NO_ERROR","SOURCE_ENV","ENV","Object","assign","main","op","code","SUPPORTS_FLOAT_TEXTURES","floatCode","pick_value","inputs","keys","input","functions","key","toFixed","w4","funcBody","selector","float","chunks","freeze","validType","indexOf","getType","String","complexType","constructHeading","uniforms","uniform","inputKeys","head","uniformsKeys","constantsKeys","constant","preparedValue","glValueType","injectChunks","separateWidth","requiredChunks","dependencies","concat","filter","item","pos","self","midString","floor","ceil","TypeError","hasMain","constructKernel","fullKernel","end","DEBUG","AVAILABLE_GLSL_CHUNKS","assert$$1","expression","msg","assertShapesAreEqual$$1","isValidShape$$1","some","n","isOperation$$1","Operation","isTensor$$1","tensor","Tensor","isValidGLSLChunk$$1","includes","isValidGLSLVariableName$$1","test","isValidOperationShape$$1","DeprecationError$$1","deprecationWarning$$1","deprecationError$$1","isInitialized","lastCtx","random","cache","sess","isRecalculated","outTexture","useProgram","opName","viewport","clearColor","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","drawElements","TRIANGLES","UNSIGNED_SHORT","framebuffer","createProgram","OUT_VIEW","getShader","attachShader","fragmentShader","linkProgram","message","attributes","aVertexPosition","aTextureCoords","aIndices","uniformKeys","j","defaultValue","src","shader","createShader","FRAGMENT_SHADER","VERTEX_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","handler","context","inputNames","traverse","path","innerDeps","getDependencies","names","prop","cursor","deleteProgram","deleteShader","deleteFramebuffer","cloneProp","GPUTexture","unit","texParameteri","TEXTURE_MAG_FILTER","NEAREST","TEXTURE_MIN_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","allocate","width","UNSIGNED_BYTE","uint8View","activeTexture","TEXTURE0","deleteTexture","range","result","tensorFrom","cast","out","tensorClone","from","to","tensorInvert","output","invertShape","fill","clone","tmpArr","invert","coords","IndexToCoord","inverted","tensorAssertEqual","actual","expected","tensorAssertCloseEqual","delta","tensorAssertMSEEqual","mse","flipTensor","invertTensor","tensorMap","t","fn","tensorOnes","stride","GetSize","_defineStride","_compileJITMethods","Malloc","Uint8Array","buffer","indices","argsStr","indexStr","Function","sz","nextDtype","DefineType","nextLength","res","_index","shapeSum","reduce","s","r","CoordToIndex","sum","Uint32Array","Int8Array","Int16Array","Int32Array","Float64Array","Uint8ClampedArray","str","GetTypedArray","Session","height","initWebGL","operation","textureCount","opts","float32Ext","node","update","opKeys","init","sequence","isLastOp","run","readToTensor","glLoseContext","textures","operations","loseContext","delete","destroy","RegisterOperation","checkShape","preCompile","postCompile","chunk","inputShapes","inputNode","assignInput","initDrawable","updater","flag","onmousedown","onmouseup","onmousemove","e","offsetY","offsetX","initMouseTracking","toImageData","img","rgba","transposed","imageData","ImageData","val","getImageData","putImageData","dw","dh","clearRect","canvasFromTensor","canvasToTensor","imgData","canvasDrawLine","color","beginPath","moveTo","lineTo","strokeStyle","lineWidth","stroke","closePath","canvasDrawCircle","radius","arc","canvasFillCircle","fillStyle","clearCanvas","canvasDrawRect","cross","canvasFill","fillRect","canvasClear","canvasInit","querySelector","canvasCreate","imageTensorFromURL","url","outShape","cors","Promise","reolve","reject","image","crossOrigin","onload","drawImage","onerror","getWidth","getHeight","getMaxAvailableSize","maxWidth","maxHeight","_height","getMinAvailableSize","minWidth","minHeight","CaptureVideo","IsAvailable","cfg","min","ideal","max","getUserMedia","navigator","webkitGetUserMedia","mozGetUserMedia","msGetUserMedia","oGetUserMedia","ua","userAgent","video","getStream","resolve","mediaDevices","then","stream","tracks","getTracks","deviceID","getSettings","deviceId","forEach","track","stop","catch","getDevices","enumerateDevices","devices","device","kind","muted","playsInline","canvasCtx","sourceCanvas","sourceCanvasCtx","sourceWidth","sourceHeight","setSize","sourceMinWidth","sourceMinHeight","scaledSize","scaledMinSize","exactFacingMode","started","exact","aspectRatio","srcObject","window","URL","createObjectURL","play","setSourceSize","videoWidth","videoHeight","ow","oh","originW","originH","getImageBuffer","tSrc","Input","Output","LoadChunk","GLSLKernel","Compile","kernel$1","index$1","kernelSize","sigma","Uniform","Constant","PreCompile","dstKernel","mean","resultKernel","exp","kernel$2","index$2","coeficient","SetShapeFn","kernel$3","index$3","dirrectionKernel","groupKernel","groupMaxKernel","hogDirrection","hogGroup","k","hogGroupMax","index$4","kernel$4","index$5","nmsKernel","hysteresisKernel","CannyNMS","CannyHysteresis","low","high","index$6","kernel$5","index$7","clusters","centroids","parallelReductionCheckSteps","steps","parallelReductionCheckSteps2d","parallelReductionGetSteps","layersCount","ignoreOne","maxLayerSize","base","RangeError","_size","_base","parallelReductionGetSteps2d","s2","clacConvolution","inputLength","kernelSide","getMean","getStd","reduceStd","joinKernel","ImageReduceStd","tStd","ImageExtractStd","tMean","ImageExtractMean","JoinOp","meanStdOp","layers","ignoreStd","meanPipe","stdPipe","getHistogramKernel","reduceKernel","ImageExtractHistogram","step","count","ImageReduceHistogram","histogramOp","histogramPipe","getMinMax","reduceMinMax","ImageExtractMinMax","ImageReduceMinMax","minMaxOp","minMaxPipe","kernel$6","index$8","tCurr","tPrev","kernel$7","index$9","ths","uRThreshold","uGThreshold","uBThreshold","uRtoMinDiffThreshold","uRtoGDiffThreshold","kernel$8","kernelFlat","getParam","param","isFinite","slidingWindowOp","windowSize","stragtegy","win","SX","SY","outputShape","kernelCode","SWAP_COORDS","kernel$9","index$a","tSobel","tCanny","returnCoords","kernel$a","index$b","tA","tB","mask","replace","l2Kernel","minMaxKernel","l2Norm","tStdMean","minMaxNorm","tMinMax","norm","parallelReductionLayers","histKernel","histCumulateKernel","cumulateHistEq","histEq","tHist","index$c","kernel$b","index$d","tTransform","transformKernel","enhanceKernel","peaksKernel","TopKCandidates","f","PCLinesTransform","EnhancePCLines","index$e","pipeline","RGBToHSVKernel","HSVToRGBKernel","index$f","kernel$c","index$g","threshold","channel","kernel$d","erode","tKernel","kernel$e","dilate","kernel$f","sub","index$h","GLTexture","assert","assertShapesAreEqual","isValidShape","isOperation","isTensor","isValidGLSLChunk","isValidGLSLVariableName","isValidOperationShape","DeprecationError","deprecationWarning","deprecationError","grayscale","gaussianBlur","downsample","sobelOperator","hog","cannyEdges","colorSegmentation","meanStd","histogram","minMax","motionDetect","skinTest","slidingWindow","swt","histogramEqualization","perspectiveProjection","pcLines","HSVColor","morphologyEx","isTensor2D","canvasDrawChart","gm","defaultStyles","findMinMax","axis","elem","drawAxisGrid","styles","roundedMax","font","legendFontSize","legendFontColor","legendRulerColor","legendGuidesColor","xAxisLabels","showRulerY","styleIndent","indent","yAxisFromMinVal","legendGrid","showMinY","bottomPadding","isXAxis","isYAxis","axisGrid","axisStep","legendStep","precision","digits","axisLegendValues","tempLegendValue","tempX","xAxis","tempY","yAxis","markTxt","toUpperCase","textAlign","textBaseline","fillText","yMark","xMark","drawData","dataCount","dataStyles","dataStyle","lineColor","pointSize","pointBorder","pointColor","chartScale","tempYMin","drawHeight","xGrid","xStep","normX","normY","columnWidth","bgColor","tensorArray","styleSize","devicePixelRatio","style","scale","fakeCanvas","boundaries","plotCanvas","getElementById","scatterCanvas","histogramCanvas","dimension","samplesCount","plotStyles","scatterStyles","histStyles"],"mappings":"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","file":"example.b3911a91.map","sourceRoot":"../example","sourcesContent":["/**\n * GammaCV v0.1.0\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nfunction sortPoints(points, canvas) { // eslint-disable-line\n  // How it works?\n  const center = [0, 0];\n  let A = null;\n  let B = null;\n  let C = null;\n  let D = null;\n\n  center[0] += points[0][0];\n  center[0] += points[1][0];\n  center[0] += points[2][0];\n  center[0] += points[3][0];\n  center[1] += points[0][1];\n  center[1] += points[1][1];\n  center[1] += points[2][1];\n  center[1] += points[3][1];\n\n  center[0] /= 4;\n  center[1] /= 4;\n\n  for (let i = 0; i < points.length; i += 1) {\n    if (points[i][0] >= center[0] && points[i][1] >= center[1]) {\n      C = points[i];\n    }\n\n    if (points[i][0] <= center[0] && points[i][1] <= center[1]) {\n      A = points[i];\n    }\n\n    if (points[i][0] >= center[0] && points[i][1] <= center[1]) {\n      B = points[i];\n    }\n\n    if (points[i][0] <= center[0] && points[i][1] >= center[1]) {\n      D = points[i];\n    }\n  }\n\n  return [A, B, C, D];\n}\n\nfunction angleBetweenLines(line1, line2) {\n  const dx1 = line1[2] - line1[0];\n  const dy1 = line1[3] - line1[1];\n  const dx2 = line2[2] - line2[0];\n  const dy2 = line2[3] - line2[1];\n\n  const d = dx1 * dx2 + dy1 * dy2;\n  const l2 = (dx1 * dx1 + dy1 * dy1) * (dx2 * dx2 + dy2 * dy2);\n\n  return Math.acos(d / Math.sqrt(l2));\n}\n\nfunction transfromPoint(px, py, transformation) {\n  const m = transformation;\n  let xs = 0.0;\n  let ys = 0.0;\n  let xs0 = 0.0;\n  let ys0 = 0.0;\n  let ws = 0.0;\n  let sc = 0.0;\n\n  xs0 = m.get(0, 1) * py + m.get(0, 2);\n  ys0 = m.get(1, 1) * py + m.get(1, 2);\n  ws = m.get(2, 1) * py + m.get(2, 2);\n\n  xs0 += m.get(0, 0) * px;\n  ys0 += m.get(1, 0) * px;\n  ws += m.get(2, 0) * px;\n\n\n  sc = 1.0 / ws;\n  xs = xs0 * sc;\n  ys = ys0 * sc;\n\n  return [xs, ys];\n}\n\n/* eslint-disable */\n\n/**\n * Fill transformMatrix with transformation values for fixing rect's perspective to be full viewed in view bounds.\n * @param {Rect} rect\n * @param {Array} dstBounds\n * @param {Tensor} transformMatrix\n */\n\nfunction genetateTransformMatrix(rect, dstBounds, transformMatrix, pad = 0) {\n  perspective_4point_transform(\n    transformMatrix,\n    pad, pad, rect.ax, rect.ay,\n    dstBounds[1] - pad, pad, rect.bx, rect.by,\n    dstBounds[1] - pad, dstBounds[0] - pad, rect.cx, rect.cy,\n    pad, dstBounds[0] - pad, rect.dx, rect.dy,\n    transformMatrix.shape.length === 3 && transformMatrix.shape[2] === 4,\n  );\n\n  return transformMatrix;\n}\n\n/**\n * Get perspective transformation matrix\n * @param {Tensor} dst\n * @param src_x0\n * @param src_y0\n * @param dst_x0\n * @param dst_y0\n * @param src_x1\n * @param src_y1\n * @param dst_x1\n * @param dst_y1\n * @param src_x2\n * @param src_y2\n * @param dst_x2\n * @param dst_y2\n * @param src_x3\n * @param src_y3\n * @param dst_x3\n * @param dst_y3\n */\nfunction perspective_4point_transform(\n  dst, src_x0, src_y0, dst_x0, dst_y0,\n  src_x1, src_y1, dst_x1, dst_y1,\n  src_x2, src_y2, dst_x2, dst_y2,\n  src_x3, src_y3, dst_x3, dst_y3,\n  nd4 = false // if we should apply for 4d based vector.\n) {\n  let t1 = src_x0;\n  let t2 = src_x2;\n  let t4 = src_y1;\n  let t5 = t1 * t2 * t4;\n  let t6 = src_y3;\n  let t7 = t1 * t6;\n  let t8 = t2 * t7;\n  let t9 = src_y2;\n  let t10 = t1 * t9;\n  let t11 = src_x1;\n  let t14 = src_y0;\n  let t15 = src_x3;\n  let t16 = t14 * t15;\n  let t18 = t16 * t11;\n  let t20 = t15 * t11 * t9;\n  let t21 = t15 * t4;\n  let t24 = t15 * t9;\n  let t25 = t2 * t4;\n  let t26 = t6 * t2;\n  let t27 = t6 * t11;\n  let t28 = t9 * t11;\n  let t30 = 1.0 / (t21 - t24 - t25 + t26 - t27 + t28);\n  let t32 = t1 * t15;\n  let t35 = t14 * t11;\n  let t41 = t4 * t1;\n  let t42 = t6 * t41;\n  let t43 = t14 * t2;\n  let t46 = t16 * t9;\n  let t48 = t14 * t9 * t11;\n  let t51 = t4 * t6 * t2;\n  let t55 = t6 * t14;\n  const Hr0 = -(t8 - t5 + t10 * t11 - t11 * t7 - t16 * t2 + t18 - t20 + t21 * t2) * t30;\n  const Hr1 = (t5 - t8 - t32 * t4 + t32 * t9 + t18 - t2 * t35 + t27 * t2 - t20) * t30;\n  const Hr2 = t1;\n  const Hr3 = (-t9 * t7 + t42 + t43 * t4 - t16 * t4 + t46 - t48 + t27 * t9 - t51) * t30;\n  const Hr4 = (-t42 + t41 * t9 - t55 * t2 + t46 - t48 + t55 * t11 + t51 - t21 * t9) * t30;\n  const Hr5 = t14;\n  const Hr6 = (-t10 + t41 + t43 - t35 + t24 - t21 - t26 + t27) * t30;\n  const Hr7 = (-t7 + t10 + t16 - t43 + t27 - t28 - t21 + t25) * t30;\n\n  t1 = dst_x0;\n  t2 = dst_x2;\n  t4 = dst_y1;\n  t5 = t1 * t2 * t4;\n  t6 = dst_y3;\n  t7 = t1 * t6;\n  t8 = t2 * t7;\n  t9 = dst_y2;\n  t10 = t1 * t9;\n  t11 = dst_x1;\n  t14 = dst_y0;\n  t15 = dst_x3;\n  t16 = t14 * t15;\n  t18 = t16 * t11;\n  t20 = t15 * t11 * t9;\n  t21 = t15 * t4;\n  t24 = t15 * t9;\n  t25 = t2 * t4;\n  t26 = t6 * t2;\n  t27 = t6 * t11;\n  t28 = t9 * t11;\n  t30 = 1.0 / (t21 - t24 - t25 + t26 - t27 + t28);\n  t32 = t1 * t15;\n  t35 = t14 * t11;\n  t41 = t4 * t1;\n  t42 = t6 * t41;\n  t43 = t14 * t2;\n  t46 = t16 * t9;\n  t48 = t14 * t9 * t11;\n  t51 = t4 * t6 * t2;\n  t55 = t6 * t14;\n  const Hl0 = -(t8 - t5 + t10 * t11 - t11 * t7 - t16 * t2 + t18 - t20 + t21 * t2) * t30;\n  const Hl1 = (t5 - t8 - t32 * t4 + t32 * t9 + t18 - t2 * t35 + t27 * t2 - t20) * t30;\n  const Hl2 = t1;\n  const Hl3 = (-t9 * t7 + t42 + t43 * t4 - t16 * t4 + t46 - t48 + t27 * t9 - t51) * t30;\n  const Hl4 = (-t42 + t41 * t9 - t55 * t2 + t46 - t48 + t55 * t11 + t51 - t21 * t9) * t30;\n  const Hl5 = t14;\n  const Hl6 = (-t10 + t41 + t43 - t35 + t24 - t21 - t26 + t27) * t30;\n  const Hl7 = (-t7 + t10 + t16 - t43 + t27 - t28 - t21 + t25) * t30;\n\n  // the following code computes R = Hl * inverse Hr\n  t2 = Hr4 - Hr7 * Hr5;\n  t4 = Hr0 * Hr4;\n  t5 = Hr0 * Hr5;\n  t7 = Hr3 * Hr1;\n  t8 = Hr2 * Hr3;\n  t10 = Hr1 * Hr6;\n  const t12 = Hr2 * Hr6;\n  t15 = 1.0 / (t4 - t5 * Hr7 - t7 + t8 * Hr7 + t10 * Hr5 - t12 * Hr4);\n  t18 = -Hr3 + Hr5 * Hr6;\n  const t23 = -Hr3 * Hr7 + Hr4 * Hr6;\n  t28 = -Hr1 + Hr2 * Hr7;\n  const t31 = Hr0 - t12;\n  t35 = Hr0 * Hr7 - t10;\n  t41 = -Hr1 * Hr5 + Hr2 * Hr4;\n  const t44 = t5 - t8;\n  const t47 = t4 - t7;\n  t48 = t2 * t15;\n  const t49 = t28 * t15;\n  const t50 = t41 * t15;\n  const mat = dst.data;\n\n  if (nd4) {\n    mat[0] = Hl0 * t48 + Hl1 * (t18 * t15) - Hl2 * (t23 * t15);\n    mat[1] = Hl0 * t49 + Hl1 * (t31 * t15) - Hl2 * (t35 * t15);\n    mat[2] = -Hl0 * t50 - Hl1 * (t44 * t15) + Hl2 * (t47 * t15);\n    mat[4] = Hl3 * t48 + Hl4 * (t18 * t15) - Hl5 * (t23 * t15);\n    mat[5] = Hl3 * t49 + Hl4 * (t31 * t15) - Hl5 * (t35 * t15);\n    mat[6] = -Hl3 * t50 - Hl4 * (t44 * t15) + Hl5 * (t47 * t15);\n    mat[8] = Hl6 * t48 + Hl7 * (t18 * t15) - t23 * t15;\n    mat[9] = Hl6 * t49 + Hl7 * (t31 * t15) - t35 * t15;\n    mat[10] = -Hl6 * t50 - Hl7 * (t44 * t15) + t47 * t15;\n  } else {\n    mat[0] = Hl0 * t48 + Hl1 * (t18 * t15) - Hl2 * (t23 * t15);\n    mat[1] = Hl0 * t49 + Hl1 * (t31 * t15) - Hl2 * (t35 * t15);\n    mat[2] = -Hl0 * t50 - Hl1 * (t44 * t15) + Hl2 * (t47 * t15);\n    mat[3] = Hl3 * t48 + Hl4 * (t18 * t15) - Hl5 * (t23 * t15);\n    mat[4] = Hl3 * t49 + Hl4 * (t31 * t15) - Hl5 * (t35 * t15);\n    mat[5] = -Hl3 * t50 - Hl4 * (t44 * t15) + Hl5 * (t47 * t15);\n    mat[6] = Hl6 * t48 + Hl7 * (t18 * t15) - t23 * t15;\n    mat[7] = Hl6 * t49 + Hl7 * (t31 * t15) - t35 * t15;\n    mat[8] = -Hl6 * t50 - Hl7 * (t44 * t15) + t47 * t15;\n  }\n}\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nconst eps = 0.0000001;\n\nfunction between(a, b, c) {\n  return a - eps <= b && b <= c + eps;\n}\n\nclass Line {\n  static Intersection(l1, l2) {\n    const x1 = l1.x1;\n    const y1 = l1.y1;\n    const x2 = l1.x2;\n    const y2 = l1.y2;\n    const x3 = l2.x1;\n    const y3 = l2.y1;\n    const x4 = l2.x2;\n    const y4 = l2.y2;\n\n    const x = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) /\n      ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4));\n    const y = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) /\n      ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4));\n\n    if (isNaN(x) || isNaN(y)) {\n      return false;\n    }\n\n    if (x1 >= x2) {\n      if (!between(x2, x, x1)) { return false; }\n    } else if (!between(x1, x, x2)) { return false; }\n\n    if (y1 >= y2) {\n      if (!between(y2, y, y1)) { return false; }\n    } else if (!between(y1, y, y2)) { return false; }\n\n    if (x3 >= x4) {\n      if (!between(x4, x, x3)) { return false; }\n    } else if (!between(x3, x, x4)) { return false; }\n\n    if (y3 >= y4) {\n      if (!between(y4, y, y3)) { return false; }\n    } else if (!between(y3, y, y4)) { return false; }\n\n    return [x, y];\n  }\n  /**\n   * @param {ArrayBuffer|Array|number} [a] - Source buffer to link, array to create from, or x value\n   * @param {number} [b] - buffer's offset or y value\n   */\n  constructor(a, b, c, d, x, y) {\n    if (a instanceof ArrayBuffer) {\n      this.data = new Float32Array(a, b, 8);\n    } else if (Array.isArray(a)) {\n      if (a.length < 8) {\n        for (let i = a.length; i <= 8; i += 1) {\n          a.push(0);\n        }\n      }\n      this.data = new Float32Array(a);\n    } else if (a !== undefined && b !== undefined) {\n      this.data = new Float32Array([a, b, c, d, x, y, 0, 0]);\n    } else {\n      this.data = new Float32Array(8);\n    }\n  }\n\n  set(a, b, c, d, x, y) {\n    this.data[0] = a;\n    this.data[1] = b;\n    this.data[2] = c;\n    this.data[3] = d;\n    this.data[4] = x;\n    this.data[5] = y;\n    this.data[6] = 0;\n    this.data[7] = 0;\n  }\n\n  fromParallelCoords(x, y, w, h, maxDistance, maxAngles) {\n    const x1 = 0;\n    const x2 = w;\n    let y1;\n    let y2;\n\n    if (x > maxAngles) {\n      x -= maxAngles; // eslint-disable-line\n\n      y1 = maxDistance - (maxAngles * y / x);\n      y2 = (-1 + maxAngles / x) * w + y1;\n    } else {\n      x = maxAngles - x; // eslint-disable-line\n\n      y1 = (maxAngles * y / x);\n      y2 = (1 - maxAngles / x) * w + y1;\n    }\n\n    this.set(x1, y1, x2, y2, x, y);\n  }\n\n  get length() {\n    if (this.data[6]) {\n      return this.data[6];\n    }\n\n    const dx = this.data[2] - this.data[0];\n    const dy = this.data[3] - this.data[1];\n    const length = Math.sqrt(dx ** 2 + dy ** 2);\n\n    this.data[6] = length;\n\n    return length;\n  }\n\n  get angle() {\n    if (this.data[7]) {\n      return this.data[7];\n    }\n    const dx = this.data[2] - this.data[0];\n    const dy = this.data[3] - this.data[1];\n    let angle = (Math.atan(dy / dx)) / Math.PI * 180;\n\n    if (angle < 0) {\n      angle = 180 + angle;\n    }\n\n    this.data[7] = angle;\n\n    return angle;\n  }\n\n  get x1() {\n    return this.data[0];\n  }\n\n  get y1() {\n    return this.data[1];\n  }\n\n  get x2() {\n    return this.data[2];\n  }\n\n  get y2() {\n    return this.data[3];\n  }\n\n  get px() {\n    return this.data[4];\n  }\n\n  get py() {\n    return this.data[5];\n  }\n\n  set x1(v) {\n    this.data[0] = v;\n  }\n\n  set y1(v) {\n    this.data[1] = v;\n  }\n\n  set x2(v) {\n    this.data[2] = v;\n  }\n\n  set y2(v) {\n    this.data[3] = v;\n  }\n\n  set px(v) {\n    this.data[4] = v;\n  }\n\n  set py(v) {\n    this.data[5] = v;\n  }\n\n  clear() {\n    this.data[0] = 0;\n    this.data[1] = 0;\n    this.data[2] = 0;\n    this.data[3] = 0;\n    this.data[4] = 0;\n    this.data[5] = 0;\n    this.data[6] = 0;\n    this.data[7] = 0;\n  }\n\n  fromArray(arr) {\n    this.data.set(arr);\n  }\n\n  toArray() {\n    return Array.prototype.slice.call(this.data);\n  }\n}\n\nLine.BYTES_PER_ELEMENT = 36;\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\n/**\n * Rect data has the next view:\n * 0: A.x\n * 1: A.y\n * 2: B.x\n * 3: B.y\n * 4: C.x\n * 5: C.y\n * 6: D.x\n * 7: D.y\n *\n * Where:\n * A------B\n * |      |\n * D------C\n */\nclass Rect {\n  static Distance(r1, r2) {\n    let distance = 0;\n\n    for (let i = 0; i < 8; i += 2) {\n      const vecLength = Math.sqrt((r1.data[i] - r2.data[i]) ** 2\n        + (r1.data[i + 1] - r2.data[i + 1]) ** 2);\n\n      distance += vecLength ** 2;\n    }\n\n    distance = Math.sqrt(distance / 8);\n\n    return distance === Infinity ? 0 : distance;\n  }\n\n  /**\n   * Helper method to calculate triangle area from 3 points\n   * @param {number} ax\n   * @param {number} ay\n   * @param {number} bx\n   * @param {number} by\n   * @param {number} cx\n   * @param {number} cy\n   * @returns {number} Area\n   */\n  static TriangleS(ax, ay, bx, by, cx, cy) {\n    return Math.abs(ax * (by - cy) + bx * (cy - ay) + cx * (ay - by)) / 2;\n  }\n\n  /**\n   * @param {ArrayBuffer|Array|number} [a] - Source buffer to link, array to create from, or x value\n   * @param {number} [b] - buffer's offset or y value\n   */\n  constructor(...args) {\n    if (args[0] instanceof ArrayBuffer) {\n      this.data = new Float32Array(args[0], args[1], Rect.NUM_ELEMENTS);\n    } else if (Array.isArray(args[0])) {\n      this.data = new Float32Array(args[0]);\n    } else if (args[0] && args.length === Rect.NUM_ELEMENTS) {\n      this.data = new Float32Array(args);\n    } else {\n      this.data = new Float32Array(Rect.NUM_ELEMENTS);\n    }\n  }\n\n  /**\n   * Define if point with given coordinates is inside rectangle.\n   * @param {number} x\n   * @param {number} y\n   * @returns {boolean} Is insinde rect\n   */\n  isInRect(x, y) {\n    const s1 = Rect.TriangleS(x, y, this.ax, this.ay, this.bx, this.by);\n    const s2 = Rect.TriangleS(x, y, this.cx, this.cy, this.bx, this.by);\n    const s3 = Rect.TriangleS(this.cx, this.cy, x, y, this.dx, this.dy);\n    const s4 = Rect.TriangleS(this.dx, this.dy, x, y, this.ax, this.ay);\n\n    if ((s1 + s2 + s3 + s4) - this.area > 0) {\n      return false;\n    }\n\n    return true;\n  }\n\n  isNotEmpty() {\n    if (\n      this.data[0] > 0 &&\n      this.data[1] > 0 &&\n      this.data[2] > 0 &&\n      this.data[3] > 0 &&\n      this.data[4] > 0 &&\n      this.data[5] > 0 &&\n      this.data[6] > 0 &&\n      this.data[7] > 0\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  clone() {\n    return new Rect(this.toArray());\n  }\n\n  set(ax, ay, bx, by, cx, cy, dx, dy) {\n    this.data[0] = ax;\n    this.data[1] = ay;\n    this.data[2] = bx;\n    this.data[3] = by;\n    this.data[4] = cx;\n    this.data[5] = cy;\n    this.data[6] = dx;\n    this.data[7] = dy;\n  }\n\n  assign(rect) {\n    this.data.set(rect.data);\n\n    return this;\n  }\n\n  scale(x, y) {\n    this.data[0] *= x;\n    this.data[1] *= y;\n    this.data[2] *= x;\n    this.data[3] *= y;\n    this.data[4] *= x;\n    this.data[5] *= y;\n    this.data[6] *= x;\n    this.data[7] *= y;\n\n    return this;\n  }\n\n  fromLines(l1, l2, l3, l4) {\n    const sorted = sortPoints([\n      Line.Intersection(l1, l2),\n      Line.Intersection(l2, l3),\n      Line.Intersection(l3, l4),\n      Line.Intersection(l4, l1),\n    ]);\n\n    if (\n      !sorted[0] ||\n      !sorted[1] ||\n      !sorted[2] ||\n      !sorted[3]\n    ) {\n      return false;\n    }\n\n    this.data[0] = sorted[0][0];\n    this.data[1] = sorted[0][1];\n    this.data[2] = sorted[1][0];\n    this.data[3] = sorted[1][1];\n    this.data[4] = sorted[2][0];\n    this.data[5] = sorted[2][1];\n    this.data[6] = sorted[3][0];\n    this.data[7] = sorted[3][1];\n\n    return true;\n  }\n\n  get ax() {\n    return this.data[0];\n  }\n\n  get ay() {\n    return this.data[1];\n  }\n\n  get bx() {\n    return this.data[2];\n  }\n\n  get by() {\n    return this.data[3];\n  }\n\n  get cx() {\n    return this.data[4];\n  }\n\n  get cy() {\n    return this.data[5];\n  }\n\n  get dx() {\n    return this.data[6];\n  }\n\n  get dy() {\n    return this.data[7];\n  }\n\n  set ax(v) {\n    this.data[0] = v;\n  }\n\n  set ay(v) {\n    this.data[1] = v;\n  }\n\n  set bx(v) {\n    this.data[2] = v;\n  }\n\n  set by(v) {\n    this.data[3] = v;\n  }\n\n  set cx(v) {\n    this.data[4] = v;\n  }\n\n  set cy(v) {\n    this.data[5] = v;\n  }\n\n  set dx(v) {\n    this.data[6] = v;\n  }\n\n  set dy(v) {\n    this.data[7] = v;\n  }\n\n  get distA() {\n    return Math.sqrt((this.data[6] - this.data[0]) ** 2 + (this.data[7] - this.data[1]) ** 2);\n  }\n\n  get distB() {\n    return Math.sqrt((this.data[4] - this.data[2]) ** 2 + (this.data[5] - this.data[3]) ** 2);\n  }\n\n  get distC() {\n    return Math.sqrt((this.data[0] - this.data[2]) ** 2 + (this.data[1] - this.data[3]) ** 2);\n  }\n\n  get distD() {\n    return Math.sqrt((this.data[6] - this.data[4]) ** 2 + (this.data[7] - this.data[5]) ** 2);\n  }\n\n  get distE() {\n    return Math.sqrt((this.data[0] - this.data[4]) ** 2 + (this.data[1] - this.data[5]) ** 2);\n  }\n\n  get distF() {\n    return Math.sqrt((this.data[6] - this.data[2]) ** 2 + (this.data[7] - this.data[3]) ** 2);\n  }\n\n  get angleA() {\n    return angleBetweenLines(\n      [this.data[6], this.data[7], this.data[0], this.data[1]],\n      [this.data[0], this.data[1], this.data[2], this.data[3]],\n    );\n  }\n\n  get angleB() {\n    return angleBetweenLines(\n      [this.data[0], this.data[1], this.data[2], this.data[3]],\n      [this.data[2], this.data[3], this.data[4], this.data[5]],\n    );\n  }\n\n  get angleC() {\n    return angleBetweenLines(\n      [this.data[2], this.data[3], this.data[4], this.data[5]],\n      [this.data[4], this.data[5], this.data[6], this.data[7]],\n    );\n  }\n\n  get angleD() {\n    return angleBetweenLines(\n      [this.data[4], this.data[5], this.data[6], this.data[7]],\n      [this.data[6], this.data[7], this.data[0], this.data[1]],\n    );\n  }\n\n  get area() {\n    const A = this.distA;\n    const B = this.distB;\n    const C = this.distC;\n    const D = this.distD;\n    const p = (A + B + C + D) / 2;\n\n    return Math.sqrt((p - A) * (p - B) * (p - C) * (p - D));\n  }\n\n  get P() {\n    return this.distA + this.distB + this.distC + this.distD;\n  }\n\n  mul(num) {\n    this.data[0] *= num;\n    this.data[1] *= num;\n    this.data[2] *= num;\n    this.data[3] *= num;\n    this.data[4] *= num;\n    this.data[5] *= num;\n    this.data[6] *= num;\n    this.data[7] *= num;\n\n    return this;\n  }\n\n  scaleAt(num) {\n    this.data[0] -= num;\n    this.data[1] -= num;\n    this.data[2] -= num;\n    this.data[3] += num;\n    this.data[4] += num;\n    this.data[5] += num;\n    this.data[6] += num;\n    this.data[7] -= num;\n\n    return this;\n  }\n\n  clear() {\n    this.data[0] = 0;\n    this.data[1] = 0;\n    this.data[2] = 0;\n    this.data[3] = 0;\n    this.data[4] = 0;\n    this.data[5] = 0;\n    this.data[6] = 0;\n    this.data[7] = 0;\n  }\n\n  fromDeep(arr) {\n    this.data[0] = arr[0][0];\n    this.data[1] = arr[0][1];\n    this.data[2] = arr[1][0];\n    this.data[3] = arr[1][1];\n    this.data[4] = arr[2][0];\n    this.data[5] = arr[2][1];\n    this.data[6] = arr[3][0];\n    this.data[7] = arr[3][1];\n\n    return this;\n  }\n\n  perspective(matrix) {\n    const p1 = transfromPoint(this.data[0], this.data[1], matrix);\n    const p2 = transfromPoint(this.data[2], this.data[3], matrix);\n    const p3 = transfromPoint(this.data[4], this.data[5], matrix);\n    const p4 = transfromPoint(this.data[6], this.data[7], matrix);\n\n    this.data[0] = p1[0];\n    this.data[1] = p1[1];\n    this.data[2] = p2[0];\n    this.data[3] = p2[1];\n    this.data[4] = p3[0];\n    this.data[5] = p3[1];\n    this.data[6] = p4[0];\n    this.data[7] = p4[1];\n\n    return this;\n  }\n\n  fromArray(arr) {\n    this.data.set(arr);\n\n    return this;\n  }\n\n  toArray() {\n    return Array.prototype.slice.call(this.data);\n  }\n\n  isInside(rect) {\n    return (\n      rect.ax > this.ax\n      && rect.ay > this.ay\n      && rect.bx < this.bx\n      && rect.by > this.by\n      && rect.cx < this.cx\n      && rect.cy < this.cy\n      && rect.dx > this.dx\n      && rect.dy < this.dy\n    );\n  }\n\n  toJSON() {\n    return this.toArray();\n  }\n}\n\nRect.NUM_ELEMENTS = 8;\nRect.BYTES_PER_ELEMENT = Rect.NUM_ELEMENTS * Float32Array.BYTES_PER_ELEMENT;\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nclass TypedPool {\n  constructor(Type, poolSize) {\n    this.dataStore = new ArrayBuffer(poolSize * Type.BYTES_PER_ELEMENT);\n    this.data = new Array(poolSize);\n    this.size = poolSize;\n\n    for (let i = 0; i < poolSize; i += 1) {\n      this.data[i] = new Type(this.dataStore, i * Type.BYTES_PER_ELEMENT);\n    }\n\n    this.length = 0;\n  }\n\n  map(cb, ctx) {\n    return this.data.map(cb, ctx);\n  }\n\n  push(type) {\n    if (this.length < this.size) {\n      this.data[this.length].data.set(type.data);\n      this.length += 1;\n    } else {\n      throw new Error('Typed Pool size exceed');\n    }\n  }\n\n  at(i) {\n    if (i >= this.size) {\n      throw new Error('Out of range requested');\n    }\n\n    return this.data[i];\n  }\n\n  release(clear) {\n    this.length = 0;\n\n    if (clear) {\n      for (let i = 0; i < this.size; i += 1) {\n        this.data[i].clear();\n      }\n    }\n  }\n}\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nclass GraphNode {\n  static GlobalCountIncrease() {\n    GraphNode.GlobalNodesCount += 1;\n\n    return GraphNode.GlobalNodesCount;\n  }\n\n  constructor(name) {\n    this.id = GraphNode.GlobalCountIncrease();\n    this.name = `${name}:${this.id}`;\n  }\n}\n\nGraphNode.GlobalNodesCount = 0;\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nclass GLUniform {\n  constructor(gl, program, name, dtype) {\n    this.gl = gl;\n    this.name = name;\n    this.dtype = dtype;\n    this.location = gl.getUniformLocation(program, this.name);\n  }\n\n  set(value) {\n    const gl = this.gl;\n\n    switch (this.dtype) {\n      case 'int':\n        gl.uniform1i(this.location, value);\n        break;\n      case 'float':\n        gl.uniform1f(this.location, value);\n        break;\n      case 'vec2':\n        gl.uniform2fv(this.location, value);\n        break;\n      case 'vec3':\n        gl.uniform3fv(this.location, value);\n        break;\n      case 'vec4':\n        gl.uniform4fv(this.location, value);\n        break;\n      case 'mat3':\n        gl.uniformMatrix3fv(this.location, false, value);\n        break;\n      case 'mat4':\n        gl.uniformMatrix4fv(this.location, false, value);\n        break;\n      default:\n        return false;\n    }\n\n    return true;\n  }\n}\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nclass GLBuffer {\n  constructor(gl, program, name, dtype) {\n    this.program = program;\n    this.gl = gl;\n    this.name = name;\n    this.dtype = dtype;\n    this.location = gl.getAttribLocation(this.program, this.name);\n    this.ctx = gl.createBuffer();\n    this.empty = new ArrayBuffer(1);\n    if (dtype === 'float' || dtype === 'int') {\n      this.size = 1;\n    } else {\n      this.size = parseInt(/\\d/g.exec(dtype)[0], 10);\n      gl.enableVertexAttribArray(this.location);\n    }\n  }\n\n  set(data) {\n    const gl = this.gl;\n\n    this.bind(this.ctx);\n    if (this.dtype === 'int') {\n      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(data), gl.STATIC_DRAW);\n    } else {\n      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);\n    }\n  }\n\n  bind() {\n    const gl = this.gl;\n\n    if (this.dtype === 'int') {\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ctx);\n    } else {\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.ctx);\n      gl.vertexAttribPointer(this.location, this.size, gl.FLOAT, false, 0, 0);\n    }\n  }\n\n  unbind() {\n    const gl = this.gl;\n\n    if (this.dtype === 'int') {\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    } else {\n      gl.bindBuffer(gl.ARRAY_BUFFER, null);\n      gl.vertexAttribPointer(this.location, this.size, gl.FLOAT, false, 0, 0);\n    }\n  }\n\n  disable() {\n    const gl = this.gl;\n\n    gl.disableVertexAttribArray(this.ctx);\n  }\n\n  enable() {\n    const gl = this.gl;\n\n    gl.enableVertexAttribArray(this.ctx);\n  }\n\n  delete() {\n    const gl = this.gl;\n\n    gl.deleteBuffer(this.ctx);\n    this.program = null;\n    this.gl = null;\n    this.ctx = null;\n  }\n}\n\nvar vertexShader = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/precision highp float;attribute vec3 aVertexPosition;attribute vec2 aTextureCoords;varying vec2 texCoords;void main(void){texCoords=aTextureCoords;gl_Position=vec4(aVertexPosition,1.0);}\";\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nconst errorStart = 'Error: An error occurred compiling the shaders: ';\n\nfunction getOffset(line) {\n  const l = /\\d+\\|(\\s+)/.exec(line);\n\n  if (l) {\n    return ' '.repeat(l[1].length);\n  }\n\n  return ' '.repeat(2);\n}\n\nfunction prepareSourceLines(source) {\n  let lines = source.split('\\n');\n  const targetLength = (lines.length + 1).toString().length;\n\n  lines = lines.map((text, line) => `${(line + 1).toString().padStart(targetLength)}|  ${text}`);\n\n  return lines;\n}\n\nfunction calcErrorStats(errors) {\n  let errCount = 0;\n  let warnCount = 0;\n\n  for (let i = 0; i < errors.length; i += 1) {\n    if (/ERROR/.exec(errors[i])) {\n      errCount += 1;\n    }\n    if (/WARNING/.exec(errors[i])) {\n      warnCount += 1;\n    }\n  }\n\n  return {\n    errCount,\n    warnCount,\n  };\n}\n\nfunction injectAll(kernel, error, useStyles = true) {\n  const lines = prepareSourceLines(kernel);\n  const targetLength = (lines.length + 1).toString().length;\n  let errorText = error.toString();\n  const shortErrors = [];\n  const fullTextStyle = [];\n\n  if (errorText.startsWith(errorStart)) {\n    errorText = errorText.substr(errorStart.length);\n  }\n\n  const errors = errorText.split('\\n');\n  const errorsStats = calcErrorStats(errors);\n\n  let offset = 0;\n\n  for (let i = 0; i < errors.length; i += 1) {\n    const text = errors[i];\n    const lineNo = /0:(\\d+)/.exec(text);\n\n    if (lineNo) {\n      const index = +lineNo[1] + offset;\n      const preErrorLine = `${' '.repeat(targetLength)}|${getOffset(lines[index - 1])}`;\n\n      shortErrors.push(`${text}\\n${lines[index - 2]}\\n${lines[index - 1]}\\n${preErrorLine}^\\n${lines[index]}`);\n      const sS = useStyles ? '%c' : '';\n\n      lines.splice(index, 0, `${sS}${preErrorLine}^--${text}${sS}`);\n      if (useStyles) {\n        fullTextStyle.push('color: red;');\n        fullTextStyle.push('color: inherit;');\n      }\n      offset += 1;\n    }\n  }\n\n  return {\n    fullText: lines.join('\\n'),\n    firstError: shortErrors[0],\n    errorsStats,\n    fullTextStyle,\n  };\n}\n\nfunction processError(kernel, kernelName, error) {\n  try {\n    const prepared = injectAll(kernel, error);\n    const stats = prepared.errorsStats;\n\n    console.group(`Error: An error occurred compiling the shader ${kernelName}: ${stats.errCount} ERRORS, ${stats.warnCount} WARNINGS`);\n    console.log(prepared.firstError);\n    console.groupCollapsed('Show more');\n    console.log(prepared.fullText, ...prepared.fullTextStyle);\n    console.groupEnd();\n    console.groupEnd();\n  } catch (err) {\n    console.warn('Unable to process GLSG compiling error.');\n  }\n}\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nconst parameters = {};\n\nfunction testFloatTextures() {\n  const canvas = document.createElement('canvas');\n  const gl = canvas.getContext('webgl');\n\n  if (!gl) {\n    return false;\n  }\n\n  if (!gl.getExtension('OES_texture_float')) {\n    return false;\n  }\n\n  const frameBuffer = gl.createFramebuffer();\n  const texture = gl.createTexture();\n\n  parameters.MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.FLOAT, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n  const frameBufferComplete =\n    gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n\n  let noError;\n\n  try {\n    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.FLOAT, new Float32Array(4));\n    noError = gl.getError() === gl.NO_ERROR;\n  } catch (err) {\n    noError = false;\n  }\n\n  return frameBufferComplete && noError;\n}\n\nconst SOURCE_ENV = {\n  SUPPORTS_FLOAT_TEXTURES: testFloatTextures(),\n  DEBUG: false,\n  MAX_TEXTURE_SIZE: parameters.MAX_TEXTURE_SIZE,\n};\n\n\nconst ENV = Object.assign({}, SOURCE_ENV);\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nfunction main (op) {\n  let code = `\nvoid main(void) {\n  vec2 coords = gl_FragCoord.xy - 0.5;\n  vec4 result = operation(coords.y, coords.x);\n\n  gl_FragColor = result;\n}\n  `;\n\n  if (!ENV.SUPPORTS_FLOAT_TEXTURES && op.dtype === 'float32') {\n    code = `\n    void main(void) {\n      vec2 coords = gl_FragCoord.xy;\n\n      highp float ox = floor(coords.x / 4.0);\n      float dx = floor(coords.x - ox * 4.0 + 0.5);\n    \n      vec4 result = operation(coords.y - 0.5, floor((coords.x - 0.5) / 4.0));\n\n      float value;\n\n      if (dx == 1.0) {\n        value = result.r;\n      } else if (dx == 2.0) {\n        value = result.g;\n      } else if (dx == 3.0) {\n        value = result.b;\n      } else if (dx == 4.0) {\n        value = result.a;\n      }\n    \n      gl_FragColor = encode_float(value);\n    }\n    `;\n  }\n\n  return code;\n}\n\nvar floatCode = \"/***@author twerdster from https:*/precision highp float;highp vec4 encode_float(highp float f){if(f==1./0.){return vec4(0.0,0.0,128.0,127.0)/255.0;}highp vec4 rgba;highp float e=5.0;highp float F=abs(f);highp float sign=step(0.0,-f);highp float exponent=floor(log2(F));highp float mantissa=(exp2(-exponent)*F);exponent=floor(log2(F)+127.0)+floor(log2(mantissa));rgba[0]=128.0*sign+floor(exponent*exp2(-1.0));rgba[1]=128.0*mod(exponent,2.0)+mod(floor(mantissa*64.0*2.0),128.0);rgba[2]=floor(mod(floor(mantissa*exp2(23.0-8.0)),exp2(8.0)));rgba[3]=floor(exp2(23.0)*mod(mantissa,exp2(-15.0)));return rgba.abgr/255.0;}float decode_float(highp vec4 rgba){rgba=rgba.abgr*255.0;highp float sign=1.0-step(128.0,rgba[0])*2.0;highp float exponent=2.0*mod(rgba[0],128.0)+step(128.0,rgba[1])-127.0;highp float mantissa=mod(rgba[1],128.0)*32768.0*2.0+rgba[2]*256.0+rgba[3]+float(0x800000);highp float result=sign*mantissa*exp2(-6.0)*exp2(exponent/4.0)*exp2(-7.0)*exp2(exponent/4.0)*exp2(-5.0)*exp2(exponent/4.0)*exp2(-5.0)*exp2(exponent/4.0);return result;}\";\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nfunction pick_value (op) {\n  const inputs = Object.keys(op.input);\n  const functions = [];\n\n  for (let i = 0; i < inputs.length; i += 1) {\n    const key = inputs[i];\n\n    if (!op.input[key].shape) {\n      continue;\n    }\n    const shape = [...op.input[key].shape];\n\n    const w = shape[1].toFixed(1);\n    const h = shape[0].toFixed(1);\n    const w4 = (shape[1] * 4).toFixed(1);\n\n    let funcBody = (type, name, selector) =>\n      `${type} ${name}_${key}(float y, float x) {\\n\\treturn texture2D(${key}, vec2((x + 0.5) / ${w}, (y + 0.5) / ${h}))${selector};\\n}`;\n\n    if (!ENV.SUPPORTS_FLOAT_TEXTURES && op.input[key].dtype === 'float32') {\n      funcBody = (type, name, selector) => `\n        ${type} ${name}_${key}(float y, float x) {\n          float r = decode_float(texture2D(${key}, vec2((x * 4.0 + 0.5) / ${w4}, y / ${h})));\n          float g = decode_float(texture2D(${key}, vec2((x * 4.0 + 1.5) / ${w4}, y / ${h})));\n          float b = decode_float(texture2D(${key}, vec2((x * 4.0 + 2.5) / ${w4}, y / ${h})));\n          float a = decode_float(texture2D(${key}, vec2((x * 4.0 + 3.5) / ${w4}, y / ${h})));\n\n          return vec4(r, g, b, a)${selector};\n        }\n      `;\n    }\n\n    functions.push(funcBody('vec4', 'pickValue', ''));\n    functions.push(funcBody('float', 'pickScalarValue', '.x'));\n  }\n\n  return functions.join('\\n');\n}\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\n/**\n * @name GLSLChunks\n * @description WebGL chunks is a set of helper functions that help enable code reuse\n * and utilize higher-level abstractions in your GPU kernels.\n * To use chunk, you must type `operationsRegister.LoadChunk(...chunkNames)`.\n * Some chunks are used under the hood, it is:\n * - `main` - Used to wrap operations into a smart entry point.\n * - `float` - Used as a polyfill the float textures on some devices.\n */\n\n/**\n * @name pickValue_INPUTNAME\n * @function\n * @description Returns pixel data of `texture` with the same\n * coordinates as current operation pixel.\n * @param {float} y - coordinate of needed pixel\n * @param {float} x - coordinate of needed pixel\n * @returns {vec4}\n*/\n\nconst float = () => floatCode;\n\nvar chunks = /*#__PURE__*/Object.freeze({\n  main: main,\n  pickValue: pick_value,\n  float: float\n});\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\n// TODO: Need to move it to kind of program_utils\nfunction validType(dtype) {\n  return [\n    'bool', 'int', 'uint',\n    'float', 'double',\n    'vec2', 'vec3', 'vec4',\n    'mat2', 'mat3', 'mat4',\n    'sampler2D',\n  ].indexOf(dtype) >= 0;\n}\n\nfunction getType(value) {\n  let type = typeof value;\n\n  value = String(value);\n  const complexType = /^(vec\\d|mat\\d)\\([^)]+\\)$/.exec(value);\n\n  if (complexType) {\n    type = complexType[1];\n  } else if (/^\\d+$/.exec(value)) {\n    type = 'int';\n  } else if (/^\\d+\\.(\\d+)?$/.exec(value)) {\n    type = 'float';\n  } else if (type === 'boolean') {\n    type = 'bool';\n  }\n\n  return type;\n}\n\nfunction constructHeading(op) {\n  const uniforms = Object.assign({}, op.uniform);\n  const inputKeys = Object.keys(op.input);\n  let head = 'precision highp float;\\n';\n\n  for (let i = 0; i < inputKeys.length; i += 1) {\n    const key = inputKeys[i];\n\n    uniforms[key] = { dtype: 'sampler2D' };\n  }\n\n  const uniformsKeys = Object.keys(uniforms);\n\n  for (let i = 0; i < uniformsKeys.length; i += 1) {\n    const key = uniformsKeys[i];\n\n    if (!validType(uniforms[key].dtype)) {\n      throw new Error(`Uniform ${key} has invalid type \"${uniforms[key].dtype}\"`);\n    }\n\n    head += `uniform ${uniforms[key].dtype} ${key};\\n`;\n  }\n  head += 'varying vec2 texCoords;\\n';\n  const constantsKeys = Object.keys(op.constant);\n\n  for (let i = 0; i < constantsKeys.length; i += 1) {\n    const key = constantsKeys[i];\n    let preparedValue = op.constant[key];\n    const valueType = typeof preparedValue;\n\n    if (valueType === 'number' && preparedValue % 1 === 0) {\n      preparedValue = preparedValue.toFixed(1);\n    }\n\n    const glValueType = getType(preparedValue);\n\n    if (!validType(glValueType)) {\n      throw new Error(`Constant ${key}, has invalid type \"${glValueType}\"`);\n    }\n\n    head += `#define ${key} ${preparedValue}\\n`;\n  }\n\n  return head;\n}\n\n\nfunction injectChunks(op) {\n  const separateWidth = 35;\n  const requiredChunks = [];\n\n  if (!ENV.SUPPORTS_FLOAT_TEXTURES) {\n    requiredChunks.push('float');\n  }\n\n  const dependencies = requiredChunks\n    .concat(op.chunks.filter((item, pos, self) => self.indexOf(item) === pos));\n\n  return dependencies.map((name) => {\n    const midString = ` Chunk ${name} `;\n    const pad = separateWidth - midString.length;\n    const head = `${'-'.repeat(Math.floor(pad / 2))}${midString}${'-'.repeat(Math.ceil(pad / 2))}`;\n\n    if (typeof chunks[name] === 'function') {\n      return `/*${head}*/\\n${chunks[name](op)}\\n/*${'-'.repeat(separateWidth)}*/`;\n    }\n\n    throw new TypeError(`Chunk \"${name}\" is not a function`);\n  }).join('\\n');\n}\n\nfunction hasMain(code) {\n  return !!(/void main\\([\\s\\S]+\\)([\\s]+)?{/.exec(code));\n}\n\nfunction constructKernel(op) {\n  let fullKernel;\n\n  if (hasMain(op.kernel)) {\n    fullKernel = op.kernel;\n  } else {\n    const head = constructHeading(op);\n    const dependencies = injectChunks(op);\n    const end = main(op);\n\n    fullKernel = [head, dependencies, op.kernel, end].join('\\n\\n');\n  }\n\n  if (ENV.DEBUG) {\n    console.groupCollapsed(op.name);\n    console.log(prepareSourceLines(fullKernel).join('\\n'));\n    console.groupEnd();\n  }\n\n  return fullKernel;\n}\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nconst AVAILABLE_GLSL_CHUNKS = ['pickCurrentValue', 'pickValue', 'float'];\n\nconst assert$$1 = (expression, msg) => {\n  if (!expression) {\n    throw new Error(msg);\n  }\n};\n\n\nconst assertShapesAreEqual$$1 = (a, b) => {\n  if (a.shape.length !== b.shape.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.shape.length; i += 1) {\n    if (a.shape[i] !== b.shape[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nconst isValidShape$$1 = shape => Array.isArray(shape)\n  && shape.length > 0\n  && !shape.some(n => n % 1 !== 0);\nconst isOperation$$1 = op => op instanceof Operation;\nconst isTensor$$1 = tensor => tensor instanceof Tensor;\nconst isValidGLSLChunk$$1 = name => AVAILABLE_GLSL_CHUNKS.includes(name);\nconst isValidGLSLVariableName$$1 = name => /^[A-Za-z](\\w+)?$/.test(name);\nconst isValidOperationShape$$1 = shape => shape[0] > 0 && shape[1] > 0;\n\nclass DeprecationError$$1 extends Error { }\n\nfunction deprecationWarning$$1(name, msg) {\n  console.warn(`GammaCV Deprecation Warning: \"${name}\" is deprecated${msg ? `, ${msg}` : ''}. \"${name}\" will be removed in next major version.`);\n}\n\nfunction deprecationError$$1(name, msg) {\n  throw new DeprecationError$$1(`GammaCV Deprecation Error: \"${name}\" is deprecated${msg ? `, ${msg}` : ''}. \"${name}\" and was removed.`);\n}\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nclass Operation extends GraphNode {\n  constructor(name) {\n    assert$$1(\n      typeof name !== 'undefined',\n      'Operation: Operation shouldn\\'t be unnamed.',\n    );\n    super(name);\n    this.dtype = null;\n    this.input = {};\n    this.uniform = {};\n    this.constant = {};\n    this.chunks = [];\n    this.inputKeys = [];\n    this.isInitialized = false;\n    this.lastCtx = Math.random();\n    this.cache = true;\n  }\n\n  run(sess, ctx, isRecalculated) {\n    assert$$1(\n      this.isInitialized,\n      'Operation: Unable to run unilialized operation.',\n    );\n\n    const gl = this.gl;\n    const outTexture = sess.texture[this.name];\n\n    if (\n      ctx === this.lastCtx\n      && this.cache\n      && !isRecalculated\n    ) {\n      outTexture.bind(this.program, false, this.inputKeys.length);\n      this.bindBuffer();\n\n      return false;\n    }\n\n    this.lastCtx = ctx;\n\n    gl.useProgram(this.program);\n\n    for (let i = 0; i < this.inputKeys.length; i += 1) {\n      const key = this.inputKeys[i];\n      const input = this.input[key];\n      const opName = input.name;\n      const texture = sess.texture[opName];\n\n      texture.bind(this.program, key, i);\n\n      if (isTensor$$1(input)) {\n        texture.set(input);\n      }\n    }\n\n    outTexture.bind(this.program, false, this.inputKeys.length);\n    this.bindBuffer();\n\n    gl.viewport(0, 0, (this.dtype === 'float32' ? 4 : 1) * this.shape[1], this.shape[0]);\n    gl.clearColor(0, 0, 0, 1);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n\n    return true;\n  }\n\n  unbindBuffer() {\n    const gl = this.gl;\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  }\n\n  bindBuffer() {\n    const gl = this.gl;\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\n  }\n\n  init(gl) {\n    if (!this.isInitialized) {\n      this.gl = gl;\n      this.program = gl.createProgram();\n      this.framebuffer = gl.createFramebuffer();\n\n      if (this.isInitialized) {\n        return false;\n      }\n\n      this.name = this.name;\n      this.shape = this.shape;\n      this.constant.OUT_VIEW = `vec2(${this.shape[1]}, ${this.shape[0]})`;\n      this.kernel = constructKernel(this);\n      // Initialization:\n      // - Kernel compilation\n      // - Uniforms initialization\n\n      // Kernel compilation.\n      try {\n        this.vertexShader = this.getShader('vertex', vertexShader);\n        gl.attachShader(this.program, this.vertexShader);\n        this.fragmentShader = this.getShader('fragment', this.kernel);\n        gl.attachShader(this.program, this.fragmentShader);\n        gl.linkProgram(this.program);\n        gl.useProgram(this.program);\n      } catch (err) {\n        processError(this.kernel, this.name, err);\n        throw new Error(`GPUProgram: Error during shader compilation.\\n${err.message}`);\n      }\n\n      this.attributes = {\n        aVertexPosition: new GLBuffer(\n          this.gl,\n          this.program,\n          'aVertexPosition',\n          'vec3',\n        ),\n        aTextureCoords: new GLBuffer(\n          this.gl,\n          this.program,\n          'aTextureCoords',\n          'vec2',\n        ),\n        aIndices: new GLBuffer(\n          this.gl,\n          this.program,\n          'aIndices',\n          'int',\n        ),\n      };\n\n      // Set buffer values\n      this.attributes.aVertexPosition.set([1.0, 1.0, 0.0, -1.0, 1.0, 0.0,\n        -1.0, -1.0, 0.0, 1.0, -1.0, 0.0]);\n      this.attributes.aTextureCoords.set([1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0]);\n      this.attributes.aIndices.set([0, 1, 2, 0, 2, 3]);\n\n      // Init uniforms and set default values\n      const uniformKeys = Object.keys(this.uniform);\n\n      for (let j = 0; j < uniformKeys.length; j += 1) {\n        const uniform = this.uniform[uniformKeys[j]];\n\n        this.uniform[uniformKeys[j]] = new GLUniform(\n          this.gl,\n          this.program,\n          uniform.name,\n          uniform.dtype,\n        );\n\n        if (uniform.defaultValue) {\n          this.uniform[uniformKeys[j]].set(uniform.defaultValue);\n        }\n      }\n\n      this.isInitialized = true;\n    }\n\n    return true;\n  }\n\n  getShader(type, src) {\n    const gl = this.gl;\n    let shader = null;\n\n    if (type === 'fragment') {\n      shader = gl.createShader(gl.FRAGMENT_SHADER);\n    } else {\n      shader = gl.createShader(gl.VERTEX_SHADER);\n    }\n\n    gl.shaderSource(shader, src);\n    gl.compileShader(shader);\n\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n      throw new Error(`An error occurred compiling the shaders: ${gl.getShaderInfoLog(shader)}`);\n    }\n\n    return shader;\n  }\n\n  traverse(handler, context) {\n    const inputNames = Object.keys(this.input);\n\n    for (let i = 0; i < inputNames.length; i += 1) {\n      const name = inputNames[i];\n\n      if (this.input[name] instanceof Operation) {\n        this.input[name].traverse(handler, context);\n      } else {\n        handler(this.input[name], context);\n      }\n    }\n\n    handler(this, context);\n  }\n\n  getDependencies() {\n    const path = [];\n    const inputNames = Object.keys(this.input);\n\n    for (let i = 0; i < inputNames.length; i += 1) {\n      const name = inputNames[i];\n\n      if (this.input[name] instanceof Operation) {\n        const innerDeps = this.input[name].getDependencies();\n\n        for (let j = 0; j < innerDeps.length; j += 1) {\n          if (path.indexOf(innerDeps[j]) === -1) {\n            path.push(innerDeps[j]);\n          }\n        }\n      }\n    }\n\n    path.push(this.name);\n\n    return path;\n  }\n\n  assignInput(name, input) {\n    this.input[name] = input;\n\n    if (this.inputKeys.indexOf(name) === -1) {\n      this.inputKeys.push(name);\n    }\n  }\n\n  cloneProp(name) {\n    const names = Object.keys(this[name]);\n    const prop = {};\n\n    for (let i = 0; i < names.length; i += 1) {\n      const cursor = names[i];\n\n      prop[cursor] = this[name][cursor];\n    }\n\n    return prop;\n  }\n\n  destroy() {\n    if (this.program) {\n      this.gl.deleteProgram(this.program);\n    }\n    if (this.vertexShader) {\n      this.gl.deleteShader(this.vertexShader);\n    }\n    if (this.fragmentShader) {\n      this.gl.deleteShader(this.fragmentShader);\n    }\n    if (this.framebuffer) {\n      this.gl.deleteFramebuffer(this.framebuffer);\n    }\n  }\n\n  clone() {\n    const op = new Operation(this.name.split(':')[0]);\n\n    op.input = this.cloneProp('input');\n    op.uniform = this.cloneProp('uniform');\n    op.constant = this.cloneProp('constant');\n    op.dtype = this.dtype;\n    op.kernel = this.kernel;\n    op.chunks = this.chunks;\n\n    return op;\n  }\n}\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nclass GPUTexture {\n  constructor(dtype, gl, unit, shape) {\n    if (dtype === 'float32' || dtype === 'uint8') {\n      this.unit = unit;\n      this.dtype = dtype;\n      this.gl = gl;\n      this.ctx = gl.createTexture();\n      this.shape = shape;\n\n      gl.bindTexture(gl.TEXTURE_2D, this.ctx);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n      this.allocate();\n    } else {\n      throw new Error(`GPUTexture: Invalid texture type, currently supported is: float32, uint8, but got ${dtype} `);\n    }\n  }\n\n  allocate() {\n    const gl = this.gl;\n    let width = this.shape[1];\n    let type = gl.UNSIGNED_BYTE;\n\n    if (this.dtype === 'float32') {\n      if (ENV.SUPPORTS_FLOAT_TEXTURES) {\n        type = gl.FLOAT;\n      } else {\n        width *= 4;\n      }\n    }\n\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      0,\n      gl.RGBA,\n      width,\n      this.shape[0],\n      0,\n      gl.RGBA,\n      type,\n      null,\n    );\n  }\n\n  set(tensor = null) {\n    const gl = this.gl;\n    let width = tensor.shape[1];\n    let type = gl.UNSIGNED_BYTE;\n    let data = tensor.data;\n\n    if (tensor.dtype === 'float32') {\n      if (ENV.SUPPORTS_FLOAT_TEXTURES) {\n        type = gl.FLOAT;\n      } else {\n        width *= 4;\n        data = tensor.uint8View;\n      }\n    }\n\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      0,\n      gl.RGBA,\n      width,\n      this.shape[0],\n      0,\n      gl.RGBA,\n      type,\n      data,\n    );\n  }\n\n  bind(program, name, unit) {\n    const gl = this.gl;\n\n    if (name) {\n      const location = gl.getUniformLocation(program, name);\n\n      gl.uniform1i(location, unit);\n    }\n\n    gl.activeTexture(gl.TEXTURE0 + unit);\n    gl.bindTexture(gl.TEXTURE_2D, this.ctx);\n\n    this.unit = unit;\n  }\n\n  unbind() {\n    const gl = this.gl;\n\n    gl.activeTexture(gl.TEXTURE0 + this.unit);\n    gl.bindTexture(gl.TEXTURE_2D, null);\n  }\n\n  delete() {\n    const gl = this.gl;\n\n    gl.deleteTexture(this.ctx);\n    this.gl = null;\n    this.program = null;\n    this.ctx = null;\n    gl.bindTexture(gl.TEXTURE_2D, null);\n  }\n}\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nfunction range(n) {\n  const result = new Array(n);\n\n  for (let i = 0; i < n; i += 1) {\n    result[i] = i;\n  }\n\n  return result;\n}\n\nfunction tensorFrom(input, cast = false) {\n  let out = null;\n\n  if (input instanceof Operation) {\n    out = new Tensor(cast || input.dtype, input.shape);\n  }\n\n  if (input instanceof Tensor) {\n    out = new Tensor(cast || input.dtype, input.shape);\n  }\n\n  return out;\n}\n\nfunction tensorClone(from, to) {\n  if (to.data.set) {\n    to.data.set(from.data);\n  } else {\n    for (let i = 0; i < to.size; i += 1) {\n      to.data[i] = from.data[i];\n    }\n  }\n}\n\n/**\n * @param {Tensor} input\n * @param {Tensor} [output]\n * @param {Array.<number>} invertShape\n */\n\nfunction tensorInvert(\n  input,\n  output = input,\n  invertShape = new Array(input.shape.length).fill(true),\n) {\n  const shape = input.shape;\n\n  if (input === output) {\n    input = input.clone();\n  }\n\n  if (input.shape.length !== output.shape.length) {\n    throw new Error('invertTensor: Unable to invert, input and output has different shapes');\n  }\n\n  const tmpArr = new Array(shape.length); // eslint-disable-line\n  let invert = () => { }; // eslint-disable-line\n\n  eval(`invert = function (coords) { ${invertShape.map((a, key) => a ? `tmpArr[${key}] = shape[${key}] - 1 - coords[${key}]` : `tmpArr[${key}] = coords[${key}]`).join(';')}; return tmpArr; }`); // eslint-disable-line\n\n  for (let i = 0; i < input.size; i += 1) {\n    const coords = Tensor.IndexToCoord(shape, i);\n    const inverted = invert(coords, tmpArr);\n\n    output.set(...inverted, input.get(...coords));\n  }\n\n  return output;\n}\n\n\nconst tensorAssertEqual = (actual, expected) => {\n  if (!assertShapesAreEqual$$1(actual, expected)) {\n    return false;\n  }\n\n  for (let i = 0; i < actual.size; i += 1) {\n    if (actual.data[i] !== expected.data[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nconst tensorAssertCloseEqual = (actual, expected, delta = 1) => {\n  if (!assertShapesAreEqual$$1(actual, expected)) {\n    return false;\n  }\n\n  for (let i = 0; i < actual.size; i += 1) {\n    if (Math.abs(actual.data[i] - expected.data[i]) > delta) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nconst tensorAssertMSEEqual = (actual, expected, delta = 1) => {\n  if (!assertShapesAreEqual$$1(actual, expected)) {\n    return false;\n  }\n\n  let mse = 0;\n\n  for (let i = 0; i < actual.size; i += 1) {\n    mse += (actual.data[i] - expected.data[i]) ** 2;\n  }\n\n  mse = Math.sqrt(mse) / actual.size;\n\n  return mse < delta;\n};\n\n/**\n * @param {Tensor} input\n * @param {Tensor} [output]\n * @param {Array.<number>} invertShape\n */\n\nfunction flipTensor(\n  input,\n  output = input,\n  invertShape = new Array(input.shape.length).fill(true),\n) {\n  const shape = input.shape;\n\n  if (input === output) {\n    input = input.clone();\n  }\n\n  if (input.shape.length !== output.shape.length) {\n    throw new Error('invertTensor: Unable to invert, input and output has different shapes');\n  }\n\n  const tmpArr = new Array(shape.length); // eslint-disable-line\n  let invert = () => { }; // eslint-disable-line\n\n  eval(`invert = function (coords) { ${invertShape.map((a, key) => a ? `tmpArr[${key}] = shape[${key}] - 1 - coords[${key}]` : `tmpArr[${key}] = coords[${key}]`).join(';')}; return tmpArr; }`); // eslint-disable-line\n\n  for (let i = 0; i < input.size; i += 1) {\n    const coords = Tensor.IndexToCoord(shape, i);\n    const inverted = invert(coords, tmpArr);\n\n    output.set(...inverted, input.get(...coords));\n  }\n\n  return output;\n}\n\n/**\n * @deprecated\n */\nfunction invertTensor(...args) {\n  deprecationWarning$$1('invertTensor', 'use \"flipTensor\" instead');\n\n  return flipTensor(...args);\n}\n\n/**\n * Map tensor by each component\n * @param {Tensor} t - input\n * @param {function} fn\n * @param {Tensor} [out] - output\n */\nfunction tensorMap(t, fn, out = t) {\n  for (let i = 0; i < t.size; i += 1) {\n    out.data[i] = fn(t.data[i], i);\n  }\n}\n\n/**\n * Create tensor filled with 1\n * @param {string} dtype\n * @param {array} shape\n * @returns {Tensor}\n */\nfunction tensorOnes(dtype, shape) {\n  const result = new Tensor(dtype, shape);\n\n  tensorMap(result, () => 1);\n\n  return result;\n}\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\n/**\n * @class Tensor\n * @description N Dimensional data view, that helps create, store, manipulate data.\n */\nclass Tensor extends GraphNode {\n  /**\n   * @param {string} dtype - the data type for tensor instance\n   * @param {Array.<number>} shape - the list of integers,\n   * @param {DataView|Array} [data] - initial data to store\n   * @param {Array.<number>} [stride] - custom mapping from plain to NDArray\n   * @param {number} [offset] - number of data elements to skip\n   */\n  constructor(dtype, shape, data, stride, offset = 0) {\n    super('Tensor');\n    this.dtype = dtype;\n    this.shape = shape || [data.length];\n\n    assert$$1(isValidShape$$1(this.shape), 'Shape is not valid');\n    if (stride) {\n      assert$$1(isValidShape$$1(stride), 'Stride is not valid');\n      assert$$1(this.shape.length === stride.length, 'Stride length should be equal to shape length');\n    }\n    assert$$1(typeof offset === 'number' && offset % 1 === 0, `Offset should be integer, but got ${offset}`);\n\n    this.size = Tensor.GetSize(this.shape);\n    this.stride = stride || this._defineStride(this.shape);\n    this.offset = offset;\n\n\n    this._compileJITMethods();\n\n    if (typeof data === 'undefined') {\n      this.data = Tensor.Malloc(dtype, this.size);\n      this.empty = Tensor.Malloc(dtype, this.size);\n    } else {\n      this.assign(data);\n    }\n\n    if (!ENV.SUPPORTS_FLOAT_TEXTURES && dtype === 'float32') {\n      this.uint8View = new Uint8Array(this.data.buffer);\n    }\n  }\n\n  _compileJITMethods() {\n    const indices = range(this.shape.length);\n    const argsStr = indices.map(i => `i${i}`).join(',');\n    const indexStr = `${this.offset}+${indices.map(i => `${this.stride[i]}*i${i}`).join('+')}`;\n\n    /**\n     * @name get\n     * @method\n     * @description Get data element by coordinates\n     * @param {...number} x - coordinates\n     *\n     * Require N number arguments, where n - dimention of a tensor.\n     * @return {number}\n     * @example\n     * const t = new gm.Tensor('uint8', [2, 3], new Uint8Array([1, 2, 3, 4, 5, 6]));\n     * t.get(0, 0); // 1\n     * t.get(0, 1); // 2\n     * t.get(1, 2); // 6\n     */\n    this.get = new Function(`return function get(${argsStr}) { return this.data[${indexStr}]; }`)(); // eslint-disable-line\n\n    /**\n     * @name set\n     * @method\n     * @description Put value to tensor by coordinates\n     * @param {...number} x - coordinates\n     * @param {number} v - value\n     *\n     * @example\n     * const t = new gm.Tensor('uint8', [2, 3], new Uint8Array([1, 2, 3, 4, 5, 6]));\n     * t.set(0, 0, 10); // 1\n     * t.set(0, 1, 15); // 2\n     * t.set(1, 2, 20); // 6\n     *\n     * console.log(t.data); // <Uint8Array[10, 15, 3, 4, 5, 20]>\n     */\n    this.set = new Function(`return function get(${argsStr}, v) { this.data[${indexStr}] = v; }`)(); // eslint-disable-line\n\n    /**\n     * @name index\n     * @method\n     * @description Get's index in plain data view of data element specified by coordinates\n     * @param {...number} x - coordinates\n     *\n     * Require N number arguments, where n - dimention of a tensor.\n     * @return {number}\n     * @example\n     * const t = new gm.Tensor('uint8', [2, 3], new Uint8Array([1, 2, 3, 4, 5, 6]));\n     * t.index(0, 0); // 0\n     * t.index(0, 1); // 1\n     * t.index(1, 2); // 5\n     */\n    this.index = new Function(`return function get(${argsStr}, v) { return ${indexStr}; }`)(); // eslint-disable-line\n  }\n\n  _defineStride(shape) {\n    const d = shape.length;\n    const stride = new Array(d);\n\n    for (let i = d - 1, sz = 1; i >= 0; i -= 1) {\n      stride[i] = sz;\n      sz *= this.shape[i];\n    }\n\n    return stride;\n  }\n\n  /**\n   * @name Tensor.assign\n   * @param {DataView|Array} data\n   * @returns {Tensor} self\n   */\n  assign(data) {\n    const nextDtype = Tensor.DefineType(data);\n    const nextLength = data.length;\n\n    assert$$1(nextDtype === this.dtype, `Different dtypes assigned: \\n   expected - ${this.dtype} \\n   actual - ${nextDtype}`);\n    assert$$1(nextLength === this.size + this.offset, `Different sizes assigned: \\n   expected - ${this.size + this.offset} \\n   actual - ${nextLength}`);\n\n    this.data = data;\n\n    return this;\n  }\n\n  /**\n   * @description Write zeros into tensor's data\n   * @return {Tensor} self\n   */\n  relese() {\n    if (this.empty) {\n      this.data.set(this.empty);\n    } else {\n      this.data = Tensor.Malloc(this.dtype, this.size);\n    }\n\n    return this;\n  }\n\n  /**\n   * @return {Tensor} a shallow copy, new instance\n   */\n  clone() {\n    const result = new Tensor(this.dtype, this.shape, undefined, this.stride, this.offset);\n\n    tensorClone(this, result);\n\n    return result;\n  }\n\n  /**\n   * @static\n   * @param {Array.<number>} shape\n   * @param {number} index\n   * @return {Array.<number>} coordinets that maps to the entered index\n   */\n  static IndexToCoord(shape, index) {\n    const res = new Array(shape.length);\n    let _index = index;\n    let shapeSum = shape.reduce((s, b) => s * b);\n\n    for (let i = 0; i <= shape.length - 2; i += 1) {\n      shapeSum /= shape[i];\n      const r = ~~(_index / shapeSum);\n\n      _index %= shapeSum;\n      res[i] = r;\n    }\n    res[res.length - 1] = _index % shape[shape.length - 1];\n\n    return res;\n  }\n\n  /**\n   * @static\n   * @param {Array.<number>} shape\n   * @param {Array.<number>} coords\n   * @return {number} index that mapped from entered coords\n   */\n  static CoordToIndex(shape, coords) {\n    let shapeSum = 1;\n    let sum = 0;\n\n    for (let i = shape.length - 1; i >= 0; i -= 1) {\n      sum += shapeSum * coords[i];\n      shapeSum *= shape[i];\n    }\n\n    return sum;\n  }\n\n  /**\n   * @static\n   * @param {string} dtype\n   * @param {number} size\n   * @return {Tensor}\n   */\n  static Malloc(dtype, size) {\n    switch (dtype) {\n      case 'uint8':\n        return new Uint8Array(size);\n      case 'uint16':\n        return new Uint16Array(size);\n      case 'uint32':\n        return new Uint32Array(size);\n      case 'int8':\n        return new Int8Array(size);\n      case 'int16':\n        return new Int16Array(size);\n      case 'int32':\n        return new Int32Array(size);\n      case 'float32':\n        return new Float32Array(size);\n      case 'float64':\n        return new Float64Array(size);\n      case 'uint8c':\n        return new Uint8ClampedArray(size);\n      case 'array':\n        return new Array(size);\n      default:\n        throw new Error(`Unexpected type: ${dtype}.`);\n    }\n  }\n\n  /**\n   * @static\n   * @description Define data type of an argument\n   * @param {DataView|Array} data\n   * @return {string}\n   * @example\n   * gm.Tensor.DefineType(new Float32Array()); // float32\n   */\n  static DefineType(buffer) {\n    const str = Object.prototype.toString.call(buffer);\n\n    switch (str) {\n      case '[object Uint8Array]':\n        return 'uint8';\n      case '[object Uint16Array]':\n        return 'uint16';\n      case '[object Uint32Array]':\n        return 'uint32';\n      case '[object Int8Array]':\n        return 'int8';\n      case '[object Int16Array]':\n        return 'int16';\n      case '[object Int32Array]':\n        return 'int32';\n      case '[object Float32Array]':\n        return 'float32';\n      case '[object Float64Array]':\n        return 'float64';\n      case '[object Uint8ClampedArray]':\n        return 'uint8c';\n      case '[object Array]':\n        return 'array';\n      default:\n        throw new Error(`Unknown dtype: ${str}.`);\n    }\n  }\n\n  /**\n   * @static\n   * @description Generate DataView\n   * @param {string} dtype - data type of view\n   * @param {DataView|Array} data - initial data\n   * @return {DataView|Array}\n   */\n  static GetTypedArray(dtype, data) {\n    if (dtype === Tensor.DefineType(data)) {\n      return data;\n    }\n\n    switch (dtype) {\n      case 'uint8':\n        return new Uint8Array(data);\n      case 'uint16':\n        return new Uint16Array(data);\n      case 'uint32':\n        return new Uint32Array(data);\n      case 'int8':\n        return new Int8Array(data);\n      case 'int16':\n        return new Int16Array(data);\n      case 'int32':\n        return new Int32Array(data);\n      case 'float32':\n        return new Float32Array(data);\n      case 'float64':\n        return new Float64Array(data);\n      case 'uint8c':\n        return new Uint8ClampedArray(data);\n      case 'array':\n        return new Array(data);\n      default:\n        throw new Error(`Unknown type: ${dtype}.`);\n    }\n  }\n\n  /**\n   * @static\n   * @param {Array.<number>} shape\n   * @return {number} Number of elements that described by shape\n   */\n  static GetSize(shape) {\n    return shape.reduce((a, b) => a * b, 1);\n  }\n}\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\n/**\n * @class Session\n * @description This is a runtime which allows you to run computational graphs on different backends\n */\nclass Session {\n  constructor() {\n    this.canvas = document.createElement('canvas');\n    this.canvas.width = 1;\n    this.canvas.height = 1;\n    this.initWebGL(this.canvas);\n\n    this.operation = {};\n    this.texture = {};\n    this.textureCount = 0;\n  }\n\n  initWebGL(canvas, opts) {\n    this.canvas = canvas;\n    const gl = this.canvas.getContext('webgl', opts);\n    const float32Ext = gl.getExtension('OES_texture_float');\n\n    assert$$1(\n      !!gl,\n      'WebGL not supported.',\n    );\n    assert$$1(\n      !!float32Ext,\n      'Unable to find extension OES_texture_float',\n    );\n\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    this.gl = gl;\n  }\n\n  /**\n   * @description Intialize operations for session\n   * @param {Operation} node - operation chain to be used in session\n   */\n  init(node) {\n    // Make sure we trying to initialize true Operation\n    assert$$1(\n      !!node,\n      'Session: Unable to initialize undefined operation',\n    );\n\n    assert$$1(\n      isOperation$$1(node) || isTensor$$1(node),\n      'Session: Unable to initialize operation with invalid input type',\n    );\n\n    if (isOperation$$1(node)) {\n      // Traversing of all the operations and flatten it to key-value storage\n      node.traverse((input, sess) => {\n        sess.operation[input.name] = input;\n      }, this);\n    }\n\n    if (isTensor$$1(node)) {\n      this.operation[node.name] = node;\n    }\n\n    this.update();\n  }\n\n  update() {\n    const gl = this.gl;\n    const opKeys = Object.keys(this.operation);\n\n    for (let i = 0; i < opKeys.length; i += 1) {\n      const operation = this.operation[opKeys[i]];\n\n      if (operation instanceof Operation) {\n        operation.init(this.gl);\n      }\n\n      if (!this.texture[opKeys[i]]) {\n        this.texture[opKeys[i]] = new GPUTexture(\n          operation.dtype,\n          this.gl,\n          this.textureCount,\n          operation.shape,\n        );\n\n        if (operation instanceof Operation) {\n          gl.bindFramebuffer(gl.FRAMEBUFFER, operation.framebuffer);\n          gl.framebufferTexture2D(\n            gl.FRAMEBUFFER,\n            gl.COLOR_ATTACHMENT0,\n            gl.TEXTURE_2D,\n            this.texture[opKeys[i]].ctx,\n            0,\n          );\n          gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        }\n\n        this.textureCount += 1;\n      }\n    }\n  }\n\n  /**\n   * @description Run Operation\n   * @param {Operation} op - operation to run\n   * @param {*} ctx - context of a run, passing the same context twice in a raw\n   *    will use cached result\n   * @param {Tensor} [output] - if passed, the output is put into it.\n   */\n  runOp(op, ctx, output = false) {\n    const sequence = op.sequence;\n    let isRecalculated = false;\n\n    for (let i = 0; i < sequence.length; i += 1) {\n      const key = sequence[i];\n      const operation = this.operation[key];\n      const isLastOp = i === (sequence.length - 1);\n\n      if (operation.run(this, ctx, isRecalculated)) {\n        isRecalculated = true;\n      } else {\n        isRecalculated = false;\n      }\n\n      if (output && output instanceof Tensor && isLastOp) {\n        this.readToTensor(output);\n      }\n    }\n  }\n\n  /**\n   * @description Destroy all initialized operations,\n   * texture and outher data connected this session.\n   */\n  destroy() {\n    const glLoseContext = this.gl.getExtension('WEBGL_lose_context');\n    const textures = Object.keys(this.texture);\n    const operations = Object.keys(this.operation);\n\n    if (glLoseContext) {\n      glLoseContext.loseContext();\n    }\n\n    for (let i = 0; i < textures.length; i += 1) {\n      this.texture[textures[i]].delete();\n    }\n\n    for (let i = 0; i < operations.length; i += 1) {\n      const op = this.operation[operations[i]];\n\n      if (op instanceof Operation) {\n        op.destroy();\n      }\n    }\n\n    this.canvas = null;\n    this.operation = {};\n    this.texture = {};\n    this.gl = null;\n    this.textureCount = 0;\n  }\n\n  readToTensor(tensor) {\n    const gl = this.gl;\n    let width = tensor.shape[1];\n    let type = gl.UNSIGNED_BYTE;\n    let data = tensor.data;\n\n    if (tensor.dtype === 'float32') {\n      if (ENV.SUPPORTS_FLOAT_TEXTURES) {\n        type = gl.FLOAT;\n      } else {\n        width *= 4;\n        data = tensor.uint8View;\n      }\n    }\n\n    gl.readPixels(\n      0,\n      0,\n      width,\n      tensor.shape[0],\n      gl.RGBA,\n      type,\n      data,\n    );\n  }\n}\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\n/**\n * @name RegisterOperation\n */\nclass RegisterOperation {\n  constructor(name) {\n    this.op = new Operation(name);\n    this.name = name;\n    this.checkShape = (a) => {\n      const keys = Object.keys(a);\n\n      return a[keys[0]];\n    };\n    this.preCompile = () => {};\n    this.postCompile = () => {};\n    this.chunks = [];\n  }\n\n  GLSLKernel(kernel) {\n    assert$$1(\n      typeof kernel === 'string',\n      'RegisterOperation: The kernel should be a string but it is not.',\n    );\n    this.op.kernel = kernel;\n\n    return this;\n  }\n\n  LoadChunk(...chunks) {\n    for (const chunk of chunks) {\n      assert$$1(\n        isValidGLSLChunk$$1(chunk),\n        `There is no available GLSL chunk supported: ${chunk}`,\n      );\n    }\n\n    this.op.chunks = this.op.chunks.concat(chunks);\n\n    return this;\n  }\n\n  Input(name, dtype) {\n    assert$$1(isValidGLSLVariableName$$1(name));\n    this.op.input[name] = { name, dtype };\n\n    return this;\n  }\n\n  Output(dtype) {\n    assert$$1(\n      this.op.dtype === null,\n      'RegisterOperation: The operation allows a single output.',\n    );\n\n    this.op.dtype = dtype;\n\n    return this;\n  }\n\n  Constant(name, value) {\n    assert$$1(isValidGLSLVariableName$$1(name));\n    this.op.constant[name] = value;\n\n    return this;\n  }\n\n  SetShapeFn(fn) {\n    assert$$1(typeof fn === 'function', 'SetShapeFn should receive function in first argument');\n    this.checkShape = fn;\n\n    return this;\n  }\n\n  PreCompile(fn) {\n    assert$$1(typeof fn === 'function', 'PreCompile should receive function in first argument');\n    this.preCompile = fn;\n\n    return this;\n  }\n\n  PostCompile(fn) {\n    assert$$1(typeof fn === 'function', 'PostCompile should receive function in first argument');\n    this.postCompile = fn;\n\n    return this;\n  }\n\n  Uniform(name, dtype, defaultValue) {\n    assert$$1(isValidGLSLVariableName$$1(name));\n    this.op.uniform[name] = { name, dtype, defaultValue };\n\n    return this;\n  }\n\n  Compile(input) {\n    const op = this.op.clone();\n    const inputShapes = {};\n    const keys = Object.keys(input);\n\n    this.preCompile(op);\n\n    for (let i = 0; i < keys.length; i += 1) {\n      const key = keys[i];\n      const inputNode = input[key];\n\n      assert$$1(\n        !!inputNode,\n        `RegisterOperation:${op.name}.${key}:\n         Can't compile operation with undefined input.`,\n      );\n\n      assert$$1(\n        isTensor$$1(inputNode) || isOperation$$1(inputNode),\n        `RegisterOperation:${op.name}.${key}:\n         Can't compile operation with invalid input type.\n         You can only use Tensor or another Operation to be an input`,\n      );\n\n      inputShapes[key] = input[key].shape;\n      op.assignInput(key, input[key]);\n    }\n\n    op.shape = this.checkShape(inputShapes);\n    op.sequence = op.getDependencies();\n\n    return op;\n  }\n}\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nfunction initDrawable(canvas, output, updater) {\n  let flag = false;\n\n  canvas.onmousedown = () => { flag = true; };\n  canvas.onmouseup = () => { flag = false; };\n  canvas.onmousemove = (e) => {\n    if (flag) {\n      output.set(e.offsetY, e.offsetX, 255);\n\n      if (updater) {\n        updater();\n      }\n    }\n  };\n\n  return () => {\n    canvas.onmousedown = null;\n    canvas.onmouseup = null;\n    canvas.onmousemove = null;\n  };\n}\n\nfunction initMouseTracking(canvas, handler) {\n  canvas.onmousemove = e => handler(e.offsetX, e.offsetY);\n\n  return () => {\n    canvas.onmousemove = null;\n  };\n}\n\n\n/**\n * toImageData\n * @param {Tensor} img\n * @param {boolean} rgba\n * @return {ImageData}\n */\n\nfunction toImageData(img, rgba = false, transposed = false) {\n  const imageData = new ImageData(img.shape[1], img.shape[0]);\n  const size = img.shape[0] * img.shape[1];\n\n  if (rgba && img.dtype === 'uint8') {\n    imageData.data.set(img.data);\n\n    return imageData;\n  }\n\n  if (!rgba) {\n    for (let i = 0; i < size; i += 1) {\n      const y = ~~(i / img.shape[0]);\n      const x = i - (y * img.shape[1]);\n      const val = img.data[i];\n      let offset = 0;\n\n      if (!transposed) {\n        offset = ((y * img.shape[1]) + x) * 4;\n      } else {\n        offset = ((x * img.shape[0]) + y) * 4;\n      }\n\n      imageData.data[offset + 0] = val;\n      imageData.data[offset + 1] = val;\n      imageData.data[offset + 2] = val;\n      imageData.data[offset + 3] = 255;\n    }\n\n    return imageData;\n  }\n\n  if (img.dtype === 'float32') {\n    for (let i = 0; i < img.size; i += 1) {\n      imageData.data[i] = img.data[i] * 255;\n    }\n  } else {\n    for (let i = 0; i < img.size; i += 1) {\n      imageData.data[i] = img.data[i];\n    }\n  }\n\n  return imageData;\n}\n\nfunction getImageData(canvas, x = 0, y = 0, w = canvas.width, h = canvas.height) {\n  return canvas.getContext('2d').getImageData(x, y, w, h);\n}\n\nfunction putImageData(\n  canvas,\n  imageData,\n  x = 0, y = 0, dx = 0, dy = 0, dw = imageData.width, dh = imageData.height,\n  clear,\n) {\n  if (imageData.width !== canvas.width || imageData.height !== canvas.height || clear) {\n    canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);\n  }\n\n  return canvas.getContext('2d').putImageData(imageData, x, y, dx, dy, dw, dh);\n}\n\n/**\n * @param {HTMLCanvasElement} canvas\n * @param {Tensor} img\n * @param {boolean} rgba\n */\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nfunction canvasFromTensor(canvas, img, rgba = false, transposed = false) {\n  if (!(img instanceof Tensor)) {\n    throw Error('tensorToCanvas: Input tensor invalid');\n  }\n\n  if (img.shape[2] && img.shape[2] === 4) {\n    rgba = true;\n  }\n\n  const imageData = toImageData(img, rgba, transposed);\n\n  canvas.getContext('2d').putImageData(imageData, 0, 0);\n}\n\nfunction canvasToTensor(canvas, dst) {\n  const imgData = canvas.getContext('2d').getImageData(0, 0, dst.shape[1], dst.shape[0]);\n\n  if (dst) {\n    switch (dst.dtype) {\n      case 'uint8': {\n        dst.assign(new Uint8Array(imgData.data));\n        break;\n      }\n      case 'uint8c': {\n        dst.assign(imgData.data);\n        break;\n      }\n      case 'float32':\n      default: {\n        dst.assign(new Float32Array(imgData.data));\n        break;\n      }\n    }\n  }\n}\n\nconst canvasDrawLine = (canvas, line, color = 'rgba(255, 0, 0, 0.5)', width = 1) => {\n  const context = canvas.getContext('2d');\n\n  context.beginPath();\n  if (Array.isArray(line)) {\n    context.moveTo(line[0], line[1]);\n    context.lineTo(line[2], line[3]);\n  } else {\n    context.moveTo(line.data[0], line.data[1]);\n    context.lineTo(line.data[2], line.data[3]);\n  }\n  context.strokeStyle = color;\n  context.lineWidth = width;\n  context.stroke();\n  context.closePath();\n};\n\nconst canvasDrawCircle = (canvas, coords, radius = 5, stroke = '#ff0000') => {\n  const context = canvas.getContext('2d');\n\n  context.beginPath();\n  context.arc(coords[0], coords[1], radius, 0, (2 * Math.PI));\n  context.strokeStyle = stroke;\n  context.stroke();\n};\n\nconst canvasFillCircle = (canvas, coords, radius, fill = '#ff0000') => {\n  const context = canvas.getContext('2d');\n\n  context.beginPath();\n  context.arc(coords[0], coords[1], radius, 0, (2 * Math.PI));\n  context.fillStyle = fill;\n  context.fill();\n};\n\nconst clearCanvas = (canvas) => {\n  const context = canvas.getContext('2d');\n\n  context.clearRect(0, 0, canvas.width, canvas.height);\n};\n\nconst canvasDrawRect = (canvas, rect, color = 'rgba(255, 0, 0, 1)', width = 1, cross = false, fill = false) => {\n  const context = canvas.getContext('2d');\n\n  context.beginPath();\n  context.moveTo(rect.ax, rect.ay);\n  context.lineTo(rect.bx, rect.by);\n  context.lineTo(rect.cx, rect.cy);\n  context.lineTo(rect.dx, rect.dy);\n  context.lineTo(rect.ax, rect.ay);\n\n  if (cross) {\n    context.lineTo(rect.ax, rect.ay);\n    context.lineTo(rect.cx, rect.cy);\n    context.lineTo(rect.bx, rect.by);\n    context.lineTo(rect.dx, rect.dy);\n    context.lineTo(rect.ax, rect.ay);\n  }\n\n  context.strokeStyle = color;\n  if (fill) {\n    context.fillStyle = color;\n    context.fill();\n  }\n  context.stroke();\n  context.lineWidth = width;\n  context.closePath();\n};\n\nfunction canvasFill(canvas, color) {\n  const ctx = canvas.getContext('2d');\n\n  ctx.fillStyle = color;\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\n}\n\nconst canvasClear = (canvas) => {\n  canvas.width = canvas.width;\n  canvas.height = canvas.height;\n};\n\nconst canvasInit = (id, width, height) => {\n  const canvas = document.querySelector(id);\n\n  canvas.width = width;\n  canvas.height = height;\n\n  return canvas;\n};\n\nconst canvasCreate = (width, height) => {\n  const canvas = document.createElement('canvas');\n\n  canvas.width = width;\n  canvas.height = height;\n\n  return canvas;\n};\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nfunction imageTensorFromURL(url, type = 'uint8', outShape, cors = false) {\n  return new Promise((reolve, reject) => {\n    const image = document.createElement('img');\n    const canvas = document.createElement('canvas');\n\n    const context = canvas.getContext('2d');\n\n    let width;\n    let height;\n\n    image.src = url;\n\n    if (cors) {\n      image.crossOrigin = 'Anonimus';\n    }\n\n    image.onload = () => {\n      if (outShape) {\n        width = outShape[1];\n        height = outShape[0];\n      } else {\n        width = image.width;\n        height = image.height;\n      }\n      canvas.width = width;\n      canvas.height = height;\n      context.drawImage(image, 0, 0, width, height);\n\n      let data;\n      const imgData = context.getImageData(0, 0, width, height);\n\n      switch (type) {\n        case 'uint8': {\n          data = new Uint8Array(imgData.data.buffer);\n          break;\n        }\n        case 'float32': {\n          data = new Float32Array(imgData.data);\n          break;\n        }\n        default: {\n          data = imgData.data;\n        }\n      }\n\n      const dst = new Tensor(type, [height, width, 4], data);\n\n      reolve(dst);\n    };\n\n    image.onerror = reject;\n  });\n}\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n/**\n *\n * @param {Ratio} r\n * @param {number} height\n */\nfunction getWidth(r, h) {\n  return r * h;\n}\n\n/**\n *\n * @param {Ratio} r\n * @param {number} width\n */\nfunction getHeight(r, w) {\n  return w / r;\n}\n\n/**\n *\n * @param {Ratio} r\n * @param {number} maxWidth\n * @param {number} [maxHeight]\n * @return {Size}\n */\nfunction getMaxAvailableSize(r, maxWidth, maxHeight) {\n  if (maxWidth) {\n    const _height = getHeight(r, maxWidth);\n\n    if (_height <= maxHeight) {\n      return {\n        width: maxWidth,\n        height: _height,\n      };\n    }\n  }\n\n  return {\n    width: getWidth(r, maxHeight),\n    height: maxHeight,\n  };\n}\n\n/**\n *\n * @param {Ratio} r\n * @param {number} minWidth\n * @param {number} [minHeight]\n * @return {Size}\n */\nfunction getMinAvailableSize(r, minWidth, minHeight) {\n  if (minWidth) {\n    const _height = getHeight(r, minWidth);\n\n    if (_height > minHeight) {\n      return {\n        width: minWidth,\n        height: _height,\n      };\n    }\n  }\n\n  return {\n    width: getWidth(r, minHeight),\n    height: minHeight,\n  };\n}\n\nclass CaptureVideo {\n  static IsAvailable() {\n    const cfg = {\n      video: {\n        width: { min: 480, ideal: 1080, max: 1920 },\n        height: { min: 480, ideal: 1080, max: 1920 },\n      },\n    };\n\n    navigator.getUserMedia = navigator.getUserMedia\n      || navigator.webkitGetUserMedia\n      || navigator.mozGetUserMedia\n      || navigator.msGetUserMedia\n      || navigator.oGetUserMedia;\n\n    const ua = navigator.userAgent;\n\n    if (ua.indexOf('Safari') !== -1 && ua.indexOf('Chrome') === -1) {\n      delete cfg.video.width;\n      delete cfg.video.height;\n    }\n\n    let getStream = Promise.resolve();\n\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n      getStream = getStream.then(() => navigator.mediaDevices.getUserMedia(cfg));\n    } else if (navigator.getUserMedia) {\n      getStream = getStream.then(() => new Promise(res => navigator.getUserMedia(cfg, res)));\n    }\n\n    return getStream\n      .then((stream) => {\n        const tracks = stream.getTracks();\n        const deviceID = tracks[0].getSettings().deviceId;\n\n        tracks.forEach(track => track.stop());\n\n        return deviceID || true;\n      })\n      .catch(() => Promise.resolve(false));\n  }\n\n  static getDevices() {\n    if ('mediaDevices' in navigator && 'enumerateDevices' in navigator.mediaDevices) {\n      return navigator.mediaDevices.enumerateDevices()\n        .then(devices => devices.filter(device => device.kind === 'videoinput'));\n    }\n\n    return Promise.resolve(null);\n  }\n\n  constructor(width, height) {\n    this.video = document.createElement('video');\n    this.video.muted = true;\n    this.video.playsInline = true;\n    this.canvas = document.createElement('canvas');\n    this.canvasCtx = this.canvas.getContext('2d');\n    this.sourceCanvas = document.createElement('canvas');\n    this.sourceCanvasCtx = this.sourceCanvas.getContext('2d');\n\n    this.width = width;\n    this.height = height;\n\n    this.sourceWidth = width;\n    this.sourceHeight = height;\n\n    this.setSize(width, height);\n    this.track = null;\n  }\n\n  setSize(width, height) {\n    this.width = width;\n    this.height = height;\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.sourceCanvas.width = width;\n    this.sourceCanvas.height = height;\n    this.sourceMinWidth = width;\n    this.sourceMinHeight = height;\n  }\n\n  setSourceSize(width, height) {\n    const scaledSize = getMinAvailableSize(width / height, this.width, this.height);\n    const size = getMaxAvailableSize(this.width / this.height, width, height);\n    const scaledMinSize = getMinAvailableSize(width / height, size.width, size.height);\n\n    this.sourceMinWidth = scaledSize.width;\n    this.sourceMinHeight = scaledSize.height;\n\n    this.sourceWidth = scaledMinSize.width;\n    this.sourceHeight = scaledMinSize.height;\n\n    this.sourceCanvas.width = size.width;\n    this.sourceCanvas.height = size.height;\n  }\n\n  getDevice() {\n    if (this.track) {\n      return this.track.getSettings().deviceId;\n    }\n\n    return null;\n  }\n\n  start(deviceID, exactFacingMode = '') {\n    this.started = true;\n    const cfg = {\n      video: {\n        width: { min: 240, ideal: 1080, max: 1920 },\n        height: { min: 240, ideal: 1080, max: 1920 },\n        aspectRatio: { exact: this.width / this.height },\n        deviceId: deviceID ? { ideal: deviceID } : undefined,\n        facingMode: exactFacingMode ? { exact: exactFacingMode } : null,\n      },\n    };\n\n    const ua = navigator.userAgent;\n\n    if (ua.indexOf('Safari') !== -1 && ua.indexOf('Chrome') === -1) {\n      delete cfg.video.width;\n      delete cfg.video.height;\n      delete cfg.video.aspectRatio;\n    }\n\n    navigator.getUserMedia = navigator.getUserMedia\n      || navigator.webkitGetUserMedia\n      || navigator.mozGetUserMedia\n      || navigator.msGetUserMedia\n      || navigator.oGetUserMedia;\n\n    let getStream = Promise.resolve();\n\n\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n      getStream = getStream.then(() => navigator.mediaDevices.getUserMedia(cfg));\n    } else if (navigator.getUserMedia) {\n      getStream = getStream.then(() => new Promise(res => navigator.getUserMedia(cfg, res)));\n    }\n\n    return getStream.then((stream) => {\n      if (stream) {\n        const tracks = stream.getTracks();\n\n        if (!this.started) {\n          tracks.forEach(t => t.stop());\n\n          return null;\n        }\n        if ('srcObject' in this.video) {\n          this.video.srcObject = stream;\n        } else {\n          this.video.src = window.URL.createObjectURL(stream);\n        }\n\n        this.track = tracks[0];\n\n        return this.video.play()\n          .then(() => this.setSourceSize(this.video.videoWidth, this.video.videoHeight));\n      }\n      throw new Error('getUserMedia not found or no stream was created');\n    });\n  }\n\n  stop() {\n    this.started = false;\n    if (this.track) {\n      this.track.stop();\n      this.track = null;\n    }\n  }\n\n  drawImage(ctx, w, h, ow, oh) {\n    ctx.drawImage(\n      this.video,\n      (ow - w) / -2,\n      (oh - h) / -2,\n      ow,\n      oh,\n    );\n  }\n\n  getImageBuffer(\n    type,\n    ctx = this.canvasCtx,\n    width = this.width,\n    height = this.height,\n    x = 0,\n    y = 0,\n    w = width,\n    h = height,\n    originW = this.sourceMinWidth,\n    originH = this.sourceMinHeight,\n  ) {\n    this.drawImage(ctx, w, h, originW, originH);\n    const imgData = ctx.getImageData(x, y, w, h);\n\n    if (type instanceof Tensor) {\n      type.data.set(imgData.data);\n\n      return type;\n    }\n\n    switch (type) {\n      case 'uint8': {\n        return new Uint8Array(imgData.data);\n      }\n      case 'uint8c': {\n        return imgData.data;\n      }\n      case 'float32': {\n        return new Float32Array(imgData.data);\n      }\n      default: {\n        return imgData;\n      }\n    }\n  }\n\n  getImageBufferTo(\n    type,\n    ctx = this.canvasCtx,\n    width = this.width,\n    height = this.height,\n    x = 0,\n    y = 0,\n    w = width,\n    h = height,\n    to,\n  ) {\n    ctx.drawImage(\n      this.video,\n      (this.sourceWidth - this.width) / -2,\n      (this.sourceHeight - this.height) / -2,\n      this.sourceWidth,\n      this.sourceHeight,\n    );\n    const imgData = ctx.getImageData(x, y, w, h);\n\n    to.data = imgData.data.buffer;\n  }\n\n  getSourceImageBuffer(type, x, y, w, h) {\n    return this.getImageBuffer(\n      type,\n      this.sourceCanvasCtx,\n      this.sourceCanvas.width,\n      this.sourceCanvas.height,\n      x,\n      y,\n      w,\n      h,\n      this.sourceWidth,\n      this.sourceHeight,\n    );\n  }\n}\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nvar kernel = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/const vec3 k=vec3(0.2128,0.7148,0.0724);vec4 operation(float y,float x){float value=dot(pickValue_tSrc(y,x).rgb,k);return vec4(value,value,value,1.0);}\";\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\n/**\n * @name Grayscale\n * @description\n *  Grayscale of the input image by formula of luminosity\n *  R * 0.2126 + G * 0.7152 + B * 0.0722\n * @example\n *  grayscale(inputImage);\n * @param {Tensor} tSrc - The source image to be grayscaled.\n */\n\nvar index = tSrc => new RegisterOperation('Grayscale')\n  .Input('tSrc', 'uint8')\n  .Output('uint8')\n  .LoadChunk('pickValue')\n  .GLSLKernel(kernel)\n  .Compile({ tSrc });\n\nvar kernel$1 = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float y,float x){const int mSize=int(KERNEL_SIZE);const int kSize=(mSize-1)/2;vec3 finalColour=vec3(0.0);for(int i=-kSize;i<=kSize;i+=1){for(int j=-kSize;j<=kSize;j+=1){float k=pickValue_tKernel(float(i+kSize),float(j+kSize)).a;finalColour+=pickValue_tSrc(y+float(i),x+float(j)).rgb*k;}}return vec4(finalColour,1.0);}\";\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\n/**\n * @name GaussianBlur\n * @description\n *  This operation is default blur operation which actually\n *  convolution with Gaussian kernel.\n * @example\n *  gaussianBlur(inputImage, 5, 3);\n * @param {Tensor} tSrc - The source image to be grayscaled.\n * @param {number} kernelSize - Size of the kernel.\n * @param {number} sigma - Sigma coeficient value.\n */\n\nvar index$1 = (tSrc, kernelSize = 3, sigma = 3) => {\n  assert$$1(\n    kernelSize >= 3,\n    'Kernel size should be greater equal 3',\n  );\n\n  assert$$1(\n    sigma > 0,\n    'Sigma should be greater then 0',\n  );\n\n  return new RegisterOperation('GaussianBlur')\n    .Input('tSrc', tSrc.dtype)\n    .Input('tKernel', 'float32')\n    .Output(tSrc.dtype)\n    .LoadChunk('pickValue')\n    .Uniform('uWidth', 'float', tSrc.shape[0])\n    .Uniform('uHeight', 'float', tSrc.shape[1])\n    .Constant('KERNEL_SIZE', kernelSize)\n    .PreCompile((op) => {\n      const dstKernel = new Tensor('float32', [kernelSize, kernelSize]);\n      const mean = kernelSize / 2;\n      const resultKernel = new Tensor('float32', [kernelSize, kernelSize, 4]);\n      let sum = 0.0;\n\n      for (let x = 0; x < kernelSize; x += 1) {\n        for (let y = 0; y < kernelSize; y += 1) {\n          const v = Math.exp(-0.5 * (((x - mean) / sigma) ** 2\n            + ((y - mean) / sigma) ** 2)) / (2 * Math.PI * sigma * sigma);\n\n          dstKernel.set(x, y, v);\n          sum += dstKernel.get(x, y);\n        }\n      }\n\n      // Normalize the kernel\n      for (let x = 0; x < kernelSize; x += 1) {\n        for (let y = 0; y < kernelSize; y += 1) {\n          resultKernel.set(x, y, 3, dstKernel.get(x, y) / sum);\n        }\n      }\n\n      op.assignInput('tKernel', resultKernel);\n    })\n    .GLSLKernel(kernel$1)\n    .Compile({ tSrc });\n};\n\nvar kernel$2 = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float y,float x){float value=0.0;for(float dx=0.0;dx<K;dx+=1.0){for(float dy=0.0;dy<K;dy+=1.0){float v=pickValue_tSrc((y*K)-dy,(x*K)-dx).r;if(S==0.0){if(v>0.0){value=v;}}if(S==1.0){value+=v;}}}if(S==1.0){value/=K*K;}return vec4(value,value,value,1.0);}\";\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\n/**\n * @name Downsample\n * @description\n *  Performance is always important, but some algorithms are very expensive to apply\n *  to large picture sizes. To accommodate for this in Computer Vision we often need\n *  reduce an original image to a smaller size before we apply a given algorithm,\n *  GammaCV support a few different ways to reduce the dimension of a image,\n *  for example we support \"meaning pixels\" and an approach known as \"MaxPooling\".\n * @example\n *  // this line reduces an input image in 3x\n *  downsample(inputImage, 3, 0);\n * @param {Tensor} tSrc - The source image to be downsampled.\n * @param {number} coeficient - Downsampling coeficient.\n * @param {number} type - Downsampling support two possible variants of processing\n *  pixels to be downsampled 'max', 'mean'.\n */\n\nvar index$2 = (tSrc, coeficient = 2, type = 'mean') => {\n  assert$$1(\n    type === 'mean' || type === 'max',\n    'DownsampleOp: Unsupported type of operation. Currently sup',\n  );\n\n  let t = 0;\n\n  if (type === 'max') {\n    t = 0;\n  } else if (type === 'mean') {\n    t = 1;\n  }\n\n  return new RegisterOperation('Downsample')\n    .Input('tSrc', 'uint8')\n    .Output('uint8')\n    .Constant('K', coeficient)\n    .Constant('S', t)\n    .SetShapeFn(() => {\n      const shape = [~~(tSrc.shape[0] / coeficient), ~~(tSrc.shape[1] / coeficient), 4];\n\n      assert$$1(\n        isValidOperationShape$$1(shape),\n        'DownsampleOperation: Invalid operation shape',\n      );\n\n      return shape;\n    })\n    .LoadChunk('pickValue')\n    .GLSLKernel(kernel$2)\n    .Compile({ tSrc });\n};\n\nvar kernel$3 = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float y,float x){float wk=1.0;float hk=1.0;float dx=0.0;float dy=0.0;/*-1 0+1-2 0+2-1 0+1*/dx+=-1.0*pickScalarValue_tSrc(y-hk,x-wk);dx+=-2.0*pickScalarValue_tSrc(y,x-wk);dx+=-1.0*pickScalarValue_tSrc(y+wk,x-wk);dx+=+1.0*pickScalarValue_tSrc(y-wk,x+wk);dx+=+2.0*pickScalarValue_tSrc(y,x+wk);dx+=+1.0*pickScalarValue_tSrc(y+wk,x+wk);/*-1-2-10 0  0+1+2+1*/dy+=-1.0*pickScalarValue_tSrc(y-wk,x-wk);dy+=-2.0*pickScalarValue_tSrc(y-wk,x);dy+=-1.0*pickScalarValue_tSrc(y-wk,x+wk);dy+=+1.0*pickScalarValue_tSrc(y+wk,x-wk);dy+=+2.0*pickScalarValue_tSrc(y+wk,x);dy+=+1.0*pickScalarValue_tSrc(y+wk,x+wk);float magniture=sqrt((dx*dx)+(dy*dy));float theta=atan(dy/dx);return vec4(magniture,dx,dy,theta);}\";\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\n/**\n * @name SobelOperator\n * @description\n *  Calculating image gradient and magnitude by applying of Sobel Operator.\n *  Output description:\n *    0 - GX\n *    1 - GY\n *    2 - Magnitude\n * @example\n *  sobelOperator(inputImage);\n * @param {Tensor} tSrc - Input image.\n */\n\nvar index$3 = tSrc => new RegisterOperation('SobelOperator')\n  .Input('tSrc', tSrc.dtype)\n  .Output('float32')\n  .Uniform('uWidth', 'float', tSrc.shape[0])\n  .Uniform('uHeight', 'float', tSrc.shape[1])\n  .Constant('PI', Math.PI)\n  .GLSLKernel(kernel$3)\n  .LoadChunk('pickValue')\n  .Compile({ tSrc });\n\nvar dirrectionKernel = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float y,float x){float dx=pickValue_tSrc(y,x+1.0).r-pickValue_tSrc(y,x-1.0).r;float dy=pickValue_tSrc(y+1.0,x).r-pickValue_tSrc(y-1.0,x).r;float magniture=sqrt((dx*dx)+(dy*dy));return vec4(magniture,atan(dy/dx),dx,dy);}\";\n\nvar groupKernel = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/float A=180.0/9.0;float S=3.0;vec4 operation(float y,float x){float my=y-(S*floor(y/S));float mx=x-(S*floor(x/S));x=x/S;y=y/S;float index=mx+(my*S);float sum=0.0;for(float dx=0.0;dx<K;dx+=1.0){for(float dy=0.0;dy<K;dy+=1.0){vec4 v=pickValue_tSrc(((y*K)+dy),((x*K)+dx));float theta=abs(PI/2.0-v.g);float deg=theta*(180.0/PI);float i=floor(deg/A);if(i==index){sum+=v.r;}}}float rad=(index/9.0*PI);return vec4(sum,rad,0.0,0.0);}\";\n\nvar groupMaxKernel = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/const int w=int(W);const int h=int(H);const int k=int(K);const float S=3.0;float A=180.0/9.0;vec4 getPixel(float y,float x){float x1=x/float(w);float y1=y/float(h);return pickValue_tSrc(floor(y1*uSrcHeight),floor(x1*uSrcWidth));}vec4 getPixel(float y,float x,float xOffset,float yOffset){float x1=x/float(w);float y1=y/float(h);return pickValue_tSrc(floor(y1*uSrcHeight)+yOffset,floor(x1*uSrcWidth)+xOffset);}vec4 operation(float y,float x){float x1=x/W;float y1=y/H;float res=0.0;float tmpx=x/S;float tmpy=y/S;float sum[9];int count=0;vec4 value=getPixel(y,x);for(int _x=0;_x<k;_x+=1){for(int _y=0;_y<k;_y+=1){vec4 v=getPixel(y,x,float(_y),float(_x));float theta=abs(PI/2.0-v.g);float deg=theta*(180.0/PI);int i=int(floor(deg/A));if(i==1){sum[1]+=v.r;}if(i==2){sum[2]+=v.r;}if(i==3){sum[3]+=v.r;}if(i==4){sum[4]+=v.r;}if(i==5){sum[5]+=v.r;}if(i==6){sum[6]+=v.r;}if(i==7){sum[7]+=v.r;}if(i==8){sum[8]+=v.r;}}}int maxI=0;float maxV=0.0;for(int i=0;i<9;i++){if(maxV<sum[i]){maxI=i;maxV=sum[i];}}return vec4(maxI,maxV,0.0,0.0);}\";\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nconst hogDirrection = tSrc => new RegisterOperation('HOGDirection')\n  .Input('tSrc', 'uint8')\n  .Output('float32')\n  .Uniform('uWidth', 'float', tSrc.shape[1])\n  .Uniform('uHeight', 'float', tSrc.shape[0])\n  .LoadChunk('pickValue')\n  .GLSLKernel(dirrectionKernel)\n  .Compile({ tSrc });\n\nconst hogGroup = (tSrc, k) => new RegisterOperation('HOG')\n  .Input('tSrc', 'uint8')\n  .Output('float32')\n  .Uniform('uSrcWidth', 'float', tSrc.shape[1])\n  .Uniform('uSrcHeight', 'float', tSrc.shape[0])\n  .Uniform('uWidth', 'float', ~~(tSrc.shape[1] / k) * 3)\n  .Uniform('uHeight', 'float', ~~(tSrc.shape[0] / k) * 3)\n  .Constant('PI', Math.PI)\n  .Constant('W', ~~(tSrc.shape[1] / k))\n  .Constant('H', ~~(tSrc.shape[0] / k))\n  .Constant('K', k)\n  .LoadChunk('pickValue')\n  .SetShapeFn(() => [~~(tSrc.shape[0] / k) * 3, ~~(tSrc.shape[1] / k) * 3, 4])\n  .GLSLKernel(groupKernel)\n  .Compile({ tSrc });\n\nconst hogGroupMax = (tSrc, k) => new RegisterOperation('HOGMax')\n  .Input('tSrc', 'uint8')\n  .Output('float32')\n  .Uniform('uSrcWidth', 'float', tSrc.shape[1])\n  .Uniform('uSrcHeight', 'float', tSrc.shape[0])\n  .Uniform('uWidth', 'float', ~~(tSrc.shape[1] / k))\n  .Uniform('uHeight', 'float', ~~(tSrc.shape[0] / k))\n  .Constant('PI', Math.PI)\n  .Constant('W', ~~(tSrc.shape[1] / k))\n  .Constant('H', ~~(tSrc.shape[0] / k))\n  .Constant('K', k)\n  .LoadChunk('pickValue')\n  .SetShapeFn(() => [~~(tSrc.shape[0] / k), ~~(tSrc.shape[1] / k), 4])\n  .GLSLKernel(groupMaxKernel)\n  .Compile({ tSrc });\n\n/**\n * @name HOG\n * @description\n *  This operation allows to extract Histogram of Oriented Gradients features.\n *  Currently availiable two types:\n *    - `visualize`: will return 9 bin histogram for each segment\n *    - `max`: will return angle with maximum intencity in histogram\n * @example\n *   gm.hog(inputImage, 5, 3);\n * @param {Tensor} tSrc - The source image to be grayscaled.\n * @param {number} k - region size.\n * @param {string} type - Type of HOG features extractor, currently availiable max and visualize.\n */\n\nvar index$4 = (tSrc, k = 10, type = 'max') => {\n  assert$$1(\n    type === 'max' || type === 'visualize',\n    `Unsupported type of HOG operation.\n     Currently availiable max and visualize.`,\n  );\n\n  let operation = null;\n\n  if (type === 'max') {\n    operation = hogGroupMax(hogDirrection(tSrc), k);\n  }\n\n  if (type === 'visualize') {\n    operation = hogGroup(hogDirrection(tSrc), k);\n  }\n\n  return operation;\n};\n\nvar kernel$4 = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float y,float x){return pickValue_tSrc(y,x);}\";\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\n/**\n * @name Cast\n * @description\n *  Change the texture data type\n * @example\n *  cast(inputImage, 'float32');\n * @param {Tensor} tSrc - The source to be changed.\n * @param {string} dtype - The destination data type\n */\n\nvar index$5 = (tSrc, dtype = tSrc.dtype) => new RegisterOperation('Cast')\n  .Input('tSrc', tSrc.dtype)\n  .Output(dtype)\n  .LoadChunk('pickValue')\n  .GLSLKernel(kernel$4)\n  .Compile({ tSrc });\n\nvar nmsKernel = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/\\n#define STROKE uSize\\nvec4 operation(float y,float x){vec4 M=pickValue_tSrc(y,x);float N=pickValue_tSrc(y+STROKE,x).r;float S=pickValue_tSrc(y-STROKE,x).r;float W=pickValue_tSrc(y,x-STROKE).r;float E=pickValue_tSrc(y,x+STROKE).r;float SE=pickValue_tSrc(y-STROKE,x+STROKE).r;float NW=pickValue_tSrc(y+STROKE,x-STROKE).r;float NE=pickValue_tSrc(y+STROKE,x+STROKE).r;float SW=pickValue_tSrc(y-STROKE,x-STROKE).r;float H=0.0;float V=M.r;float dx=M.g;float dy=M.b;float theta=atan(dy/dx);float deg=theta*(180.0/PI);float angle=0.0;if(deg<0.0){deg=180.0+deg;}if(deg<22.5||deg>=157.5){if(V>W&&V>E){H+=1.0;}}if(deg<67.5&&deg>=22.5){if(V>SW&&V>NE){H+=1.0;}}if(deg<112.5&&deg>=67.5){if(V>N&&V>S){H+=1.0;}}if(deg<157.5&&deg>=112.5){if(V>NW&&V>SE){H+=1.0;}}if(H==1.0){return vec4(V,V,V,255);}else{return vec4(0,0,0,255);}}\";\n\nvar hysteresisKernel = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/\\n#define STROKE uSize\\nvec4 operation(float y,float x){vec4 M=pickValue_tSrc(y,x);float N=pickValue_tSrc(y+STROKE,x).r;float S=pickValue_tSrc(y-STROKE,x).r;float W=pickValue_tSrc(y,x-STROKE).r;float E=pickValue_tSrc(y,x+STROKE).r;float SE=pickValue_tSrc(y-STROKE,x+STROKE).r;float NW=pickValue_tSrc(y+STROKE,x-STROKE).r;float NE=pickValue_tSrc(y+STROKE,x+STROKE).r;float SW=pickValue_tSrc(y-STROKE,x-STROKE).r;float V=M.r;float H=0.0;if(V>uThresholdHigh){H+=1.0;}if(V>uThresholdLow&&V<uThresholdHigh){if(N>0.0||S>0.0||W>0.0||E>0.0||SE>0.0||NW>0.0||NE>0.0||SW>0.0){H+=1.0;}}if(H==1.0){return vec4(255,255,255,255);}else{return vec4(0,0,0,255);}}\";\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nconst CannyNMS = tSrc => new RegisterOperation('ImageCannyEdgesNMS')\n  .Input('tSrc', tSrc.dtype)\n  .Output(tSrc.dtype)\n  .LoadChunk('pickValue')\n  .Uniform('uSize', 'float', 1)\n  .Constant('PI', Math.PI)\n  .GLSLKernel(nmsKernel)\n  .Compile({ tSrc });\n\nconst CannyHysteresis = (tSrc, low, high) => {\n  assert$$1(\n    low >= 0,\n    'Canny low threshold should be greater equal 0',\n  );\n\n  assert$$1(\n    high <= 1,\n    'Canny high threshold should be less equal 1',\n  );\n\n  return new RegisterOperation('ImageCannyEdgesHysteresis')\n    .Input('tSrc', tSrc.dtype)\n    .Output(tSrc.dtype)\n    .LoadChunk('pickValue')\n    .Uniform('uSize', 'float', 1)\n    .Uniform('uThresholdLow', 'float', low)\n    .Uniform('uThresholdHigh', 'float', high)\n    .GLSLKernel(hysteresisKernel)\n    .Compile({ tSrc });\n};\n\n/**\n * @name CannyEdges\n * @description\n *  The Canny edge detector is an edge detection operator that uses\n *  a multi-stage algorithm to detect a wide range of edges in images.\n *  [Read more on Wiki](https://en.wikipedia.org/wiki/Canny_edge_detector).\n * @example\n *  cannyEdges(inputImage, 0.25, 0.75);\n * @param {Tensor} sobel - Sobel derivatives operation output [sobelOperator](https://en.wikipedia.org/wiki/Canny_edge_detector).\n * @param {number} low - Low threshold to be applied.\n * @param {number} high - High threshold to be applied.\n */\n\nvar index$6 = (input, low = 0.25, high = 0.75) => CannyHysteresis(CannyNMS(input), low, high);\n\nvar kernel$5 = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/const float _step=1.0/CLUSTERS;vec4 operation(float y,float x){float minDistance=256.0;float label=0.0;vec3 value=pickValue_tSrc(y,x).rgb;for(int i=0;i<int(CLUSTERS);i+=1){vec3 curr=pickValue_tCentroids(float(i),0.0).rgb;float distance=sqrt(((value.r-curr.r)*(value.r-curr.r)));if(distance<minDistance){minDistance=distance;label=float(i)/CLUSTERS;}}return vec4(label,label,label,1.0);}\";\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\n/**\n * @name ColorSegmentation\n * @description\n *  Color segmentation of given image with simple Euclidian\n *  distance estimation.\n * @example\n *  // segmentation of input image to 5 clusters\n *  colorSegmentation(inputImage, 5);\n * @param {Tensor} tSrc - Current frame.\n * @param {number} clusters - Number of clusters the input image to be clustered.\n */\n\nvar index$7 = (tSrc, clusters = 3) => {\n  assert$$1(\n    tSrc.dtype === 'uint8',\n    'Color Segmentation currently available for uint8 image input',\n  );\n\n  assert$$1(\n    clusters > 1,\n    'Number of clusters should be greater than 1',\n  );\n\n  return new RegisterOperation('ImageColorSegmentation')\n    .Input('tSrc', 'uint8')\n    .Input('tCentroids', 'uint8')\n    .Output('uint8')\n    .LoadChunk('pickValue')\n    .Constant('CLUSTERS', clusters)\n    .GLSLKernel(kernel$5)\n    .PreCompile((op) => {\n      const k = ~~(256 / clusters);\n\n      op.centroids = new Tensor('uint8', [clusters, 1, 4]);\n\n      for (let i = 0; i < clusters; i += 1) {\n        op.centroids.set(i, 0, 0, i * k);\n      }\n\n      op.assignInput('tCentroids', op.centroids);\n    })\n    .Compile({ tSrc });\n};\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nfunction parallelReductionCheckSteps(size = 1, steps = [1]) {\n  let s = size;\n\n  for (let i = 0; i < steps.length; i += 1) {\n    s /= steps[i];\n  }\n\n  return s === 1;\n}\n\nfunction parallelReductionCheckSteps2d(size = [1, 1], steps = [[1, 1]]) {\n  return parallelReductionCheckSteps(size[0], steps.map(n => n[0]))\n  && parallelReductionCheckSteps(size[0], steps.map(n => n[1]));\n}\n\nfunction parallelReductionGetSteps(\n  size = 1,\n  layersCount = 1,\n  ignoreOne = true,\n  maxLayerSize = size,\n) {\n  const base = size ** (1 / layersCount);\n\n  if (size % 1 !== 0) {\n    throw new RangeError(`Can't get parallel reduction steps for non-integer, got \"${size}\"`);\n  }\n\n  if (maxLayerSize < 1) {\n    throw new RangeError(`Can't get parallel reduction steps for maxLayerSize below less than 1, got \"${maxLayerSize}\"`);\n  }\n\n  if (base % 1 === 0 && base < maxLayerSize) {\n    return new Array(layersCount).fill(base);\n  }\n\n  const result = [];\n  let _size = size;\n  let _base = base;\n\n  for (let i = 0; i < layersCount; i += 1) {\n    _base = _size ** (1 / (layersCount - i));\n    let v = Math.ceil(_base);\n\n    while ((_size % v !== 0 || _size / v > maxLayerSize) && _size / v !== 1) {\n      if (maxLayerSize === 4) {\n        console.log(v, _size / v, maxLayerSize);\n      }\n      v += 1;\n    }\n    if (v === 1 && ignoreOne) {\n      break;\n    }\n    _size /= v;\n\n    if (maxLayerSize === 4) {\n      console.log(v, result);\n    }\n    result.push(v);\n  }\n\n  return result;\n}\n\nfunction parallelReductionGetSteps2d(\n  size = [1, 1],\n  layersCount = 1,\n  ignoreOne = true,\n  maxLayerSize = size,\n) {\n  const s1 = parallelReductionGetSteps(size[0], layersCount, ignoreOne, maxLayerSize[0]);\n  const s2 = parallelReductionGetSteps(size[1], layersCount, ignoreOne, maxLayerSize[1]);\n  const result = [];\n\n  for (let i = 0; i < layersCount && (s1[i] || s2[i]); i += 1) {\n    result.push([s1[i] || 1, s2[i] || 1]);\n  }\n\n  return result;\n}\n\n/**\n * Convolution calc ouput shape.\n * @param {number} inputLength - the source size\n * @param {number} kernelSide\n * @param {number} [stride]\n * @returns {number} - Count of windows.\n */\n\nfunction clacConvolution(inputLength, kernelSide, stride = 1) {\n  return Math.ceil(((inputLength - kernelSide) + 1) / stride);\n}\n\nvar getMean = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/const int kx=int(KX);const int ky=int(KY);const int w=int(WIDTH);const int h=int(HEIGHT);vec4 operation(float gly,float glx){float size=KY*KX;float mean=0.0;float std=0.0;vec3 color=vec3(0.0,0.0,0.0);for(int y=0;y<ky;y+=1){for(int x=0;x<kx;x+=1){vec3 value=pickValue_tSrc(gly*KY+float(y),glx*KX+float(x)).rgb;color+=value.rgb;}}color/=size;mean=color.r;for(int y=0;y<ky;y+=1){for(int x=0;x<kx;x+=1){vec3 value=pickValue_tSrc(gly*KY+float(y),glx*KX+float(x)).rgb;std+=(value.r-mean)*(value.r-mean);}}std/=size;std=sqrt(std);if(std==0.0){std=1.0;}return vec4(color,255.0);}\";\n\nvar getStd = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/const int kx=int(KX);const int ky=int(KY);const int w=int(WIDTH);const int h=int(HEIGHT);vec4 operation(float gly,float glx){float size=KX*KY;vec3 std=vec3(0.0,0.0,0.0);vec3 mean=pickValue_tMean(0.0,0.0).rgb;for(int y=0;y<ky;y+=1){for(int x=0;x<kx;x+=1){vec3 value=pickValue_tSrc(gly*KY+float(y),glx*KX+float(x)).rgb;std+=(value-mean)*(value-mean);}}std/=size;std=sqrt(std);if(std.r==0.0){std.r=255.0;}if(std.g==0.0){std.g=255.0;}if(std.b==0.0){std.b=255.0;}return vec4(std,255.0);}\";\n\nvar reduceStd = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/const int kx=int(KX);const int ky=int(KY);const int w=int(WIDTH);const int h=int(HEIGHT);vec4 operation(float gly,float glx){float size=KX*KY;vec3 std=vec3(0.0,0.0,0.0);for(int y=0;y<ky;y+=1){for(int x=0;x<kx;x+=1){vec3 mstd=pickValue_tStd(gly*KY+float(y),glx*KX+float(x)).rgb;std+=mstd*mstd;}}std/=size;std=sqrt(std);if(std.r==0.0){std.r=255.0;}if(std.g==0.0){std.g=255.0;}if(std.b==0.0){std.b=255.0;}return vec4(std,255.0);}\";\n\nvar joinKernel = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float gly,float glx){if(gly==0.0){return texture2D(tMean,vec2(0,0));}else{return texture2D(tStd,vec2(0,0));}}\";\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nconst ImageReduceStd = (tStd, k) => new RegisterOperation('ImageReduceStd')\n  .Input('tStd', tStd.dtype)\n  .Output(tStd.dtype)\n  .Constant('WIDTH', tStd.shape[1])\n  .Constant('HEIGHT', tStd.shape[0])\n  .Uniform('uWidth', 'float', tStd.shape[1] / k[1])\n  .Uniform('uHeight', 'float', tStd.shape[0] / k[0])\n  .Constant('KX', k[1])\n  .Constant('KY', k[0])\n  .LoadChunk('pickValue')\n  .SetShapeFn(() => [~~(tStd.shape[0] / k[0]), ~~(tStd.shape[1] / k[1]), 4])\n  .GLSLKernel(reduceStd)\n  .Compile({ tStd });\n\nconst ImageExtractStd = (tSrc, tMean, k) => new RegisterOperation('ImageExtractStd')\n  .Input('tSrc', tSrc.dtype)\n  .Input('tMean', tMean.dtype)\n  .Output(tSrc.dtype)\n  .Constant('WIDTH', tSrc.shape[1])\n  .Constant('HEIGHT', tSrc.shape[0])\n  .Uniform('uWidth', 'float', tSrc.shape[1] / k[1])\n  .Uniform('uHeight', 'float', tSrc.shape[0] / k[0])\n  .Constant('KX', k[1])\n  .Constant('KY', k[0])\n  .LoadChunk('pickValue')\n  .SetShapeFn(() => [~~(tSrc.shape[0] / k[0]), ~~(tSrc.shape[1] / k[1]), 4])\n  .GLSLKernel(getStd)\n  .Compile({ tSrc, tMean });\n\nconst ImageExtractMean = (tSrc, k) => new RegisterOperation('ImageExtractMean')\n  .Input('tSrc', tSrc.dtype)\n  .Output(tSrc.dtype)\n  .Constant('WIDTH', tSrc.shape[1])\n  .Constant('HEIGHT', tSrc.shape[0])\n  .Uniform('uWidth', 'float', tSrc.shape[1] / k[1])\n  .Uniform('uHeight', 'float', tSrc.shape[0] / k[0])\n  .Constant('KX', k[1])\n  .Constant('KY', k[0])\n  .LoadChunk('pickValue')\n  .SetShapeFn(() => [~~(tSrc.shape[0] / k[0]), ~~(tSrc.shape[1] / k[1]), 4])\n  .GLSLKernel(getMean)\n  .Compile({ tSrc });\n\nconst JoinOp = (tMean, tStd) => new RegisterOperation('ImageJoin')\n  .Input('tMean', tMean.dtype)\n  .Input('tStd', tStd.dtype)\n  .Output(tMean.dtype)\n  .SetShapeFn(() => [2, 1, 4])\n  .GLSLKernel(joinKernel)\n  .Compile({ tMean, tStd });\n\n/**\n * @name MeanStd\n * @description\n *  Extract mean and std of pixel values of the image\n *  Returns 2 pixels in a column, in which the top is the mean, and the bottom is the std values.\n * @param {Tensor} tSrc - Inptut image\n * @param {number} layers - Number of layers for a parallel reduction\n * @param {boolean} [ignoreStd] - if true, operatino will return only one pixel with mean values\n */\n\nvar meanStdOp = (tSrc, layers = 1, ignoreStd) => {\n  let steps = [[\n    tSrc.shape[0],\n    tSrc.shape[1],\n  ]];\n\n  if (Array.isArray(layers)) {\n    assert$$1(\n      parallelReductionCheckSteps2d(tSrc.shape, layers),\n      'ImageMeanStd: Provided steps doesn\\'t converge in 1 px in ImageExtractMeanStd operation',\n    );\n\n    steps = layers;\n  } else if (typeof layers === 'number' && layers > 0) {\n    steps = parallelReductionGetSteps2d(tSrc.shape, layers);\n  }\n\n  let meanPipe = ImageExtractMean(tSrc, steps[0]);\n\n  for (let i = 1; i < steps.length; i += 1) {\n    meanPipe = ImageExtractMean(meanPipe, steps[i]);\n  }\n\n  if (ignoreStd) {\n    return meanPipe;\n  }\n\n  let stdPipe = ImageExtractStd(tSrc, meanPipe, steps[0]);\n\n  for (let i = 1; i < steps.length; i += 1) {\n    stdPipe = ImageReduceStd(stdPipe, steps[i]);\n  }\n\n  return JoinOp(meanPipe, stdPipe);\n};\n\nvar getHistogramKernel = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/const int kx=int(KX);const int ky=int(KY);precision highp float;vec4 operation(float gly,float iglx){float size=KX*KY;float glx=floor(iglx/COUNT);float currentIndex=iglx-(glx*COUNT);vec4 count=vec4(0.0);vec4 ones=vec4(1.0);vec4 twos=vec4(2.0);vec4 currentIndex4=vec4(currentIndex);vec4 value;for(int y=0;y<ky;y+=1){for(int x=0;x<kx;x+=1){value=pickValue_tSrc(gly*KY+float(y),glx*KX+float(x));vec4 index=floor((value-MIN)/STEP+0.5);count+=step(twos,ones/(abs(index-currentIndex4)));}}return count;}\";\n\nvar reduceKernel = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/const int kx=int(KX);const int ky=int(KY);vec4 operation(float gly,float iglx){float size=KX*KY;float glx=floor(iglx/COUNT);float currentIndex=iglx-(glx*COUNT);vec4 count=vec4(0.0);for(int y=0;y<ky;y+=1){for(int x=0;x<kx;x+=1){count+=pickValue_tSrc(gly*KY+float(y),(glx*KX+float(x))*COUNT+currentIndex);}}return count;}\";\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nconst ImageExtractHistogram = (tSrc, k, min, max, step, count) => new RegisterOperation('ImageExtractHistogram')\n  .Input('tSrc', tSrc.dtype)\n  .Output('float32')\n  .Constant('KX', k[1])\n  .Constant('KY', k[0])\n  .LoadChunk('pickValue')\n  .Constant('MIN', min)\n  .Constant('MAX', max)\n  .Constant('STEP', step)\n  .Constant('COUNT', count)\n  .SetShapeFn(() => [~~(tSrc.shape[0] / k[0]), ~~(tSrc.shape[1] / k[1]) * count, 4])\n  .GLSLKernel(getHistogramKernel)\n  .Compile({ tSrc });\n\nconst ImageReduceHistogram = (tSrc, k, count) => new RegisterOperation('ImageReduceHistogram')\n  .Input('tSrc', 'float32')\n  .Output('float32')\n  .Constant('KX', k[1])\n  .Constant('KY', k[0])\n  .LoadChunk('pickValue')\n  .Constant('COUNT', count)\n  .SetShapeFn(() => [~~(tSrc.shape[0] / k[0]), ~~(tSrc.shape[1] / k[1]), 4])\n  .GLSLKernel(reduceKernel)\n  .Compile({ tSrc });\n\n/**\n * @name Histogram\n * @description\n *  Extract histogram for given image and parameters\n * @param {Tensor} tSrc - Input image\n * @param {number} layers - Number of layers for a parallel reduction\n * @param {number} [min] - Minimal value of image values\n * @param {number} [max] - Maximum values of image values\n * @param {number} [step] - Step between min and max values.\n * @todo Enhance operation to be not sensible to input size and layers count,\n *  now we have danger limit (input width / first layer k) to be less then MAX_TEXUTRE_SIZE.\n */\n\nvar histogramOp = (tSrc, layers = 1, min = 0, max = 1, step = 1 / 255) => {\n  // TODO: Probably we should refactor arguments priority and add assertation for them\n  let steps = [[\n    tSrc.shape[0],\n    tSrc.shape[1],\n  ]];\n\n  const count = ~~((max - min + step) / step);\n\n  if (Array.isArray(layers)) {\n    assert$$1(\n      parallelReductionCheckSteps2d(tSrc.shape, layers),\n      'ImageExtractHistogram: Provided steps doesn\\'t converge in 1 px in operation',\n    );\n\n    steps = layers;\n  } else if (typeof layers === 'number' && layers > 0) {\n    steps = parallelReductionGetSteps2d(\n      tSrc.shape,\n      layers,\n      true,\n      [ENV.MAX_TEXTURE_SIZE, ENV.MAX_TEXTURE_SIZE / 256 / (ENV.SUPPORTS_FLOAT_TEXTURES ? 1 : 4)],\n    );\n  }\n\n  let histogramPipe = ImageExtractHistogram(tSrc, steps[0], min, max, step, count);\n\n  for (let i = 1; i < steps.length; i += 1) {\n    histogramPipe = ImageReduceHistogram(histogramPipe, steps[i], count);\n  }\n\n  return histogramPipe;\n};\n\nvar getMinMax = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/const int kx=int(KX);const int ky=int(KY);const float INF=1.0/0.0;const float h2=OUT_VIEW.y/2.0;vec4 operation(float igly,float glx){float size=KX*KY;vec3 minV=vec3(INF);vec3 maxV=vec3(-INF);float gly=igly;if(gly>=h2){gly-=h2;}for(int y=0;y<ky*2;y+=1){for(int x=0;x<kx;x+=1){vec3 value=pickValue_tSrc(gly*KY+float(y),glx*KX+float(x)).rgb;minV=min(minV,value.rgb);maxV=max(maxV,value.rgb);}}if(igly<h2){return vec4(minV,255.0);}else{return vec4(maxV,255.0);}}\";\n\nvar reduceMinMax = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/const int kx=int(KX);const int ky=int(KY);const float INF=1.0/0.0;const float h2=OUT_VIEW.y/2.0;vec4 operation(float gly,float glx){float size=KX*KY;vec3 minV=vec3(INF);vec3 maxV=vec3(-INF);vec3 value;for(int y=0;y<ky;y+=1){for(int x=0;x<kx;x+=1){value=pickValue_tSrc(gly*KY+float(y),glx*KX+float(x)).rgb;minV=min(minV,value);maxV=max(maxV,value);}}if(gly<h2){return vec4(minV,255.0);}return vec4(maxV,255.0);}\";\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nconst ImageExtractMinMax = (tSrc, k) => new RegisterOperation('ImageExtractMinMax')\n  .Input('tSrc', tSrc.dtype)\n  .Output(tSrc.dtype)\n  .Constant('KX', k[1])\n  .Constant('KY', k[0])\n  .LoadChunk('pickValue')\n  .SetShapeFn(() => [~~(tSrc.shape[0] / k[0]) * 2, ~~(tSrc.shape[1] / k[1]), 4])\n  .GLSLKernel(getMinMax)\n  .Compile({ tSrc });\n\nconst ImageReduceMinMax = (tSrc, k) => new RegisterOperation('ImageReduceMinMax')\n  .Input('tSrc', tSrc.dtype)\n  .Output(tSrc.dtype)\n  .Constant('KX', k[1])\n  .Constant('KY', k[0])\n  .LoadChunk('pickValue')\n  .SetShapeFn(() => [~~(tSrc.shape[0] / k[0]), ~~(tSrc.shape[1] / k[1]), 4])\n  .GLSLKernel(reduceMinMax)\n  .Compile({ tSrc });\n\n/**\n * @name MinMax\n * @description\n *  Extract min and max for given image\n * @param {Tensor} tSrc - Input image\n * @param {number} layers - Number of layers for a parallel reduction\n */\n\nvar minMaxOp = (tSrc, layers = 1) => {\n  let steps = [[\n    tSrc.shape[0],\n    tSrc.shape[1],\n  ]];\n\n  if (Array.isArray(layers)) {\n    assert$$1(\n      parallelReductionCheckSteps2d(tSrc.shape, layers),\n      'ImageMeanStd: Provided steps doesn\\'t converge in 1 px in ImageExtractMeanStd operation',\n    );\n\n    steps = layers;\n  } else if (typeof layers === 'number' && layers > 0) {\n    steps = parallelReductionGetSteps2d(tSrc.shape, layers);\n  }\n\n  let minMaxPipe = ImageExtractMinMax(tSrc, steps[0]);\n\n  for (let i = 1; i < steps.length; i += 1) {\n    minMaxPipe = ImageReduceMinMax(minMaxPipe, steps[i]);\n  }\n\n  return minMaxPipe;\n};\n\nvar kernel$6 = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float y,float x){vec4 prev=pickValue_tPrev(y,x);vec4 curr=pickValue_tCurr(y,x);float v=sqrt((curr.x-prev.x)*(curr.x-prev.x)+(curr.y-prev.y)*(curr.y-prev.y)+(curr.w-prev.w)*(curr.w-prev.w));return vec4(v,v,v,1.0);}\";\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\n/**\n * @name MotionDetect\n * @description\n *  Promitive motion detector based on subsctruction\n *  of frames.\n * @example\n *  motionDetect(currentImage, previousImage);\n * @param {Tensor} tCurr - Current frame.\n * @param {Tensor} tPrev - Previous frame.\n */\n\nvar index$8 = (tCurr, tPrev) => {\n  assert$$1(\n    assertShapesAreEqual$$1(tCurr, tPrev),\n    'MotionDetect: Current and previous input should have the same shape.',\n  );\n\n  return new RegisterOperation('MotionDetect')\n    .Input('tCurr', tCurr.dtype)\n    .Input('tPrev', tPrev.dtype)\n    .Output(tCurr.dtype)\n    .LoadChunk('pickValue')\n    .GLSLKernel(kernel$6)\n    .Compile({ tCurr, tPrev });\n};\n\nvar kernel$7 = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float y,float x){vec4 col=pickValue_tSrc(y,x)*255.0;float res=0.0;if((col.r>uRThreshold)&&(col.g>uGThreshold)&&(col.b>uBThreshold)&&(col.r>col.g)&&(col.r>col.b)&&(col.r-min(col.g,col.b)>uRtoMinDiffThreshold)&&(abs(col.r-col.g)>uRtoGDiffThreshold)){res=1.0;}return vec4(res,0.0,0.0,1.0);}\";\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\n/**\n * @name SkinTest\n * @description\n *  To enhance face/human detection we need an ability to test image for color that match skin\n *  color. This operation returns exact the same size image with fully red pisels\n *  rgba(255, 0, 0, 1) for pixels that match skin color and black rgba(0, 0, 0, 1) otherwise.\n * @example\n *  skinTestOp(inputImage);\n * @param {Tensor} tSrc - input image\n * @param {Object} [ths] - thresholds\n *\n * TODO: Please describe a mask formula in descriprion (@worldthirteen)\n */\n\nvar index$9 = (tSrc, ths = {}) => new RegisterOperation('SkinTest')\n  .Input('tSrc', tSrc.dtype)\n  .Output(tSrc.dtype)\n  .Uniform('uRThreshold', 'float', ths.uRThreshold || 95.0)\n  .Uniform('uGThreshold', 'float', ths.uGThreshold || 40.0)\n  .Uniform('uBThreshold', 'float', ths.uBThreshold || 20.0)\n  .Uniform('uRtoMinDiffThreshold', 'float', ths.uRtoMinDiffThreshold || 15.0)\n  .Uniform('uRtoGDiffThreshold', 'float', ths.uRtoGDiffThreshold || 15.0)\n  .LoadChunk('pickValue')\n  .GLSLKernel(kernel$7)\n  .Compile({ tSrc });\n\nvar kernel$8 = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float gly,float glx){float x;float y;if(SWAP_COORDS){x=gly;y=glx;}else{x=glx;y=gly;}float _sy=floor(x/SX);float _sx=x-(_sy*SX);float _y=floor(y/WIN_SIZE_X);float _x=y-(_y*WIN_SIZE_X);return pickValue_tSrc(_sy*STRIDE_Y+_y,_sx*STRIDE_X+_x);}\";\n\nvar kernelFlat = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/\\n#define WIN_LENGTH WIN_SIZE_X * WIN_SIZE_Y\\nvec4 operation(float gly,float glx){float i;if(SWAP_COORDS){i=gly;}else{i=glx;}float x=floor(i/WIN_LENGTH);float y=i-x*WIN_LENGTH;float _sy=floor(x/SX);float _sx=x-(_sy*SX);float _y=floor(y/WIN_SIZE_X);float _x=y-(_y*WIN_SIZE_X);return pickValue_tSrc(_sy*STRIDE_Y+_y,_sx*STRIDE_X+_x);}\";\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nfunction getParam(param, name) {\n  if (typeof param === 'number' && param > 0 && isFinite(param)) {\n    return [param, param];\n  }\n\n  if (Array.isArray(param) && param.length === 2) {\n    return param;\n  }\n\n  throw new Error(`Invalid parameter \"${name}\", expected a positive finite number or array with 2 those numbers, but got ${String(param)}`);\n}\n\n/**\n * @name SlidingWindow\n * @description\n *  We want to keep our algorythms clear, so to prepare a data for another\n *  algorythm we need a kind of getting data in different view. SlidingWindow is a helper\n *  in searching objects in an image, putting each window snaphot as a column,\n *  this makes easier to apply another algorythms that should wokrs with that data.\n * @example\n *  // this operation will output data in next stragtegy:\n *  // |xyzw|    |xyzqwe|\n *  // |qwer| -> |yzwwer|\n *  // |asdf|    |qweasd|\n *  //           |wersdf|\n *  // where each column is a one state of sliding window,\n *  // and each pixel in a row is a one pixel in a sliding window.\n *  slidingWindowOp(inputImage, 2, 1, 0);\n * @param {Tensor} tSrc - The source data to be processed.\n * @param {number|Array.<number>} windowSize\n * @param {number|Array.<number>} [stride] - window stride.\n * @param {number} [strategy] - output shape strategy.\n *  ENUM:\n *    0(default): [WH * WW, N, 4];\n *    1: [N, WH * WW, 4];\n *    2: [1, WH * WW * N, 4];\n *    2: [WH * WW * N, 1, 4];\n *  LEGEND:\n *    WH - window height,\n *    WW - window width,\n *    N - number of possible windows.\n *\n * TODO: Reviw description (@worldthirteen, @apilguk)\n * TODO: Review strategy API\n */\n\nconst slidingWindowOp = (tSrc, windowSize, stride = 1, stragtegy = 0) => {\n  const win = getParam(windowSize, 'windowSize');\n  const str = getParam(stride, 'stride');\n  const SX = clacConvolution(tSrc.shape[1], win[0], str[0]);\n  const SY = clacConvolution(tSrc.shape[0], win[1], str[1]);\n\n  let outputShape;\n  let kernelCode;\n  let SWAP_COORDS;\n\n  switch (stragtegy) {\n    case 1:\n      outputShape = [SX * SY, win[0] * win[1], 4];\n      SWAP_COORDS = true;\n      kernelCode = kernel$8;\n      break;\n    case 2:\n      outputShape = [1, SX * SY * win[0] * win[1], 4];\n      SWAP_COORDS = false;\n      kernelCode = kernelFlat;\n      break;\n    case 3:\n      outputShape = [SX * SY * win[0] * win[1], 1, 4];\n      SWAP_COORDS = true;\n      kernelCode = kernelFlat;\n      break;\n    case 0:\n    default:\n      outputShape = [win[0] * win[1], SX * SY, 4];\n      SWAP_COORDS = false;\n      kernelCode = kernel$8;\n  }\n\n  return new RegisterOperation('SlidingWindow')\n    .Input('tSrc', 'float32')\n    .Output('float32')\n    .Constant('WIDTH', tSrc.shape[1])\n    .Constant('HEIGHT', tSrc.shape[0])\n    .Constant('SX', SX)\n    .Constant('SY', SY)\n    .Constant('STRIDE_Y', str[1])\n    .Constant('STRIDE_X', str[0])\n    .Constant('WIN_SIZE_X', win[0])\n    .Constant('WIN_SIZE_Y', win[1])\n    .Constant('SWAP_COORDS', SWAP_COORDS)\n    .LoadChunk('pickValue')\n    .SetShapeFn(() => outputShape)\n    .GLSLKernel(kernelCode)\n    .Compile({ tSrc });\n};\n\nvar kernel$9 = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 findForAngle(float theta,bool invert,float gly,float glx){const float thetaTreshold=PI/6.0;float PER_STEP=(uStrokeMax-uStrokeMin)/STEPS;if(invert){theta+=PI;}float sn=sin(theta);float cs=cos(theta);float tx=cs*PER_STEP;float ty=sn*PER_STEP;float minX=cs*uStrokeMin;float minY=sn*uStrokeMin;float strokeWidth=0.0;int intersect=0;int cx=0;int cy=0;for(int i=int(STEPS);i>0;i-=1){int nx=int(glx+minX+tx*float(i));int ny=int(gly+minY+ty*float(i));float dist=sqrt(float((nx-int(glx))*(nx-int(glx)))+float((ny-int(gly))*(ny-int(gly))));float cannyValue=pickValue_tCanny(float(ny),float(nx)).r;vec4 sobelValue=pickValue_tSobel(float(ny),float(nx));float theta2=atan(sobelValue.b,sobelValue.g);if(invert){theta2+=PI;}if(cannyValue>0.0&&dist>uStrokeMin&&dist<uStrokeMax&&abs(abs(theta-theta2)-PI)<thetaTreshold){strokeWidth=dist;cx=nx;cy=ny;}}return vec4(strokeWidth,cx,cy,theta);}vec4 operation(float _y,float _x){vec4 sobel=pickValue_tSobel(_y,_x);vec4 canny=pickValue_tCanny(_y,_x);float dx=sobel.g;float dy=sobel.b;float _theta=atan(dy,dx);vec4 result=findForAngle(_theta,INVERT>0.0,_y,_x);float strokeWidth=result.r;int cx=int(result.g);int cy=int(result.b);float theta=result.a;float a=float(cx)-_x;float b=float(cy)-_y;if(C>0.0){if(canny.r>0.0&&cx>0&&cy>0){return vec4(strokeWidth,theta,int(cx),int(cy));}else{return vec4(0,0,0,0);}}if(canny.r>0.0&&cx>0&&cy>0){return vec4(strokeWidth,theta,0,1.0);}else{return vec4(0,0,0,0);}}\";\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\n/**\n * @name StrokeWidthTransform\n * @description\n *  Find text on image, using stroke width transform.\n *  [Paper](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/1509.pdf).\n * @example\n *  // this line reduces an input image in 3x\n *  downsampleOp(inputImage, 3, 0);\n * @param {Tensor} tSobel - The output from @ImageSobelOperator\n * @param {Tensor} tCanny - The output from @ImageCannyEdgesHysteresis\n * @param {number} [min] - Minimum stroke width\n * @param {number} [max] - Maximum stroke width\n * @param {number} [steps] - How much pixels count between min and max to determine\n * @param {boolean} [retrunCoords] - Pass coordinates as output\n * @param {boolean} [invert] - Find black text on white backgound when true,\n *  and white on black when false.\n */\n\nvar index$a = (\n  tSobel,\n  tCanny,\n  min = 3,\n  max = 10,\n  steps = 10,\n  returnCoords = false,\n  invert = true,\n) => new RegisterOperation('ImageStrokeWidthTransform')\n  .Input('tSobel', 'float32')\n  .Input('tCanny', 'uint8')\n  .Output('float32')\n  .LoadChunk('pickValue')\n  .Uniform('uStrokeMin', 'float', min)\n  .Uniform('uStrokeMax', 'float', max)\n  .Uniform('uWidth', 'float', tSobel.shape[0])\n  .Uniform('uHeight', 'float', tSobel.shape[1])\n  .Constant('STEPS', steps)\n  .Constant('C', returnCoords ? 1 : 0)\n  .Constant('INVERT', invert ? 1 : 0)\n  .Constant('PI', Math.PI)\n  .GLSLKernel(kernel$9)\n  .Compile({ tCanny, tSobel });\n\nvar kernel$a = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float y,float x){vec4 chanels1=pickValue_tA(y,x);vec4 chanels2=pickValue_tB(y,x);return RESULT;}\";\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\n/**\n * @name Concat\n * @description\n *  Concat two inputs in one image\n * @example\n *  Concat(inputImage1, inputImage2, ['1.r', '1.g', '2.b', '2.a']);\n * @param {Tensor} tA - The first input\n * @param {Tensor} tB - The second input\n * @param {Array.<string>} [mask] - Array that should describe the needed output.\n *  This should be an array of strings in format \"{number of input}.{vector component}\",\n *  see example for more.\n *\n *  ⚠️ STILL UNDER DEVELOPMENT (EXPERIMENTAL, API COULD BE CHANGED OR DEPRECATED)\n */\n\nvar index$b = (tA, tB, mask = ['1.r', '1.g', '2.b', '2.a']) => {\n  assert$$1(\n    tA.dtype === tB.dtype,\n    `Concat operation: inputs should have the same dtype, got ${tA.dtype} and ${tB.dtype}`,\n  );\n\n  assert$$1(\n    mask.length === 4,\n    'Concat operation: wrong input',\n  );\n\n  for (let i = 0; i < mask.length; i += 1) {\n    assert$$1(\n      typeof mask[i] === 'string' || !/^\\d\\.(r|g|b|a|x|y|z|w)$/.test(mask[i]),\n      'Concat operation: wrong input',\n    );\n  }\n\n  return new RegisterOperation('Concat')\n    .Input('tA', tA)\n    .Input('tB', tB)\n    .Output(tA.dtype)\n    .LoadChunk('pickValue')\n    .GLSLKernel(kernel$a.replace('RESULT', `vec4(${mask.map(s => `chanels${s}`).join(', ')})`))\n    .Compile({ tA, tB });\n};\n\nvar l2Kernel = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float y,float x){vec3 chanels=pickValue_tSrc(y,x).rgb;vec3 mean=pickValue_tStdMean(0.0,0.0).rgb;vec3 std=pickValue_tStdMean(1.0,0.0).rgb;vec3 value=(chanels-mean)/std;return vec4(value,1.0);}\";\n\nvar minMaxKernel = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float y,float x){vec3 chanels=pickValue_tSrc(y,x).rgb;vec3 minV=pickValue_tMinMax(0.0,0.0).rgb;vec3 maxV=pickValue_tMinMax(1.0,0.0).rgb;vec3 value=(chanels-minV)/(maxV-minV);return vec4(value,1.0);}\";\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nconst l2Norm = (tSrc, tStdMean) => new RegisterOperation('l2Norm')\n  .Input('tSrc', 'uint8')\n  .Input('tStdMean', 'uint8')\n  .Output('uint8')\n  .LoadChunk('pickValue')\n  .GLSLKernel(l2Kernel)\n  .Compile({ tSrc, tStdMean });\n\nconst minMaxNorm = (tSrc, tMinMax) => new RegisterOperation('minMaxNorm')\n  .Input('tSrc', 'uint8')\n  .Input('tMinMax', 'uint8')\n  .Output('uint8')\n  .LoadChunk('pickValue')\n  .GLSLKernel(minMaxKernel)\n  .Compile({ tSrc, tMinMax });\n\n  /**\n * @name Normalization\n * @description Normalize given data by picked normalization type\n * @param {Tensor} tSrc - Input data\n * @param {string} type - normalization type, currently supported ['l2', 'minmax']\n * @param {number} parallelReductionLayers -\n *  Number of layers for a parallel reduction\n */\nvar norm = (tSrc, type, parallelReductionLayers = 2) => {\n  assert$$1(\n    type === 'l2' || type === 'minmax',\n    `Unsupported type of normalization operation.\n     Currently availiable max and visualize.`,\n  );\n\n  let operation = null;\n\n  if (type === 'l2') {\n    operation = l2Norm(tSrc, meanStdOp(tSrc, parallelReductionLayers));\n  }\n\n  if (type === 'minmax') {\n    operation = minMaxNorm(tSrc, minMaxOp(tSrc, parallelReductionLayers));\n  }\n\n  return operation;\n};\n\nvar histKernel = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/const float norm=1.0/(OUT_VIEW.x*OUT_VIEW.y);vec4 operation(float y,float x){vec4 histBase=pickValue_tSrc(y,x)*255.0;float r=pickValue_tHist(0.0,histBase.r).r;float g=pickValue_tHist(0.0,histBase.g).g;float b=pickValue_tHist(0.0,histBase.b).b;float a=pickValue_tHist(0.0,histBase.a).a;return vec4(r,g,b,255.0/norm)*norm;}\";\n\nvar histCumulateKernel = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float y,float x){vec4 sum=vec4(0.0);for(float i=0.0;i<255.0;i+=1.0){vec4 value=pickValue_tSrc(0.0,i);if(i<=x){sum+=value;}else{break;}}return sum;}\";\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nconst cumulateHistEq = tSrc => new RegisterOperation('histogramCumulation')\n  .Input('tSrc', 'float32')\n  .Output('float32')\n  .LoadChunk('pickValue')\n  .GLSLKernel(histCumulateKernel)\n  .Compile({ tSrc });\n\nconst histEq = (tSrc, tHist) => new RegisterOperation('histogramEqualization')\n  .Input('tSrc', 'uint8')\n  .Input('tHist', 'float32')\n  .Output('uint8')\n  .LoadChunk('pickValue')\n  .GLSLKernel(histKernel)\n  .Compile({ tSrc, tHist });\n\n\n/**\n * @name Histogram Equalization\n * @description\n *  Equalize histogram for given image\n * @param {Tensor} tSrc - Input image\n * @param {number} parallelReductionLayers -\n *  Number of layers for a parallel reduction of histogram extraction\n */\n\nvar index$c = (tSrc, parallelReductionLayers = 2) =>\n  histEq(tSrc, cumulateHistEq(histogramOp(tSrc, parallelReductionLayers)));\n\nvar kernel$b = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 getPoint(vec2 p){return pickValue_tSrc(p.y,p.x);}mat3 getTransformMatrix(){vec3 r1=pickValue_tTransform(0.0,0.0).rgb;vec3 r2=pickValue_tTransform(1.0,0.0).rgb;vec3 r3=pickValue_tTransform(3.0,0.0).rgb;return mat3(r1,r2,r3);}vec4 operation(float y,float x){mat3 m=getTransformMatrix();float off=0.0;float ixs=0.0;float iys=0.0;float xs=0.0;float ys=0.0;float xs0=0.0;float ys0=0.0;float ws=0.0;float sc=0.0;float a=0.0;float b=0.0;xs0=m[0][1]*y+m[0][2];ys0=m[1][1]*y+m[1][2];ws=m[2][1]*y+m[2][2];xs0+=m[0][0]*x;ys0+=m[1][0]*x;ws+=m[2][0]*x;sc=1.0/ws;xs=xs0*sc;ys=ys0*sc;ixs=xs;iys=ys;a=max(xs-ixs,0.0);b=max(ys-iys,0.0);vec2 mvec=vec2(ixs,iys);vec2 ox=vec2(1.0,0.0);vec2 oy=vec2(1.0,1.0);vec4 p0=getPoint(mvec)+a*(getPoint(mvec+ox)-getPoint(mvec));vec4 p1=getPoint(mvec+oy)+a*(getPoint(mvec+ox+oy)-getPoint(mvec+oy));vec4 pres=p0+b*(p1-p0);return pres;}\";\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nvar index$d = (tSrc, tTransform, shape = [10, 10, 4], dtype = tSrc.dtype) => new RegisterOperation('PerspectiveProjection')\n  .Input('tSrc', tSrc.dtype)\n  .Input('tTransform', 'float32')\n  .Output(dtype)\n  .LoadChunk('pickValue')\n  .Uniform('uSrcWidth', 'float', tSrc.shape[1])\n  .Uniform('uSrcHeight', 'float', tSrc.shape[0])\n  .Uniform('uWidth', 'float', shape[1])\n  .Uniform('uHeight', 'float', shape[0])\n  .SetShapeFn(() => shape)\n  .GLSLKernel(kernel$b)\n  .Compile({ tSrc, tTransform });\n\nvar transformKernel = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/precision highp float;float intersectionX(vec4 line,float x){return((x-line.x)/(line.z-line.x)*(line.w-line.y)+line.y);}float intersectionY(vec4 line,float y){return((y-line.y)/(line.w-line.y)*(line.z-line.x)+line.x);}vec4 findSide(float x1,float y1,float x2,float y2){int i=0;vec2 i0=vec2(0,0);vec2 i1=vec2(0,0);float ax=0.0;float ay=intersectionY(vec4(x1,y1,x2,y2),ax);float by=0.0;float bx=intersectionX(vec4(x1,y1,x2,y2),by);float cx=MAX_DIST;float cy=intersectionY(vec4(x1,y1,x2,y2),cx);float dy=MAX_DIST;float dx=intersectionX(vec4(x1,y1,x2,y2),dy);if(ay<=MAX_DIST&&ay>=0.0){if(i==0){i0=vec2(ax,ay);i+=1;}}if(cy<=MAX_DIST&&cy>=0.0){if(i==0){i0=vec2(cx,cy);i+=1;}else{i1=vec2(cx,cy);}}if(bx<=MAX_DIST&&bx>=0.0){if(i==0){i0=vec2(bx,by);i+=1;}else{i1=vec2(bx,by);}}if(dx<=MAX_DIST&&dx>=0.0){if(i==0){i0=vec2(dx,dy);i+=1;}else{i1=vec2(dx,dy);}}return vec4(i0.x,i0.y,i1.x,i1.y);}float pow(float a){return a*a;}vec4 getStraight(float aIndex,float v,float dist,float angles){float y1;float y2;if(aIndex>angles){aIndex-=angles;y1=MAX_ANGLE-(angles*v/aIndex);y2=(-1.0+angles/aIndex)*uWidth+y1;}else{aIndex=angles-aIndex;y1=(angles*v/aIndex);y2=(1.0-angles/aIndex)*uWidth+y1;}return vec4(0.0,y1,uWidth,y2);}float getValue(float i,float lx,float ly,vec4 side){float xx=0.0;float yy=0.0;if(lx<ly){xx=i;yy=intersectionY(side,xx);}else{yy=i;xx=intersectionX(side,yy);}if(xx>0.0&&xx<uWidth&&yy>0.0&&yy<uHeight){float a=pickScalarValue_tSrc(yy,xx);if(a>0.0){return 1.0;}}return 0.0;}vec4 operation(float y,float x){float v_out=0.0;vec4 straight=getStraight(x,y,MAX_DIST,MAX_ANGLE/2.0);vec4 side=findSide(straight.x,straight.y,straight.z,straight.w);float lx=abs(side.z-side.x);float ly=abs(side.w-side.y);float k=1.0/D;for(float i=0.0;i<=D;i+=STEP){float a=getValue(i,lx,ly,side);if(a>0.0){v_out+=k;}}return vec4(v_out,v_out,v_out,255.0);}\";\n\nvar enhanceKernel = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/\\n#define X_STEPS 10.0\\n#define Y_STEPS 10.0\\nvec4 operation(float y,float x){float value=pickValue_tSrc(y,x).r;float c=value*value;float sum=0.0;for(float j=0.0;j<Y_STEPS;j+=1.0){for(float i=0.0;i<X_STEPS;i+=1.0){sum+=pickValue_tSrc((y-Y_STEPS/2.0)+j,(x-X_STEPS/2.0)+i).r;}}float v=(c/sum)*X_STEPS*Y_STEPS;return vec4(v,v,v,1);}\";\n\nvar peaksKernel = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/const int w=int(W);const int h=int(H);vec4 operation(float _y,float _x){float sum=0.0;float mmax=0.0;float maxX=0.0;float maxY=0.0;float sy=_y*H;float sx=_x*W;for(int x=0;x<w;x+=1){for(int y=0;y<h;y+=1){vec4 value;if(uWidth==uSrcWidth){value=pickValue_tSrc(_y,_x);}else{value=pickValue_tSrc(float(y)+sy,float(x)+sx);}if(value.r>mmax){mmax=value.r;if(uF==0.0){maxX=float(x)+sx;maxY=float(y)+sy;}else{maxX=value.g;maxY=value.b;}}}}return vec4(mmax,maxX,maxY,255.0);}\";\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\n\nconst TopKCandidates = (tSrc, k = 10, f = 0) => new RegisterOperation('ExtractPeaks')\n  .Input('tSrc', 'uint8')\n  .Output('float32')\n  .Uniform('uSrcWidth', 'float', tSrc.shape[1])\n  .Uniform('uWidth', 'float', tSrc.shape[1] / k)\n  .Uniform('uHeight', 'float', tSrc.shape[0] / k)\n  .Uniform('uF', 'float', f)\n  .LoadChunk('pickValue')\n  .Constant('SIZE', ~~(tSrc.shape[0] / k) * ~~(tSrc.shape[1] / k))\n  .Constant('W', k)\n  .Constant('H', k)\n  .Constant('K', 1 / k)\n  .SetShapeFn(() => [~~(tSrc.shape[0] / k), ~~(tSrc.shape[1] / k), 4])\n  .GLSLKernel(peaksKernel)\n  .Compile({ tSrc });\n\nconst PCLinesTransform = (tSrc, length = 0.1, step = 3) => {\n  const size = Math.max(tSrc.shape[0], tSrc.shape[1]);\n\n  return new RegisterOperation('PCLinesTransform')\n    .Input('tSrc', 'float32')\n    .Output('uint8')\n    .Uniform('uWidth', 'float', tSrc.shape[1])\n    .Uniform('uHeight', 'float', tSrc.shape[0])\n    .Uniform('uLineLength', 'float', length)\n    .Constant('PI', Math.PI)\n    .Constant('D', size)\n    .Constant('STEP', step)\n    .Constant('MAX_DIST', size)\n    .Constant('MAX_ANGLE', size)\n    .LoadChunk('pickValue')\n    .SetShapeFn(() => [size, size, 4])\n    .GLSLKernel(transformKernel)\n    .Compile({ tSrc });\n};\n\nconst EnhancePCLines = tSrc => new RegisterOperation('PCLinesTransformEnhanced')\n  .Input('tSrc', 'uint8')\n  .Output('uint8')\n  .Uniform('uWidth', 'float', tSrc.shape[0])\n  .Uniform('uHeight', 'float', tSrc.shape[0])\n  .LoadChunk('pickValue')\n  .GLSLKernel(enhanceKernel)\n  .Compile({ tSrc });\n\n\nvar index$e = (input) => {\n  let pipeline = input;\n\n  pipeline = PCLinesTransform(pipeline, 0.0, 1);\n  pipeline = EnhancePCLines(pipeline);\n  pipeline = norm(pipeline, 'minmax');\n  pipeline = TopKCandidates(pipeline, 2);\n  pipeline = TopKCandidates(pipeline, 2, 1);\n\n  return pipeline;\n};\n\nvar RGBToHSVKernel = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec3 rgb2hsv(vec3 c){vec4 K=vec4(0.0,-1.0/3.0,2.0/3.0,-1.0);vec4 p=mix(vec4(c.bg,K.wz),vec4(c.gb,K.xy),step(c.b,c.g));vec4 q=mix(vec4(p.xyw,c.r),vec4(c.r,p.yzx),step(p.x,c.r));float d=q.x-min(q.w,q.y);float e=1.0e-10;return vec3(abs(q.z+(q.w-q.y)/(6.0*d+e)),d/(q.x+e),q.x);}vec4 operation(float y,float x){return vec4(rgb2hsv(pickValue_tSrc(y,x).rgb),1);}\";\n\nvar HSVToRGBKernel = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec3 hsv2rgb(vec3 c){vec4 K=vec4(1.0,2.0/3.0,1.0/3.0,3.0);vec3 p=abs(fract(c.xxx+K.xyz)*6.0-K.www);return c.z*mix(K.xxx,clamp(p-K.xxx,0.0,1.0),c.y);}vec4 operation(float y,float x){return vec4(hsv2rgb(pickValue_tSrc(y,x).rgb),1);}\";\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\n/**\n * @name HSVColorConverter\n * @description\n *  Convert RGB color to HSV spave and vice versa,\n *  [original code](http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl).\n * @example\n *  // this line convert RGB space to HSV\n *  gm.HSVColor(inputImage, 'rgb_to_hsv');\n * @param {Tensor} tSrc - The input image\n * @param {Tensor} type - Operation supports two types of conversion: `rgb_to_hsv`, `hsv_to_rgb`.\n */\n\nvar index$f = (tSrc, type = 'rgb_to_hsv') => {\n  assert$$1(\n    type === 'rgb_to_hsv' || type === 'hsv_to_rgb',\n    `Unsupported type ${type}, currenlty avaliable: rgb_to_hsv, hsv_to_rgb.`,\n  );\n\n  let kernel = null;\n\n  if (type === 'rgb_to_hsv') {\n    kernel = RGBToHSVKernel;\n  }\n\n  if (type === 'hsv_to_rgb') {\n    kernel = HSVToRGBKernel;\n  }\n\n  return new RegisterOperation('HSV')\n    .Input('tSrc', tSrc.dtype)\n    .Output(tSrc.dtype)\n    .LoadChunk('pickValue')\n    .GLSLKernel(kernel)\n    .Compile({ tSrc });\n};\n\nvar kernel$c = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float y,float x){vec4 pixel=pickValue_tSrc(y,x);if(pixel[int(C)]>uT){return vec4(1.0,1.0,1.0,1.0);}else{return vec4(0.0,0.0,0.0,1.0);}}\";\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\n/**\n * @name Threshold\n * @description\n *  Applyes a threshold to the input image,\n *  threshold will be applied to the given channel.\n * @example\n *  gm.threshold(inputImage, 0.5);\n * @param {Tensor} tSrc - The source to be thresholded.\n * @param {number} threshold - Value to be applied\n * @param {number} channel - Channel to be applied\n */\n\nvar index$g = (tSrc, threshold = 0.5, channel = 0) => {\n  assert$$1(\n    typeof threshold === 'number',\n    'Only number available as a threshold value.',\n  );\n\n  assert$$1(\n    channel === 0 || channel === 1 || channel === 2 || channel === 3,\n    'Only RGBA available: 0, 1, 2, 3',\n  );\n\n  return new RegisterOperation('Threshold')\n    .Input('tSrc', tSrc.dtype)\n    .Output(tSrc.dtype)\n    .Constant('C', channel)\n    .Uniform('uT', 'float', threshold)\n    .LoadChunk('pickValue')\n    .GLSLKernel(kernel$c)\n    .Compile({ tSrc });\n};\n\nvar kernel$d = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/float HKW=floor(KW/2.0);float HKH=floor(KW/2.0);vec4 operation(float y,float x){float R=10000.0;float G=10000.0;float B=10000.0;y=y+HKH;x=x+HKW;for(float dx=0.0;dx<KW;dx+=1.0){for(float dy=0.0;dy<KH;dy+=1.0){vec4 v=pickValue_tSrc((y-dy),(x-dx));vec4 m=pickValue_tKernel(dy,dx);if(v.r<R&&m.r>0.0){R=v.r;}if(v.g<G&&m.g>0.0){G=v.g;}if(v.b<B&&m.b>0.0){B=v.b;}}}return vec4(R,G,B,1.0);}\";\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\n/**\n * @name Erosion\n * @description\n *  Erosion is one of two fundamental operations (the other being dilation)\n *  in morphological image processing from which all other morphological operations are based.\n *  It was originally defined for binary images, later being extended to grayscale images,\n *  and subsequently to complete lattices.\n *  [Wiki](https://en.wikipedia.org/wiki/Erosion_(morphology))\n * @example\n *  gm.erode(inputImage, [3, 3]);\n * @param {Tensor} tSrc - The source image to be downsampled.\n * @param {Array.<number>} kernelSize - Size of structure element.\n * @param {Tensor} tKernel - Optional kernel.\n */\n\n\nvar erode = (\n  tSrc,\n  kernelSize = [2, 2],\n  tKernel = false,\n) => {\n  assert$$1(\n    kernelSize.length === 2,\n    'Erosion: Kernel size should be shape of rank 2',\n  );\n\n  if (isTensor$$1(tKernel)) {\n    assert$$1(\n      kernelSize[0] === tKernel.shape[0] && kernelSize[1] === tKernel.shape[1],\n      'Erosion: Structure element has wrong size',\n    );\n  }\n\n  if (!tKernel) {\n    tKernel = new Tensor('float32', [kernelSize[0], kernelSize[1], 4]);\n\n    for (let x = 0; x < kernelSize[0]; x += 1) {\n      for (let y = 0; y < kernelSize[1]; y += 1) {\n        tKernel.set(x, y, 0, 1);\n        tKernel.set(x, y, 1, 1);\n        tKernel.set(x, y, 2, 1);\n        tKernel.set(x, y, 3, 1);\n      }\n    }\n  }\n\n  return new RegisterOperation('Erosion')\n    .Input('tSrc', tSrc.dtype)\n    .Input('tKernel', 'float32')\n    .Output(tSrc.dtype)\n    .Constant('KW', kernelSize[0])\n    .Constant('KH', kernelSize[1])\n    .LoadChunk('pickValue')\n    .GLSLKernel(kernel$d)\n    .Compile({ tSrc, tKernel });\n};\n\nvar kernel$e = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/float HKW=floor(KW/2.0);float HKH=floor(KW/2.0);vec4 operation(float y,float x){float R=0.0;float G=0.0;float B=0.0;y=y+HKH;x=x+HKW;for(float dx=0.0;dx<KW;dx+=1.0){for(float dy=0.0;dy<KH;dy+=1.0){vec4 v=pickValue_tSrc((y-dy),(x-dx));vec4 m=pickValue_tKernel(dy,dx);if(v.r>R&&m.r>0.0){R=v.r;}if(v.g>G&&m.g>0.0){G=v.g;}if(v.b>B&&m.b>0.0){B=v.b;}}}return vec4(R,G,B,1.0);}\";\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\n/**\n * @name Dilation\n * @description\n *  Dilation is one of the basic operations in mathematical morphology.\n *  Originally developed for binary images, it has been expanded first to grayscale images,\n *  and then to complete lattices. The dilation operation usually uses a structuring element\n *  for probing and expanding the shapes contained in the input image.\n *  [Wiki](https://en.wikipedia.org/wiki/Dilation_(morphology))\n * @example\n *  gm.dilate(inputImage, [3, 3]);\n * @param {Tensor} tSrc - The source image to be downsampled.\n * @param {Array.<number>} kernelSize - Size of structure element.\n * @param {Tensor} tKernel - Optional kernel.\n */\n\nvar dilate = (\n  tSrc,\n  kernelSize = [2, 2],\n  tKernel = false,\n) => {\n  assert$$1(\n    kernelSize.length === 2,\n    'Dilation: Kernel size should be shape of rank 2',\n  );\n\n  if (isTensor$$1(tKernel)) {\n    assert$$1(\n      kernelSize[0] === tKernel.shape[0] && kernelSize[1] === tKernel.shape[1],\n      'Dilation: Structure element has wrong size',\n    );\n  }\n\n  if (!tKernel) {\n    tKernel = new Tensor('float32', [kernelSize[0], kernelSize[1], 4]);\n\n    for (let x = 0; x < kernelSize[0]; x += 1) {\n      for (let y = 0; y < kernelSize[1]; y += 1) {\n        tKernel.set(x, y, 0, 1);\n        tKernel.set(x, y, 1, 1);\n        tKernel.set(x, y, 2, 1);\n        tKernel.set(x, y, 3, 1);\n      }\n    }\n  }\n\n  return new RegisterOperation('Dilation')\n    .Input('tSrc', tSrc.dtype)\n    .Input('tKernel', 'float32')\n    .Output(tSrc.dtype)\n    .Constant('KW', kernelSize[0])\n    .Constant('KH', kernelSize[1])\n    .LoadChunk('pickValue')\n    .GLSLKernel(kernel$e)\n    .Compile({ tSrc, tKernel });\n};\n\nvar kernel$f = \"/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float y,float x){vec4 A=pickValue_tA(y,x);vec4 B=pickValue_tB(y,x);return vec4(A.rgb-B.rgb,1.0);}\";\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\n/**\n * @name Substract\n * @description\n *  Pixel wise substruction tensor A from tensor B\n * @example\n *  gm.sub(A, B);\n * @param {Tensor} tA - The first input\n * @param {Tensor} tB - The second input\n */\n\nvar sub = (tA, tB) => {\n  assert$$1(\n    tA.dtype === tB.dtype,\n    `Substract: inputs should have the same dtype, got ${tA.dtype} and ${tB.dtype}`,\n  );\n\n  assert$$1(\n    tA.shape[0] === tB.shape[0] && tA.shape[1] === tB.shape[1] && tA.shape[3] === tB.shape[3],\n    `Substract: inputs should have the same shapes, got ${tA.shape} and ${tB.shape}`,\n  );\n\n  return new RegisterOperation('Substract')\n    .Input('tA', tA)\n    .Input('tB', tB)\n    .Output(tA.dtype)\n    .LoadChunk('pickValue')\n    .GLSLKernel(kernel$f)\n    .Compile({ tA, tB });\n};\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\n/**\n * @name MorphTransform\n * @description\n\n * @example\n *  gm.morphologyEx(inputImage, 'open', [3, 3]);\n * @param {Tensor} tSrc - The source image to be downsampled.\n * @param {string} type - Size of structure element.\n * @param {Array.<number>} kernelSize - Size of structure element\n * @param {Tensor} tKernel - Optional kernel.\n */\n\nvar index$h = (\n  tSrc,\n  type = 'open',\n  kernelSize = [2, 2],\n  tKernel = false,\n) => {\n  switch (type) {\n    case 'open':\n      return dilate(erode(tSrc, kernelSize, tKernel), kernelSize, tKernel);\n    case 'close':\n      return erode(dilate(tSrc, kernelSize, tKernel), kernelSize, tKernel);\n    case 'gradient':\n      return sub(\n        dilate(tSrc, kernelSize, tKernel),\n        erode(tSrc, kernelSize, tKernel),\n      );\n    case 'tophat':\n      return sub(\n        tSrc,\n        dilate(erode(tSrc, kernelSize, tKernel), kernelSize, tKernel),\n      );\n    case 'blackhat':\n      return sub(\n        erode(dilate(tSrc, kernelSize, tKernel), kernelSize, tKernel),\n        tSrc,\n      );\n    default:\n      return new Error(`MorphTransform: unsopported operation type ${type}`);\n  }\n};\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\n/**\n * @license MIT\n * @author Arkadiy Pilguk(apilguk@gmail.com)\n * @author Mihail Zachepilo(mihailzachepilo@gmail.com)\n * Copyright 2018 Peculiar Ventures and Pentatonica.\n * All rights reserved.\n */\n\nexport { Rect, Line, TypedPool, Session, GPUTexture as GLTexture, RegisterOperation, Tensor, Operation, initDrawable, initMouseTracking, toImageData, getImageData, putImageData, canvasFromTensor, canvasToTensor, canvasDrawLine, canvasDrawCircle, canvasFillCircle, clearCanvas, canvasDrawRect, canvasFill, canvasClear, canvasInit, canvasCreate, imageTensorFromURL, CaptureVideo, assert$$1 as assert, assertShapesAreEqual$$1 as assertShapesAreEqual, isValidShape$$1 as isValidShape, isOperation$$1 as isOperation, isTensor$$1 as isTensor, isValidGLSLChunk$$1 as isValidGLSLChunk, isValidGLSLVariableName$$1 as isValidGLSLVariableName, isValidOperationShape$$1 as isValidOperationShape, DeprecationError$$1 as DeprecationError, deprecationWarning$$1 as deprecationWarning, deprecationError$$1 as deprecationError, index as grayscale, index$1 as gaussianBlur, index$2 as downsample, index$3 as sobelOperator, index$4 as hog, index$5 as cast, index$6 as cannyEdges, index$7 as colorSegmentation, meanStdOp as meanStd, histogramOp as histogram, minMaxOp as minMax, index$8 as motionDetect, index$9 as skinTest, slidingWindowOp as slidingWindow, index$a as swt, index$b as concat, norm, index$c as histogramEqualization, index$d as perspectiveProjection, index$e as pcLines, index$f as HSVColor, index$g as threshold, erode, dilate, sub, index$h as morphologyEx, range, tensorFrom, tensorClone, tensorInvert, tensorAssertEqual, tensorAssertCloseEqual, tensorAssertMSEEqual, flipTensor, invertTensor, tensorMap, tensorOnes, sortPoints, angleBetweenLines, transfromPoint, genetateTransformMatrix };\n","export default function isTensor2D(shape) {\n  if (shape.length !== 2) {\n    throw new Error(`Invalid rank, expected two-dimensional tensor\n      for example - [100, 2]\n      actually - [${shape}]`);\n  }\n  if (shape[1] !== 2) {\n    throw new Error(`Invalid second shape argument\n      expected - 2\n      actually - ${shape[1]}`);\n  }\n}\n","import * as gm from 'gammacv';\nimport isTensor2D from './utils';\n\nconst defaultStyles = {\n  dataStyle: {\n    lineWidth: null,\n    lineColor: '#cccccc',\n    pointSize: 4,\n    pointColor: '#ff0000',\n    pointBorder: null,\n    bgColor: null,\n  },\n  legendGrid: [3, 7],\n  indent: {\n    xAxis: 30,\n    yAxis: 40,\n    xMark: 10,\n    yMark: 5,\n  },\n  bottomPadding: 20,\n  size: [800, 400],\n};\n\nconst findMinMax = (axis, tensor) => {\n  let min = Infinity;\n  let max = -Infinity;\n\n  for (let i = 0; i < tensor.shape[0]; i += 1) {\n    const elem = tensor.get(i, axis === 'x' ? 0 : 1);\n\n    if (elem < min) min = elem;\n    if (elem > max) max = elem;\n  }\n\n  return { min, max };\n};\n\n/**\n *\n * @param {string} axis\n * @param {object} canvas\n * @param {array} tensorArray\n * @param {object} styles\n */\nconst drawAxisGrid = (axis, canvas, { min, max, roundedMax }, styles, type) => {\n  const {\n    font,\n    legendFontSize,\n    legendFontColor,\n    legendRulerColor,\n    legendGuidesColor,\n    xAxisLabels,\n    showRulerY,\n    indent: styleIndent,\n    yAxisFromMinVal,\n    legendGrid,\n    showMinY,\n  } = styles;\n  let { bottomPadding } = defaultStyles;\n  bottomPadding = type === 'histogram' ? 0 : bottomPadding;\n\n  const isXAxis = axis === 'x';\n  const isYAxis = axis === 'y';\n\n  const axisGrid = legendGrid\n    ? legendGrid[isXAxis ? 1 : 0]\n    : defaultStyles.legendGrid[isXAxis ? 1 : 0];\n\n  const indent = styleIndent || defaultStyles.indent;\n\n  const axisStep = ((isXAxis ? canvas.width : canvas.height - bottomPadding) - indent[`${axis}Axis`] * 2) / axisGrid;\n\n  const legendStep = (\n    isYAxis\n      ? (isYAxis ? roundedMax : max) - min\n      : max\n  ) / (isXAxis ? axisGrid - 1 : axisGrid);\n\n  const precision = legendStep.toString().split('.')[1];\n  const digits = precision ? precision.length : 0;\n\n  const axisLegendValues = new Array(axisGrid);\n  let tempLegendValue = min;\n\n  for (let i = 0; i < axisGrid; i += 1) {\n    let val = 0;\n\n    if (i === 0) {\n      val = yAxisFromMinVal ? min : 0;\n    } else {\n      tempLegendValue += legendStep;\n      val = tempLegendValue;\n    }\n\n    axisLegendValues[i] = (val.toFixed(digits >= 2 ? 2 : digits));\n  }\n\n  for (let i = 0; i < axisGrid; i += 1) {\n    const tempX = isXAxis\n      ? axisStep * i + indent.xAxis\n      : indent.xAxis;\n    const tempY = isXAxis\n      ? canvas.height - indent.yAxis\n      : canvas.height - (axisStep * i + indent.yAxis);\n\n    if ((showRulerY && isYAxis) || isXAxis) {\n      /* draw rulers */\n      gm.canvasDrawLine(canvas, [\n        tempX,\n        isXAxis ? tempY : tempY - bottomPadding,\n        isXAxis ? tempX + axisStep : tempX,\n        isXAxis ? tempY : tempY - axisStep - bottomPadding,\n      ], legendRulerColor);\n\n      /* draw division marks */\n      gm.canvasDrawLine(canvas, [\n        tempX,\n        isXAxis ? tempY : tempY - bottomPadding,\n        isXAxis ? tempX : indent.xAxis - 10,\n        isXAxis ? canvas.height - indent.yAxis + 10 : tempY - bottomPadding,\n      ], legendRulerColor);\n\n      /* draw last mark */\n      if (i === axisGrid - 1) {\n        gm.canvasDrawLine(canvas, [\n          isXAxis ? tempX + axisStep : tempX,\n          isXAxis ? tempY : tempY - axisStep - bottomPadding,\n          isXAxis ? tempX + axisStep : indent.xAxis - 10,\n          isXAxis ? canvas.height - indent.yAxis + 10 : tempY - axisStep - bottomPadding,\n        ], legendRulerColor);\n      }\n    }\n\n    /* draw guides */\n    if ((isYAxis && i !== 0) || (isXAxis && type !== 'histogram')) {\n      gm.canvasDrawLine(canvas, [\n        isXAxis ? tempX + axisStep / 2 : tempX,\n        isXAxis ? tempY : tempY - bottomPadding,\n        isXAxis ? tempX + axisStep / 2 : canvas.width - indent.xAxis,\n        isXAxis ? indent.yAxis : tempY - bottomPadding,\n      ], legendGuidesColor);\n    }\n\n    /* draw last Y guide */\n    if (i === axisGrid - 1 && isYAxis) {\n      gm.canvasDrawLine(canvas, [\n        tempX,\n        tempY - axisStep - bottomPadding,\n        canvas.width - indent.xAxis,\n        tempY - axisStep - bottomPadding,\n      ], legendGuidesColor);\n    }\n\n    const ctx = canvas.getContext('2d');\n    const markTxt = (xAxisLabels && xAxisLabels[i] && isXAxis)\n      ? xAxisLabels[i].toUpperCase()\n      : axisLegendValues[i];\n\n    ctx.beginPath();\n    ctx.fillStyle = legendFontColor;\n    ctx.font = `${legendFontSize}pt ${font}`;\n    ctx.textAlign = isXAxis ? 'center' : 'end';\n    ctx.textBaseline = 'middle';\n\n    if (!showMinY && i === 0 && isYAxis) {\n      continue;\n    } else {\n      ctx.fillText(\n        markTxt,\n        isXAxis ? tempX + axisStep / 2 : indent.xAxis - indent.yMark,\n        isXAxis ? canvas.height - indent.yAxis + indent.xMark : tempY - bottomPadding,\n      );\n    }\n\n    if (i === axisGrid - 1 && isYAxis) {\n      ctx.fillText(\n        roundedMax,\n        indent.xAxis - indent.yMark,\n        tempY - axisStep - bottomPadding,\n      );\n    }\n  }\n};\n\n/**\n *\n * @param {number} index\n * @param {object} canvas\n * @param {tensor} tensor\n * @param {object} styles\n * @param {object} maxChart\n */\nconst drawData = (index, dataCount, canvas, tensor, styles, { x, y }, type) => {\n  const {\n    dataStyles,\n    indent: styleIndent,\n    yAxisFromMinVal,\n    legendGrid,\n  } = styles;\n  const { bottomPadding } = defaultStyles;\n\n  const dataStyle = (dataStyles && dataStyles[index])\n    ? dataStyles[index]\n    : defaultStyles.dataStyle;\n\n  const {\n    lineWidth,\n    lineColor,\n    pointSize,\n    pointBorder,\n    pointColor,\n  } = dataStyle;\n\n  const chartScale = (y.max - y.min) * 100 / y.roundedMax;\n\n  const indent = styleIndent || defaultStyles.indent;\n\n  const tempYMin = (yAxisFromMinVal || y.min < 0) ? y.min : 0;\n\n  const gridHeight = canvas.height - indent.yAxis * 2;\n  const drawHeight = ((gridHeight - bottomPadding) * chartScale / 100);\n\n  const xGrid = legendGrid ? legendGrid[1] : defaultStyles.legendGrid[1];\n  const xStep = (canvas.width - indent.xAxis * 2) / xGrid;\n\n  const normX = new Array(tensor.shape[0]);\n  const normY = new Array(tensor.shape[0]);\n\n  for (let i = 0; i < tensor.shape[0]; i += 1) {\n    normX[i] = (tensor.get(i, 0) - x.min) / // eslint-disable-line\n      (x.max - x.min) * (canvas.width - indent.xAxis * 2 - xStep);\n    normY[i] = canvas.height - ((tensor.get(i, 1) - tempYMin) / // eslint-disable-line\n      (y.max - tempYMin) * drawHeight);\n  }\n\n  if (type !== 'scatter' && type !== 'histogram') {\n    for (let i = 0; i < tensor.shape[0]; i += 1) {\n      gm.canvasDrawLine(canvas, [\n        normX[i] + indent.xAxis + xStep / 2,\n        normY[i] - bottomPadding - indent.yAxis,\n        normX[i + 1] + indent.xAxis + xStep / 2,\n        normY[i + 1] - bottomPadding - indent.yAxis,\n      ], lineColor, lineWidth);\n    }\n  }\n\n  if (type === 'histogram') {\n    const columnWidth = xStep / dataCount;\n\n    for (let i = 0; i < tensor.shape[0]; i += 1) {\n      gm.canvasDrawLine(canvas, [\n        indent.xAxis + xStep * i + columnWidth / 2 + columnWidth * index,\n        normY[i]/*  - bottomPadding */ - indent.yAxis,\n        indent.xAxis + xStep * i + columnWidth / 2 + columnWidth * index,\n        canvas.height/*  - bottomPadding */ - indent.yAxis,\n      ], dataStyle.bgColor, columnWidth);\n    }\n  }\n\n  if (type !== 'histogram') {\n    for (let i = 0; i < tensor.shape[0]; i += 1) {\n      gm.canvasFillCircle(canvas, [\n        normX[i] + indent.xAxis + xStep / 2,\n        normY[i] - bottomPadding - indent.yAxis,\n      ], pointSize, pointColor);\n      if (pointBorder) {\n        gm.canvasDrawCircle(canvas, [\n          normX[i] + indent.xAxis + xStep / 2,\n          normY[i] - bottomPadding - indent.yAxis,\n        ], pointSize + 1, pointBorder);\n      }\n    }\n  }\n};\n\n/**\n *\n * @param {array} tensorArray\n * @param {object} styles\n */\nconst canvasDrawChart = (tensorArray, styles, sourceCanvas, type) => {\n  const {\n    size: styleSize,\n    legendGrid,\n  } = styles;\n  const size = styleSize || defaultStyles.size;\n\n  const canvas = sourceCanvas || gm.canvasCreate();\n\n  canvas.width = size[0] * window.devicePixelRatio;\n  canvas.height = size[1] * window.devicePixelRatio;\n\n  canvas.style.width = `${size[0]}px`;\n  canvas.style.height = `${size[1]}px`;\n\n  canvas.getContext('2d').scale(window.devicePixelRatio, window.devicePixelRatio);\n\n  const fakeCanvas = {\n    width: size[0],\n    height: size[1],\n    getContext: () => canvas.getContext('2d'),\n  };\n\n  const boundaries = {\n    x: {\n      min: Infinity,\n      max: -Infinity,\n    },\n    y: {\n      min: Infinity,\n      max: -Infinity,\n      roundedMax: null,\n    },\n  };\n\n  for (let i = 0; i < tensorArray.length; i += 1) {\n    Object.keys(boundaries).forEach((key) => {\n      const { min, max } = findMinMax(key, tensorArray[i]);\n      if (min < boundaries[key].min) boundaries[key].min = min;\n      if (max > boundaries[key].max) boundaries[key].max = max;\n    });\n  }\n\n  boundaries.y.roundedMax = Math.ceil((boundaries.y.max + 1) / legendGrid[0]) * legendGrid[0];\n\n  Object.keys(boundaries).forEach((key) => {\n    drawAxisGrid(key, fakeCanvas, boundaries[key], styles, type);\n  });\n\n  for (let i = 0; i < tensorArray.length; i += 1) {\n    isTensor2D(tensorArray[i].shape);\n    drawData(i, tensorArray.length, fakeCanvas, tensorArray[i], styles, boundaries, type);\n  }\n};\n\nexport default canvasDrawChart;\n","import * as gm from 'gammacv';\nimport canvasDrawChart from '../lib';\n\nconst plotCanvas = document.getElementById('plot');\nconst scatterCanvas = document.getElementById('scatter');\nconst histogramCanvas = document.getElementById('histogram');\n\nconst dimension = 6;\nconst samplesCount = 10;\nconst tensorArray = [];\n\nconst plotStyles = {\n  dataStyles: [\n    {\n      lineWidth: 2,\n      lineColor: 'rgba(20, 110, 255, 0.2)',\n      pointSize: 5,\n      pointColor: '#146eff',\n      pointBorder: '#ffffff',\n    }, {\n      lineWidth: 2,\n      lineColor: 'rgba(252, 208, 15, 0.2)',\n      pointSize: 5,\n      pointColor: 'rgb(252, 208, 15)',\n      pointBorder: '#ffffff',\n    }, {\n      lineWidth: 2,\n      lineColor: 'rgba(168, 168, 168, 0.2)',\n      pointSize: 5,\n      pointColor: 'rgb(168, 168, 168)',\n      pointBorder: '#ffffff',\n    },\n  ],\n  showRulerY: false,\n  font: 'Open Sans',\n  legendGrid: [3, 10],\n  legendFontSize: 10,\n  legendFontColor: 'rgba(7, 15, 82, 0.8)',\n  legendGuidesColor: 'rgba(7, 15, 82, 0.1)',\n  legendRulerColor: 'rgba(7, 15, 82, 0.4)',\n  indent: {\n    xAxis: 40,\n    yAxis: 22,\n    xMark: 15,\n    yMark: 6,\n  },\n  xAxisLabels: ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'],\n  yAxisFromMinVal: true,\n  showMinY: false,\n  roundMax: true,\n};\n\nconst scatterStyles = {\n  dataStyles: [\n    {\n      pointSize: 5,\n      pointColor: '#146eff',\n      pointBorder: '#ffffff',\n    }, {\n      pointSize: 5,\n      pointColor: 'rgb(252, 208, 15)',\n      pointBorder: '#ffffff',\n    }, {\n      pointSize: 5,\n      pointColor: 'rgb(168, 168, 168)',\n      pointBorder: '#ffffff',\n    },\n  ],\n  showRulerY: false,\n  font: 'Open Sans',\n  legendGrid: [3, 10],\n  legendFontSize: 10,\n  legendFontColor: 'rgba(7, 15, 82, 0.8)',\n  legendGuidesColor: 'rgba(7, 15, 82, 0.1)',\n  legendRulerColor: 'rgba(7, 15, 82, 0.4)',\n  indent: {\n    xAxis: 40,\n    yAxis: 22,\n    xMark: 15,\n    yMark: 6,\n  },\n  yAxisFromMinVal: true,\n  showMinY: false,\n  roundMax: true,\n};\n\nconst histStyles = {\n  dataStyles: [\n    {\n      bgColor: '#146eff',\n    }, {\n      bgColor: 'rgb(252, 208, 15)',\n    }, {\n      bgColor: 'rgb(168, 168, 168)',\n    },\n  ],\n  showRulerY: false,\n  font: 'Open Sans',\n  legendGrid: [3, samplesCount],\n  legendFontSize: 10,\n  legendFontColor: 'rgba(7, 15, 82, 0.8)',\n  legendGuidesColor: 'rgba(7, 15, 82, 0.1)',\n  legendRulerColor: 'rgba(7, 15, 82, 0.4)',\n  indent: {\n    xAxis: 40,\n    yAxis: 22,\n    xMark: 15,\n    yMark: 6,\n  },\n  xAxisLabels: ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'],\n  yAxisFromMinVal: true,\n  showMinY: false,\n  roundMax: true,\n};\n\nfor (let a = 0; a < dimension; a += 1) {\n  const tensor = new gm.Tensor('float32', [samplesCount, 2]);\n\n  for (let i = 0; i < samplesCount; i += 1) {\n    tensor.set(i, 0, i);\n    tensor.set(i, 1, Math.random() * 20);\n  }\n\n  tensorArray.push(tensor);\n}\n\ncanvasDrawChart(tensorArray, plotStyles, plotCanvas, 'plot');\ncanvasDrawChart(tensorArray, scatterStyles, scatterCanvas, 'scatter');\ncanvasDrawChart(tensorArray, histStyles, histogramCanvas, 'histogram');\n"]}