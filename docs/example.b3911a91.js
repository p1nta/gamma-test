parcelRequire=function(e,r,n,t){var i="function"==typeof parcelRequire&&parcelRequire,o="function"==typeof require&&require;function u(n,t){if(!r[n]){if(!e[n]){var f="function"==typeof parcelRequire&&parcelRequire;if(!t&&f)return f(n,!0);if(i)return i(n,!0);if(o&&"string"==typeof n)return o(n);var c=new Error("Cannot find module '"+n+"'");throw c.code="MODULE_NOT_FOUND",c}p.resolve=function(r){return e[n][1][r]||r};var l=r[n]=new u.Module(n);e[n][0].call(l.exports,p,l,l.exports,this)}return r[n].exports;function p(e){return u(p.resolve(e))}}u.isParcelRequire=!0,u.Module=function(e){this.id=e,this.bundle=u,this.exports={}},u.modules=e,u.cache=r,u.parent=i,u.register=function(r,n){e[r]=[function(e,r){r.exports=n},{}]};for(var f=0;f<n.length;f++)u(n[f]);if(n.length){var c=u(n[n.length-1]);"object"==typeof exports&&"undefined"!=typeof module?module.exports=c:"function"==typeof define&&define.amd?define(function(){return c}):t&&(this[t]=c)}return u}({"AYih":[function(require,module,exports) {
"use strict";function sortPoints(t,e){const a=[0,0];let i=null,r=null,n=null,o=null;a[0]+=t[0][0],a[0]+=t[1][0],a[0]+=t[2][0],a[0]+=t[3][0],a[1]+=t[0][1],a[1]+=t[1][1],a[1]+=t[2][1],a[1]+=t[3][1],a[0]/=4,a[1]/=4;for(let e=0;e<t.length;e+=1)t[e][0]>=a[0]&&t[e][1]>=a[1]&&(n=t[e]),t[e][0]<=a[0]&&t[e][1]<=a[1]&&(i=t[e]),t[e][0]>=a[0]&&t[e][1]<=a[1]&&(r=t[e]),t[e][0]<=a[0]&&t[e][1]>=a[1]&&(o=t[e]);return[i,r,n,o]}function angleBetweenLines(t,e){const a=t[2]-t[0],i=t[3]-t[1],r=e[2]-e[0],n=e[3]-e[1],o=a*r+i*n,s=(a*a+i*i)*(r*r+n*n);return Math.acos(o/Math.sqrt(s))}function transfromPoint(t,e,a){const i=a;let r=0,n=0,o=0,s=0,l=0,c=0;return o=i.get(0,1)*e+i.get(0,2),s=i.get(1,1)*e+i.get(1,2),l=i.get(2,1)*e+i.get(2,2),o+=i.get(0,0)*t,s+=i.get(1,0)*t,[r=o*(c=1/(l+=i.get(2,0)*t)),n=s*c]}function genetateTransformMatrix(t,e,a,i=0){return perspective_4point_transform(a,i,i,t.ax,t.ay,e[1]-i,i,t.bx,t.by,e[1]-i,e[0]-i,t.cx,t.cy,i,e[0]-i,t.dx,t.dy,3===a.shape.length&&4===a.shape[2]),a}function perspective_4point_transform(t,e,a,i,r,n,o,s,l,c,h,u,d,p,f,g,m,x=!1){let y=e,v=c,S=o,k=y*v*S,T=f,E=y*T,C=v*E,$=h,b=y*$,_=n,I=a,A=p,w=I*A,M=w*_,P=A*_*$,V=A*S,R=A*$,O=v*S,L=T*v,K=T*_,U=$*_,G=1/(V-R-O+L-K+U),F=y*A,D=I*_,z=S*y,N=T*z,H=I*v,W=w*$,X=I*$*_,B=S*T*v,Y=T*I;const j=-(C-k+b*_-_*E-w*v+M-P+V*v)*G,q=(k-C-F*S+F*$+M-v*D+K*v-P)*G,Z=y,J=(-$*E+N+H*S-w*S+W-X+K*$-B)*G,Q=(z*$-N-Y*v+W-X+Y*_+B-V*$)*G,tt=I,et=(-b+z+H-D+R-V-L+K)*G,at=(-E+b+w-H+K-U-V+O)*G,it=-((C=(v=u)*(E=(y=i)*(T=m)))-(k=y*v*(S=l))+(b=y*($=d))*(_=s)-_*E-(w=(I=r)*(A=g))*v+(M=w*_)-(P=A*_*$)+(V=A*S)*v)*(G=1/(V-(R=A*$)-(O=v*S)+(L=T*v)-(K=T*_)+(U=$*_))),rt=(k-C-(F=y*A)*S+F*$+M-v*(D=I*_)+K*v-P)*G,nt=y,ot=(-$*E+(N=T*(z=S*y))+(H=I*v)*S-w*S+(W=w*$)-(X=I*$*_)+K*$-(B=S*T*v))*G,st=(z*$-N-(Y=T*I)*v+W-X+Y*_+B-V*$)*G,lt=I,ct=(-b+z+H-D+R-V-L+K)*G,ht=(-E+b+w-H+K-U-V+O)*G,ut=Z*et;M=tt*et-J;const dt=-J*at+Q*et,pt=j-ut;D=j*at-(b=q*et);const ft=(k=j*tt)-(C=Z*J),gt=(S=j*Q)-(E=J*q);X=(v=Q-at*tt)*(A=1/(S-k*at-E+C*at+b*tt-ut*Q));const mt=(U=Z*at-q)*A,xt=(z=-q*tt+Z*Q)*A,yt=t.data;x?(yt[0]=it*X+rt*(M*A)-nt*(dt*A),yt[1]=it*mt+rt*(pt*A)-nt*(D*A),yt[2]=-it*xt-rt*(ft*A)+nt*(gt*A),yt[4]=ot*X+st*(M*A)-lt*(dt*A),yt[5]=ot*mt+st*(pt*A)-lt*(D*A),yt[6]=-ot*xt-st*(ft*A)+lt*(gt*A),yt[8]=ct*X+ht*(M*A)-dt*A,yt[9]=ct*mt+ht*(pt*A)-D*A,yt[10]=-ct*xt-ht*(ft*A)+gt*A):(yt[0]=it*X+rt*(M*A)-nt*(dt*A),yt[1]=it*mt+rt*(pt*A)-nt*(D*A),yt[2]=-it*xt-rt*(ft*A)+nt*(gt*A),yt[3]=ot*X+st*(M*A)-lt*(dt*A),yt[4]=ot*mt+st*(pt*A)-lt*(D*A),yt[5]=-ot*xt-st*(ft*A)+lt*(gt*A),yt[6]=ct*X+ht*(M*A)-dt*A,yt[7]=ct*mt+ht*(pt*A)-D*A,yt[8]=-ct*xt-ht*(ft*A)+gt*A)}Object.defineProperty(exports,"__esModule",{value:!0});const eps=1e-7;function between(t,e,a){return t-eps<=e&&e<=a+eps}class Line{static Intersection(t,e){const a=t.x1,i=t.y1,r=t.x2,n=t.y2,o=e.x1,s=e.y1,l=e.x2,c=e.y2,h=((a*n-i*r)*(o-l)-(a-r)*(o*c-s*l))/((a-r)*(s-c)-(i-n)*(o-l)),u=((a*n-i*r)*(s-c)-(i-n)*(o*c-s*l))/((a-r)*(s-c)-(i-n)*(o-l));if(isNaN(h)||isNaN(u))return!1;if(a>=r){if(!between(r,h,a))return!1}else if(!between(a,h,r))return!1;if(i>=n){if(!between(n,u,i))return!1}else if(!between(i,u,n))return!1;if(o>=l){if(!between(l,h,o))return!1}else if(!between(o,h,l))return!1;if(s>=c){if(!between(c,u,s))return!1}else if(!between(s,u,c))return!1;return[h,u]}constructor(t,e,a,i,r,n){if(t instanceof ArrayBuffer)this.data=new Float32Array(t,e,8);else if(Array.isArray(t)){if(t.length<8)for(let e=t.length;e<=8;e+=1)t.push(0);this.data=new Float32Array(t)}else this.data=void 0!==t&&void 0!==e?new Float32Array([t,e,a,i,r,n,0,0]):new Float32Array(8)}set(t,e,a,i,r,n){this.data[0]=t,this.data[1]=e,this.data[2]=a,this.data[3]=i,this.data[4]=r,this.data[5]=n,this.data[6]=0,this.data[7]=0}fromParallelCoords(t,e,a,i,r,n){const o=a;let s,l;l=t>n?(n/(t-=n)-1)*a+(s=r-n*e/t):(1-n/(t=n-t))*a+(s=n*e/t),this.set(0,s,o,l,t,e)}get length(){if(this.data[6])return this.data[6];const t=this.data[2]-this.data[0],e=this.data[3]-this.data[1],a=Math.sqrt(t**2+e**2);return this.data[6]=a,a}get angle(){if(this.data[7])return this.data[7];const t=this.data[2]-this.data[0],e=this.data[3]-this.data[1];let a=Math.atan(e/t)/Math.PI*180;return a<0&&(a=180+a),this.data[7]=a,a}get x1(){return this.data[0]}get y1(){return this.data[1]}get x2(){return this.data[2]}get y2(){return this.data[3]}get px(){return this.data[4]}get py(){return this.data[5]}set x1(t){this.data[0]=t}set y1(t){this.data[1]=t}set x2(t){this.data[2]=t}set y2(t){this.data[3]=t}set px(t){this.data[4]=t}set py(t){this.data[5]=t}clear(){this.data[0]=0,this.data[1]=0,this.data[2]=0,this.data[3]=0,this.data[4]=0,this.data[5]=0,this.data[6]=0,this.data[7]=0}fromArray(t){this.data.set(t)}toArray(){return Array.prototype.slice.call(this.data)}}Line.BYTES_PER_ELEMENT=36;class Rect{static Distance(t,e){let a=0;for(let i=0;i<8;i+=2){a+=Math.sqrt((t.data[i]-e.data[i])**2+(t.data[i+1]-e.data[i+1])**2)**2}return(a=Math.sqrt(a/8))===1/0?0:a}static TriangleS(t,e,a,i,r,n){return Math.abs(t*(i-n)+a*(n-e)+r*(e-i))/2}constructor(...t){t[0]instanceof ArrayBuffer?this.data=new Float32Array(t[0],t[1],Rect.NUM_ELEMENTS):Array.isArray(t[0])?this.data=new Float32Array(t[0]):t[0]&&t.length===Rect.NUM_ELEMENTS?this.data=new Float32Array(t):this.data=new Float32Array(Rect.NUM_ELEMENTS)}isInRect(t,e){return!(Rect.TriangleS(t,e,this.ax,this.ay,this.bx,this.by)+Rect.TriangleS(t,e,this.cx,this.cy,this.bx,this.by)+Rect.TriangleS(this.cx,this.cy,t,e,this.dx,this.dy)+Rect.TriangleS(this.dx,this.dy,t,e,this.ax,this.ay)-this.area>0)}isNotEmpty(){return this.data[0]>0&&this.data[1]>0&&this.data[2]>0&&this.data[3]>0&&this.data[4]>0&&this.data[5]>0&&this.data[6]>0&&this.data[7]>0}clone(){return new Rect(this.toArray())}set(t,e,a,i,r,n,o,s){this.data[0]=t,this.data[1]=e,this.data[2]=a,this.data[3]=i,this.data[4]=r,this.data[5]=n,this.data[6]=o,this.data[7]=s}assign(t){return this.data.set(t.data),this}scale(t,e){return this.data[0]*=t,this.data[1]*=e,this.data[2]*=t,this.data[3]*=e,this.data[4]*=t,this.data[5]*=e,this.data[6]*=t,this.data[7]*=e,this}fromLines(t,e,a,i){const r=sortPoints([Line.Intersection(t,e),Line.Intersection(e,a),Line.Intersection(a,i),Line.Intersection(i,t)]);return!!(r[0]&&r[1]&&r[2]&&r[3])&&(this.data[0]=r[0][0],this.data[1]=r[0][1],this.data[2]=r[1][0],this.data[3]=r[1][1],this.data[4]=r[2][0],this.data[5]=r[2][1],this.data[6]=r[3][0],this.data[7]=r[3][1],!0)}get ax(){return this.data[0]}get ay(){return this.data[1]}get bx(){return this.data[2]}get by(){return this.data[3]}get cx(){return this.data[4]}get cy(){return this.data[5]}get dx(){return this.data[6]}get dy(){return this.data[7]}set ax(t){this.data[0]=t}set ay(t){this.data[1]=t}set bx(t){this.data[2]=t}set by(t){this.data[3]=t}set cx(t){this.data[4]=t}set cy(t){this.data[5]=t}set dx(t){this.data[6]=t}set dy(t){this.data[7]=t}get distA(){return Math.sqrt((this.data[6]-this.data[0])**2+(this.data[7]-this.data[1])**2)}get distB(){return Math.sqrt((this.data[4]-this.data[2])**2+(this.data[5]-this.data[3])**2)}get distC(){return Math.sqrt((this.data[0]-this.data[2])**2+(this.data[1]-this.data[3])**2)}get distD(){return Math.sqrt((this.data[6]-this.data[4])**2+(this.data[7]-this.data[5])**2)}get distE(){return Math.sqrt((this.data[0]-this.data[4])**2+(this.data[1]-this.data[5])**2)}get distF(){return Math.sqrt((this.data[6]-this.data[2])**2+(this.data[7]-this.data[3])**2)}get angleA(){return angleBetweenLines([this.data[6],this.data[7],this.data[0],this.data[1]],[this.data[0],this.data[1],this.data[2],this.data[3]])}get angleB(){return angleBetweenLines([this.data[0],this.data[1],this.data[2],this.data[3]],[this.data[2],this.data[3],this.data[4],this.data[5]])}get angleC(){return angleBetweenLines([this.data[2],this.data[3],this.data[4],this.data[5]],[this.data[4],this.data[5],this.data[6],this.data[7]])}get angleD(){return angleBetweenLines([this.data[4],this.data[5],this.data[6],this.data[7]],[this.data[6],this.data[7],this.data[0],this.data[1]])}get area(){const t=this.distA,e=this.distB,a=this.distC,i=this.distD,r=(t+e+a+i)/2;return Math.sqrt((r-t)*(r-e)*(r-a)*(r-i))}get P(){return this.distA+this.distB+this.distC+this.distD}mul(t){return this.data[0]*=t,this.data[1]*=t,this.data[2]*=t,this.data[3]*=t,this.data[4]*=t,this.data[5]*=t,this.data[6]*=t,this.data[7]*=t,this}scaleAt(t){return this.data[0]-=t,this.data[1]-=t,this.data[2]-=t,this.data[3]+=t,this.data[4]+=t,this.data[5]+=t,this.data[6]+=t,this.data[7]-=t,this}clear(){this.data[0]=0,this.data[1]=0,this.data[2]=0,this.data[3]=0,this.data[4]=0,this.data[5]=0,this.data[6]=0,this.data[7]=0}fromDeep(t){return this.data[0]=t[0][0],this.data[1]=t[0][1],this.data[2]=t[1][0],this.data[3]=t[1][1],this.data[4]=t[2][0],this.data[5]=t[2][1],this.data[6]=t[3][0],this.data[7]=t[3][1],this}perspective(t){const e=transfromPoint(this.data[0],this.data[1],t),a=transfromPoint(this.data[2],this.data[3],t),i=transfromPoint(this.data[4],this.data[5],t),r=transfromPoint(this.data[6],this.data[7],t);return this.data[0]=e[0],this.data[1]=e[1],this.data[2]=a[0],this.data[3]=a[1],this.data[4]=i[0],this.data[5]=i[1],this.data[6]=r[0],this.data[7]=r[1],this}fromArray(t){return this.data.set(t),this}toArray(){return Array.prototype.slice.call(this.data)}isInside(t){return t.ax>this.ax&&t.ay>this.ay&&t.bx<this.bx&&t.by>this.by&&t.cx<this.cx&&t.cy<this.cy&&t.dx>this.dx&&t.dy<this.dy}toJSON(){return this.toArray()}}Rect.NUM_ELEMENTS=8,Rect.BYTES_PER_ELEMENT=Rect.NUM_ELEMENTS*Float32Array.BYTES_PER_ELEMENT;class TypedPool{constructor(t,e){this.dataStore=new ArrayBuffer(e*t.BYTES_PER_ELEMENT),this.data=new Array(e),this.size=e;for(let a=0;a<e;a+=1)this.data[a]=new t(this.dataStore,a*t.BYTES_PER_ELEMENT);this.length=0}map(t,e){return this.data.map(t,e)}push(t){if(!(this.length<this.size))throw new Error("Typed Pool size exceed");this.data[this.length].data.set(t.data),this.length+=1}at(t){if(t>=this.size)throw new Error("Out of range requested");return this.data[t]}release(t){if(this.length=0,t)for(let t=0;t<this.size;t+=1)this.data[t].clear()}}class GraphNode{static GlobalCountIncrease(){return GraphNode.GlobalNodesCount+=1,GraphNode.GlobalNodesCount}constructor(t){this.id=GraphNode.GlobalCountIncrease(),this.name=`${t}:${this.id}`}}GraphNode.GlobalNodesCount=0;class GLUniform{constructor(t,e,a,i){this.gl=t,this.name=a,this.dtype=i,this.location=t.getUniformLocation(e,this.name)}set(t){const e=this.gl;switch(this.dtype){case"int":e.uniform1i(this.location,t);break;case"float":e.uniform1f(this.location,t);break;case"vec2":e.uniform2fv(this.location,t);break;case"vec3":e.uniform3fv(this.location,t);break;case"vec4":e.uniform4fv(this.location,t);break;case"mat3":e.uniformMatrix3fv(this.location,!1,t);break;case"mat4":e.uniformMatrix4fv(this.location,!1,t);break;default:return!1}return!0}}class GLBuffer{constructor(t,e,a,i){this.program=e,this.gl=t,this.name=a,this.dtype=i,this.location=t.getAttribLocation(this.program,this.name),this.ctx=t.createBuffer(),this.empty=new ArrayBuffer(1),"float"===i||"int"===i?this.size=1:(this.size=parseInt(/\d/g.exec(i)[0],10),t.enableVertexAttribArray(this.location))}set(t){const e=this.gl;this.bind(this.ctx),"int"===this.dtype?e.bufferData(e.ELEMENT_ARRAY_BUFFER,new Uint16Array(t),e.STATIC_DRAW):e.bufferData(e.ARRAY_BUFFER,new Float32Array(t),e.STATIC_DRAW)}bind(){const t=this.gl;"int"===this.dtype?t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.ctx):(t.bindBuffer(t.ARRAY_BUFFER,this.ctx),t.vertexAttribPointer(this.location,this.size,t.FLOAT,!1,0,0))}unbind(){const t=this.gl;"int"===this.dtype?t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null):(t.bindBuffer(t.ARRAY_BUFFER,null),t.vertexAttribPointer(this.location,this.size,t.FLOAT,!1,0,0))}disable(){this.gl.disableVertexAttribArray(this.ctx)}enable(){this.gl.enableVertexAttribArray(this.ctx)}delete(){this.gl.deleteBuffer(this.ctx),this.program=null,this.gl=null,this.ctx=null}}var vertexShader="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/precision highp float;attribute vec3 aVertexPosition;attribute vec2 aTextureCoords;varying vec2 texCoords;void main(void){texCoords=aTextureCoords;gl_Position=vec4(aVertexPosition,1.0);}";const errorStart="Error: An error occurred compiling the shaders: ";function getOffset(t){const e=/\d+\|(\s+)/.exec(t);return" ".repeat(e?e[1].length:2)}function prepareSourceLines(t){let e=t.split("\n");const a=(e.length+1).toString().length;return e=e.map((t,e)=>`${(e+1).toString().padStart(a)}|  ${t}`)}function calcErrorStats(t){let e=0,a=0;for(let i=0;i<t.length;i+=1)/ERROR/.exec(t[i])&&(e+=1),/WARNING/.exec(t[i])&&(a+=1);return{errCount:e,warnCount:a}}function injectAll(t,e,a=!0){const i=prepareSourceLines(t),r=(i.length+1).toString().length;let n=e.toString();const o=[],s=[];n.startsWith(errorStart)&&(n=n.substr(errorStart.length));const l=n.split("\n"),c=calcErrorStats(l);let h=0;for(let t=0;t<l.length;t+=1){const e=l[t],n=/0:(\d+)/.exec(e);if(n){const t=+n[1]+h,l=`${" ".repeat(r)}|${getOffset(i[t-1])}`;o.push(`${e}\n${i[t-2]}\n${i[t-1]}\n${l}^\n${i[t]}`);const c=a?"%c":"";i.splice(t,0,`${c}${l}^--${e}${c}`),a&&(s.push("color: red;"),s.push("color: inherit;")),h+=1}}return{fullText:i.join("\n"),firstError:o[0],errorsStats:c,fullTextStyle:s}}function processError(t,e,a){try{const i=injectAll(t,a),r=i.errorsStats;console.group(`Error: An error occurred compiling the shader ${e}: ${r.errCount} ERRORS, ${r.warnCount} WARNINGS`),console.log(i.firstError),console.groupCollapsed("Show more"),console.log(i.fullText,...i.fullTextStyle),console.groupEnd(),console.groupEnd()}catch(t){console.warn("Unable to process GLSG compiling error.")}}const parameters={};function testFloatTextures(){const t=document.createElement("canvas").getContext("webgl");if(!t)return!1;if(!t.getExtension("OES_texture_float"))return!1;const e=t.createFramebuffer(),a=t.createTexture();parameters.MAX_TEXTURE_SIZE=t.getParameter(t.MAX_TEXTURE_SIZE),t.bindTexture(t.TEXTURE_2D,a),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,1,1,0,t.RGBA,t.FLOAT,null),t.bindFramebuffer(t.FRAMEBUFFER,e),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,a,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;let r;try{t.readPixels(0,0,1,1,t.RGBA,t.FLOAT,new Float32Array(4)),r=t.getError()===t.NO_ERROR}catch(t){r=!1}return i&&r}const SOURCE_ENV={SUPPORTS_FLOAT_TEXTURES:testFloatTextures(),DEBUG:!1,MAX_TEXTURE_SIZE:parameters.MAX_TEXTURE_SIZE},ENV=Object.assign({},SOURCE_ENV);function main(t){let e="\nvoid main(void) {\n  vec2 coords = gl_FragCoord.xy - 0.5;\n  vec4 result = operation(coords.y, coords.x);\n\n  gl_FragColor = result;\n}\n  ";return ENV.SUPPORTS_FLOAT_TEXTURES||"float32"!==t.dtype||(e="\n    void main(void) {\n      vec2 coords = gl_FragCoord.xy;\n\n      highp float ox = floor(coords.x / 4.0);\n      float dx = floor(coords.x - ox * 4.0 + 0.5);\n    \n      vec4 result = operation(coords.y - 0.5, floor((coords.x - 0.5) / 4.0));\n\n      float value;\n\n      if (dx == 1.0) {\n        value = result.r;\n      } else if (dx == 2.0) {\n        value = result.g;\n      } else if (dx == 3.0) {\n        value = result.b;\n      } else if (dx == 4.0) {\n        value = result.a;\n      }\n    \n      gl_FragColor = encode_float(value);\n    }\n    "),e}var floatCode="/***@author twerdster from https:*/precision highp float;highp vec4 encode_float(highp float f){if(f==1./0.){return vec4(0.0,0.0,128.0,127.0)/255.0;}highp vec4 rgba;highp float e=5.0;highp float F=abs(f);highp float sign=step(0.0,-f);highp float exponent=floor(log2(F));highp float mantissa=(exp2(-exponent)*F);exponent=floor(log2(F)+127.0)+floor(log2(mantissa));rgba[0]=128.0*sign+floor(exponent*exp2(-1.0));rgba[1]=128.0*mod(exponent,2.0)+mod(floor(mantissa*64.0*2.0),128.0);rgba[2]=floor(mod(floor(mantissa*exp2(23.0-8.0)),exp2(8.0)));rgba[3]=floor(exp2(23.0)*mod(mantissa,exp2(-15.0)));return rgba.abgr/255.0;}float decode_float(highp vec4 rgba){rgba=rgba.abgr*255.0;highp float sign=1.0-step(128.0,rgba[0])*2.0;highp float exponent=2.0*mod(rgba[0],128.0)+step(128.0,rgba[1])-127.0;highp float mantissa=mod(rgba[1],128.0)*32768.0*2.0+rgba[2]*256.0+rgba[3]+float(0x800000);highp float result=sign*mantissa*exp2(-6.0)*exp2(exponent/4.0)*exp2(-7.0)*exp2(exponent/4.0)*exp2(-5.0)*exp2(exponent/4.0)*exp2(-5.0)*exp2(exponent/4.0);return result;}";function pick_value(t){const e=Object.keys(t.input),a=[];for(let i=0;i<e.length;i+=1){const r=e[i];if(!t.input[r].shape)continue;const n=[...t.input[r].shape],o=n[1].toFixed(1),s=n[0].toFixed(1),l=(4*n[1]).toFixed(1);let c=(t,e,a)=>`${t} ${e}_${r}(float y, float x) {\n\treturn texture2D(${r}, vec2((x + 0.5) / ${o}, (y + 0.5) / ${s}))${a};\n}`;ENV.SUPPORTS_FLOAT_TEXTURES||"float32"!==t.input[r].dtype||(c=((t,e,a)=>`\n        ${t} ${e}_${r}(float y, float x) {\n          float r = decode_float(texture2D(${r}, vec2((x * 4.0 + 0.5) / ${l}, y / ${s})));\n          float g = decode_float(texture2D(${r}, vec2((x * 4.0 + 1.5) / ${l}, y / ${s})));\n          float b = decode_float(texture2D(${r}, vec2((x * 4.0 + 2.5) / ${l}, y / ${s})));\n          float a = decode_float(texture2D(${r}, vec2((x * 4.0 + 3.5) / ${l}, y / ${s})));\n\n          return vec4(r, g, b, a)${a};\n        }\n      `)),a.push(c("vec4","pickValue","")),a.push(c("float","pickScalarValue",".x"))}return a.join("\n")}const float=()=>floatCode;var chunks=Object.freeze({main:main,pickValue:pick_value,float:float});function validType(t){return["bool","int","uint","float","double","vec2","vec3","vec4","mat2","mat3","mat4","sampler2D"].indexOf(t)>=0}function getType(t){let e=typeof t;t=String(t);const a=/^(vec\d|mat\d)\([^)]+\)$/.exec(t);return a?e=a[1]:/^\d+$/.exec(t)?e="int":/^\d+\.(\d+)?$/.exec(t)?e="float":"boolean"===e&&(e="bool"),e}function constructHeading(t){const e=Object.assign({},t.uniform),a=Object.keys(t.input);let i="precision highp float;\n";for(let t=0;t<a.length;t+=1){e[a[t]]={dtype:"sampler2D"}}const r=Object.keys(e);for(let t=0;t<r.length;t+=1){const a=r[t];if(!validType(e[a].dtype))throw new Error(`Uniform ${a} has invalid type "${e[a].dtype}"`);i+=`uniform ${e[a].dtype} ${a};\n`}i+="varying vec2 texCoords;\n";const n=Object.keys(t.constant);for(let e=0;e<n.length;e+=1){const a=n[e];let r=t.constant[a];"number"===typeof r&&r%1==0&&(r=r.toFixed(1));const o=getType(r);if(!validType(o))throw new Error(`Constant ${a}, has invalid type "${o}"`);i+=`#define ${a} ${r}\n`}return i}function injectChunks(t){const e=[];return ENV.SUPPORTS_FLOAT_TEXTURES||e.push("float"),e.concat(t.chunks.filter((t,e,a)=>a.indexOf(t)===e)).map(e=>{const a=` Chunk ${e} `,i=35-a.length,r=`${"-".repeat(Math.floor(i/2))}${a}${"-".repeat(Math.ceil(i/2))}`;if("function"==typeof chunks[e])return`/*${r}*/\n${chunks[e](t)}\n/*${"-".repeat(35)}*/`;throw new TypeError(`Chunk "${e}" is not a function`)}).join("\n")}function hasMain(t){return!!/void main\([\s\S]+\)([\s]+)?{/.exec(t)}function constructKernel(t){let e;if(hasMain(t.kernel))e=t.kernel;else{const a=constructHeading(t),i=injectChunks(t),r=main(t);e=[a,i,t.kernel,r].join("\n\n")}return ENV.DEBUG&&(console.groupCollapsed(t.name),console.log(prepareSourceLines(e).join("\n")),console.groupEnd()),e}const AVAILABLE_GLSL_CHUNKS=["pickCurrentValue","pickValue","float"],assert$$1=(t,e)=>{if(!t)throw new Error(e)},assertShapesAreEqual$$1=(t,e)=>{if(t.shape.length!==e.shape.length)return!1;for(let a=0;a<t.shape.length;a+=1)if(t.shape[a]!==e.shape[a])return!1;return!0},isValidShape$$1=t=>Array.isArray(t)&&t.length>0&&!t.some(t=>t%1!=0),isOperation$$1=t=>t instanceof Operation,isTensor$$1=t=>t instanceof Tensor,isValidGLSLChunk$$1=t=>AVAILABLE_GLSL_CHUNKS.includes(t),isValidGLSLVariableName$$1=t=>/^[A-Za-z](\w+)?$/.test(t),isValidOperationShape$$1=t=>t[0]>0&&t[1]>0;class DeprecationError$$1 extends Error{}function deprecationWarning$$1(t,e){console.warn(`GammaCV Deprecation Warning: "${t}" is deprecated${e?`, ${e}`:""}. "${t}" will be removed in next major version.`)}function deprecationError$$1(t,e){throw new DeprecationError$$1(`GammaCV Deprecation Error: "${t}" is deprecated${e?`, ${e}`:""}. "${t}" and was removed.`)}class Operation extends GraphNode{constructor(t){assert$$1(void 0!==t,"Operation: Operation shouldn't be unnamed."),super(t),this.dtype=null,this.input={},this.uniform={},this.constant={},this.chunks=[],this.inputKeys=[],this.isInitialized=!1,this.lastCtx=Math.random(),this.cache=!0}run(t,e,a){assert$$1(this.isInitialized,"Operation: Unable to run unilialized operation.");const i=this.gl,r=t.texture[this.name];if(e===this.lastCtx&&this.cache&&!a)return r.bind(this.program,!1,this.inputKeys.length),this.bindBuffer(),!1;this.lastCtx=e,i.useProgram(this.program);for(let e=0;e<this.inputKeys.length;e+=1){const a=this.inputKeys[e],i=this.input[a],r=i.name,n=t.texture[r];n.bind(this.program,a,e),isTensor$$1(i)&&n.set(i)}return r.bind(this.program,!1,this.inputKeys.length),this.bindBuffer(),i.viewport(0,0,("float32"===this.dtype?4:1)*this.shape[1],this.shape[0]),i.clearColor(0,0,0,1),i.clear(i.COLOR_BUFFER_BIT|i.DEPTH_BUFFER_BIT),i.drawElements(i.TRIANGLES,6,i.UNSIGNED_SHORT,0),!0}unbindBuffer(){const t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,null)}bindBuffer(){const t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,this.framebuffer)}init(t){if(!this.isInitialized){if(this.gl=t,this.program=t.createProgram(),this.framebuffer=t.createFramebuffer(),this.isInitialized)return!1;this.name=this.name,this.shape=this.shape,this.constant.OUT_VIEW=`vec2(${this.shape[1]}, ${this.shape[0]})`,this.kernel=constructKernel(this);try{this.vertexShader=this.getShader("vertex",vertexShader),t.attachShader(this.program,this.vertexShader),this.fragmentShader=this.getShader("fragment",this.kernel),t.attachShader(this.program,this.fragmentShader),t.linkProgram(this.program),t.useProgram(this.program)}catch(t){throw processError(this.kernel,this.name,t),new Error(`GPUProgram: Error during shader compilation.\n${t.message}`)}this.attributes={aVertexPosition:new GLBuffer(this.gl,this.program,"aVertexPosition","vec3"),aTextureCoords:new GLBuffer(this.gl,this.program,"aTextureCoords","vec2"),aIndices:new GLBuffer(this.gl,this.program,"aIndices","int")},this.attributes.aVertexPosition.set([1,1,0,-1,1,0,-1,-1,0,1,-1,0]),this.attributes.aTextureCoords.set([1,1,0,1,0,0,1,0]),this.attributes.aIndices.set([0,1,2,0,2,3]);const e=Object.keys(this.uniform);for(let t=0;t<e.length;t+=1){const a=this.uniform[e[t]];this.uniform[e[t]]=new GLUniform(this.gl,this.program,a.name,a.dtype),a.defaultValue&&this.uniform[e[t]].set(a.defaultValue)}this.isInitialized=!0}return!0}getShader(t,e){const a=this.gl;let i=null;if(i="fragment"===t?a.createShader(a.FRAGMENT_SHADER):a.createShader(a.VERTEX_SHADER),a.shaderSource(i,e),a.compileShader(i),!a.getShaderParameter(i,a.COMPILE_STATUS))throw new Error(`An error occurred compiling the shaders: ${a.getShaderInfoLog(i)}`);return i}traverse(t,e){const a=Object.keys(this.input);for(let i=0;i<a.length;i+=1){const r=a[i];this.input[r]instanceof Operation?this.input[r].traverse(t,e):t(this.input[r],e)}t(this,e)}getDependencies(){const t=[],e=Object.keys(this.input);for(let a=0;a<e.length;a+=1){const i=e[a];if(this.input[i]instanceof Operation){const e=this.input[i].getDependencies();for(let a=0;a<e.length;a+=1)-1===t.indexOf(e[a])&&t.push(e[a])}}return t.push(this.name),t}assignInput(t,e){this.input[t]=e,-1===this.inputKeys.indexOf(t)&&this.inputKeys.push(t)}cloneProp(t){const e=Object.keys(this[t]),a={};for(let i=0;i<e.length;i+=1){const r=e[i];a[r]=this[t][r]}return a}destroy(){this.program&&this.gl.deleteProgram(this.program),this.vertexShader&&this.gl.deleteShader(this.vertexShader),this.fragmentShader&&this.gl.deleteShader(this.fragmentShader),this.framebuffer&&this.gl.deleteFramebuffer(this.framebuffer)}clone(){const t=new Operation(this.name.split(":")[0]);return t.input=this.cloneProp("input"),t.uniform=this.cloneProp("uniform"),t.constant=this.cloneProp("constant"),t.dtype=this.dtype,t.kernel=this.kernel,t.chunks=this.chunks,t}}class GPUTexture{constructor(t,e,a,i){if("float32"!==t&&"uint8"!==t)throw new Error(`GPUTexture: Invalid texture type, currently supported is: float32, uint8, but got ${t} `);this.unit=a,this.dtype=t,this.gl=e,this.ctx=e.createTexture(),this.shape=i,e.bindTexture(e.TEXTURE_2D,this.ctx),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),this.allocate()}allocate(){const t=this.gl;let e=this.shape[1],a=t.UNSIGNED_BYTE;"float32"===this.dtype&&(ENV.SUPPORTS_FLOAT_TEXTURES?a=t.FLOAT:e*=4),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,e,this.shape[0],0,t.RGBA,a,null)}set(t=null){const e=this.gl;let a=t.shape[1],i=e.UNSIGNED_BYTE,r=t.data;"float32"===t.dtype&&(ENV.SUPPORTS_FLOAT_TEXTURES?i=e.FLOAT:(a*=4,r=t.uint8View)),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,a,this.shape[0],0,e.RGBA,i,r)}bind(t,e,a){const i=this.gl;if(e){const r=i.getUniformLocation(t,e);i.uniform1i(r,a)}i.activeTexture(i.TEXTURE0+a),i.bindTexture(i.TEXTURE_2D,this.ctx),this.unit=a}unbind(){const t=this.gl;t.activeTexture(t.TEXTURE0+this.unit),t.bindTexture(t.TEXTURE_2D,null)}delete(){const t=this.gl;t.deleteTexture(this.ctx),this.gl=null,this.program=null,this.ctx=null,t.bindTexture(t.TEXTURE_2D,null)}}function range(t){const e=new Array(t);for(let a=0;a<t;a+=1)e[a]=a;return e}function tensorFrom(t,e=!1){let a=null;return t instanceof Operation&&(a=new Tensor(e||t.dtype,t.shape)),t instanceof Tensor&&(a=new Tensor(e||t.dtype,t.shape)),a}function tensorClone(t,e){if(e.data.set)e.data.set(t.data);else for(let a=0;a<e.size;a+=1)e.data[a]=t.data[a]}function tensorInvert(input,output=input,invertShape=new Array(input.shape.length).fill(!0)){const shape=input.shape;if(input===output&&(input=input.clone()),input.shape.length!==output.shape.length)throw new Error("invertTensor: Unable to invert, input and output has different shapes");const tmpArr=new Array(shape.length);let invert=()=>{};eval(`invert = function (coords) { ${invertShape.map((t,e)=>t?`tmpArr[${e}] = shape[${e}] - 1 - coords[${e}]`:`tmpArr[${e}] = coords[${e}]`).join(";")}; return tmpArr; }`);for(let t=0;t<input.size;t+=1){const e=Tensor.IndexToCoord(shape,t),a=invert(e,tmpArr);output.set(...a,input.get(...e))}return output}const tensorAssertEqual=(t,e)=>{if(!assertShapesAreEqual$$1(t,e))return!1;for(let a=0;a<t.size;a+=1)if(t.data[a]!==e.data[a])return!1;return!0},tensorAssertCloseEqual=(t,e,a=1)=>{if(!assertShapesAreEqual$$1(t,e))return!1;for(let i=0;i<t.size;i+=1)if(Math.abs(t.data[i]-e.data[i])>a)return!1;return!0},tensorAssertMSEEqual=(t,e,a=1)=>{if(!assertShapesAreEqual$$1(t,e))return!1;let i=0;for(let a=0;a<t.size;a+=1)i+=(t.data[a]-e.data[a])**2;return(i=Math.sqrt(i)/t.size)<a};function flipTensor(input,output=input,invertShape=new Array(input.shape.length).fill(!0)){const shape=input.shape;if(input===output&&(input=input.clone()),input.shape.length!==output.shape.length)throw new Error("invertTensor: Unable to invert, input and output has different shapes");const tmpArr=new Array(shape.length);let invert=()=>{};eval(`invert = function (coords) { ${invertShape.map((t,e)=>t?`tmpArr[${e}] = shape[${e}] - 1 - coords[${e}]`:`tmpArr[${e}] = coords[${e}]`).join(";")}; return tmpArr; }`);for(let t=0;t<input.size;t+=1){const e=Tensor.IndexToCoord(shape,t),a=invert(e,tmpArr);output.set(...a,input.get(...e))}return output}function invertTensor(...t){return deprecationWarning$$1("invertTensor",'use "flipTensor" instead'),flipTensor(...t)}function tensorMap(t,e,a=t){for(let i=0;i<t.size;i+=1)a.data[i]=e(t.data[i],i)}function tensorOnes(t,e){const a=new Tensor(t,e);return tensorMap(a,()=>1),a}class Tensor extends GraphNode{constructor(t,e,a,i,r=0){super("Tensor"),this.dtype=t,this.shape=e||[a.length],assert$$1(isValidShape$$1(this.shape),"Shape is not valid"),i&&(assert$$1(isValidShape$$1(i),"Stride is not valid"),assert$$1(this.shape.length===i.length,"Stride length should be equal to shape length")),assert$$1("number"==typeof r&&r%1==0,`Offset should be integer, but got ${r}`),this.size=Tensor.GetSize(this.shape),this.stride=i||this._defineStride(this.shape),this.offset=r,this._compileJITMethods(),void 0===a?(this.data=Tensor.Malloc(t,this.size),this.empty=Tensor.Malloc(t,this.size)):this.assign(a),ENV.SUPPORTS_FLOAT_TEXTURES||"float32"!==t||(this.uint8View=new Uint8Array(this.data.buffer))}_compileJITMethods(){const t=range(this.shape.length),e=t.map(t=>`i${t}`).join(","),a=`${this.offset}+${t.map(t=>`${this.stride[t]}*i${t}`).join("+")}`;this.get=new Function(`return function get(${e}) { return this.data[${a}]; }`)(),this.set=new Function(`return function get(${e}, v) { this.data[${a}] = v; }`)(),this.index=new Function(`return function get(${e}, v) { return ${a}; }`)()}_defineStride(t){const e=t.length,a=new Array(e);for(let t=e-1,i=1;t>=0;t-=1)a[t]=i,i*=this.shape[t];return a}assign(t){const e=Tensor.DefineType(t),a=t.length;return assert$$1(e===this.dtype,`Different dtypes assigned: \n   expected - ${this.dtype} \n   actual - ${e}`),assert$$1(a===this.size+this.offset,`Different sizes assigned: \n   expected - ${this.size+this.offset} \n   actual - ${a}`),this.data=t,this}relese(){return this.empty?this.data.set(this.empty):this.data=Tensor.Malloc(this.dtype,this.size),this}clone(){const t=new Tensor(this.dtype,this.shape,void 0,this.stride,this.offset);return tensorClone(this,t),t}static IndexToCoord(t,e){const a=new Array(t.length);let i=e,r=t.reduce((t,e)=>t*e);for(let e=0;e<=t.length-2;e+=1){const n=~~(i/(r/=t[e]));i%=r,a[e]=n}return a[a.length-1]=i%t[t.length-1],a}static CoordToIndex(t,e){let a=1,i=0;for(let r=t.length-1;r>=0;r-=1)i+=a*e[r],a*=t[r];return i}static Malloc(t,e){switch(t){case"uint8":return new Uint8Array(e);case"uint16":return new Uint16Array(e);case"uint32":return new Uint32Array(e);case"int8":return new Int8Array(e);case"int16":return new Int16Array(e);case"int32":return new Int32Array(e);case"float32":return new Float32Array(e);case"float64":return new Float64Array(e);case"uint8c":return new Uint8ClampedArray(e);case"array":return new Array(e);default:throw new Error(`Unexpected type: ${t}.`)}}static DefineType(t){const e=Object.prototype.toString.call(t);switch(e){case"[object Uint8Array]":return"uint8";case"[object Uint16Array]":return"uint16";case"[object Uint32Array]":return"uint32";case"[object Int8Array]":return"int8";case"[object Int16Array]":return"int16";case"[object Int32Array]":return"int32";case"[object Float32Array]":return"float32";case"[object Float64Array]":return"float64";case"[object Uint8ClampedArray]":return"uint8c";case"[object Array]":return"array";default:throw new Error(`Unknown dtype: ${e}.`)}}static GetTypedArray(t,e){if(t===Tensor.DefineType(e))return e;switch(t){case"uint8":return new Uint8Array(e);case"uint16":return new Uint16Array(e);case"uint32":return new Uint32Array(e);case"int8":return new Int8Array(e);case"int16":return new Int16Array(e);case"int32":return new Int32Array(e);case"float32":return new Float32Array(e);case"float64":return new Float64Array(e);case"uint8c":return new Uint8ClampedArray(e);case"array":return new Array(e);default:throw new Error(`Unknown type: ${t}.`)}}static GetSize(t){return t.reduce((t,e)=>t*e,1)}}class Session{constructor(){this.canvas=document.createElement("canvas"),this.canvas.width=1,this.canvas.height=1,this.initWebGL(this.canvas),this.operation={},this.texture={},this.textureCount=0}initWebGL(t,e){this.canvas=t;const a=this.canvas.getContext("webgl",e),i=a.getExtension("OES_texture_float");assert$$1(!!a,"WebGL not supported."),assert$$1(!!i,"Unable to find extension OES_texture_float"),a.clear(a.COLOR_BUFFER_BIT|a.DEPTH_BUFFER_BIT),this.gl=a}init(t){assert$$1(!!t,"Session: Unable to initialize undefined operation"),assert$$1(isOperation$$1(t)||isTensor$$1(t),"Session: Unable to initialize operation with invalid input type"),isOperation$$1(t)&&t.traverse((t,e)=>{e.operation[t.name]=t},this),isTensor$$1(t)&&(this.operation[t.name]=t),this.update()}update(){const t=this.gl,e=Object.keys(this.operation);for(let a=0;a<e.length;a+=1){const i=this.operation[e[a]];i instanceof Operation&&i.init(this.gl),this.texture[e[a]]||(this.texture[e[a]]=new GPUTexture(i.dtype,this.gl,this.textureCount,i.shape),i instanceof Operation&&(t.bindFramebuffer(t.FRAMEBUFFER,i.framebuffer),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,this.texture[e[a]].ctx,0),t.bindFramebuffer(t.FRAMEBUFFER,null)),this.textureCount+=1)}}runOp(t,e,a=!1){const i=t.sequence;let r=!1;for(let t=0;t<i.length;t+=1){const n=i[t],o=this.operation[n],s=t===i.length-1;r=!!o.run(this,e,r),a&&a instanceof Tensor&&s&&this.readToTensor(a)}}destroy(){const t=this.gl.getExtension("WEBGL_lose_context"),e=Object.keys(this.texture),a=Object.keys(this.operation);t&&t.loseContext();for(let t=0;t<e.length;t+=1)this.texture[e[t]].delete();for(let t=0;t<a.length;t+=1){const e=this.operation[a[t]];e instanceof Operation&&e.destroy()}this.canvas=null,this.operation={},this.texture={},this.gl=null,this.textureCount=0}readToTensor(t){const e=this.gl;let a=t.shape[1],i=e.UNSIGNED_BYTE,r=t.data;"float32"===t.dtype&&(ENV.SUPPORTS_FLOAT_TEXTURES?i=e.FLOAT:(a*=4,r=t.uint8View)),e.readPixels(0,0,a,t.shape[0],e.RGBA,i,r)}}class RegisterOperation{constructor(t){this.op=new Operation(t),this.name=t,this.checkShape=(t=>{return t[Object.keys(t)[0]]}),this.preCompile=(()=>{}),this.postCompile=(()=>{}),this.chunks=[]}GLSLKernel(t){return assert$$1("string"==typeof t,"RegisterOperation: The kernel should be a string but it is not."),this.op.kernel=t,this}LoadChunk(...t){for(const e of t)assert$$1(isValidGLSLChunk$$1(e),`There is no available GLSL chunk supported: ${e}`);return this.op.chunks=this.op.chunks.concat(t),this}Input(t,e){return assert$$1(isValidGLSLVariableName$$1(t)),this.op.input[t]={name:t,dtype:e},this}Output(t){return assert$$1(null===this.op.dtype,"RegisterOperation: The operation allows a single output."),this.op.dtype=t,this}Constant(t,e){return assert$$1(isValidGLSLVariableName$$1(t)),this.op.constant[t]=e,this}SetShapeFn(t){return assert$$1("function"==typeof t,"SetShapeFn should receive function in first argument"),this.checkShape=t,this}PreCompile(t){return assert$$1("function"==typeof t,"PreCompile should receive function in first argument"),this.preCompile=t,this}PostCompile(t){return assert$$1("function"==typeof t,"PostCompile should receive function in first argument"),this.postCompile=t,this}Uniform(t,e,a){return assert$$1(isValidGLSLVariableName$$1(t)),this.op.uniform[t]={name:t,dtype:e,defaultValue:a},this}Compile(t){const e=this.op.clone(),a={},i=Object.keys(t);this.preCompile(e);for(let r=0;r<i.length;r+=1){const n=i[r],o=t[n];assert$$1(!!o,`RegisterOperation:${e.name}.${n}:\n         Can't compile operation with undefined input.`),assert$$1(isTensor$$1(o)||isOperation$$1(o),`RegisterOperation:${e.name}.${n}:\n         Can't compile operation with invalid input type.\n         You can only use Tensor or another Operation to be an input`),a[n]=t[n].shape,e.assignInput(n,t[n])}return e.shape=this.checkShape(a),e.sequence=e.getDependencies(),e}}function initDrawable(t,e,a){let i=!1;return t.onmousedown=(()=>{i=!0}),t.onmouseup=(()=>{i=!1}),t.onmousemove=(t=>{i&&(e.set(t.offsetY,t.offsetX,255),a&&a())}),()=>{t.onmousedown=null,t.onmouseup=null,t.onmousemove=null}}function initMouseTracking(t,e){return t.onmousemove=(t=>e(t.offsetX,t.offsetY)),()=>{t.onmousemove=null}}function toImageData(t,e=!1,a=!1){const i=new ImageData(t.shape[1],t.shape[0]),r=t.shape[0]*t.shape[1];if(e&&"uint8"===t.dtype)return i.data.set(t.data),i;if(!e){for(let e=0;e<r;e+=1){const r=~~(e/t.shape[0]),n=e-r*t.shape[1],o=t.data[e];let s=0;s=a?4*(n*t.shape[0]+r):4*(r*t.shape[1]+n),i.data[s+0]=o,i.data[s+1]=o,i.data[s+2]=o,i.data[s+3]=255}return i}if("float32"===t.dtype)for(let e=0;e<t.size;e+=1)i.data[e]=255*t.data[e];else for(let e=0;e<t.size;e+=1)i.data[e]=t.data[e];return i}function getImageData(t,e=0,a=0,i=t.width,r=t.height){return t.getContext("2d").getImageData(e,a,i,r)}function putImageData(t,e,a=0,i=0,r=0,n=0,o=e.width,s=e.height,l){return(e.width!==t.width||e.height!==t.height||l)&&t.getContext("2d").clearRect(0,0,t.width,t.height),t.getContext("2d").putImageData(e,a,i,r,n,o,s)}function canvasFromTensor(t,e,a=!1,i=!1){if(!(e instanceof Tensor))throw Error("tensorToCanvas: Input tensor invalid");e.shape[2]&&4===e.shape[2]&&(a=!0);const r=toImageData(e,a,i);t.getContext("2d").putImageData(r,0,0)}function canvasToTensor(t,e){const a=t.getContext("2d").getImageData(0,0,e.shape[1],e.shape[0]);if(e)switch(e.dtype){case"uint8":e.assign(new Uint8Array(a.data));break;case"uint8c":e.assign(a.data);break;case"float32":default:e.assign(new Float32Array(a.data))}}const canvasDrawLine=(t,e,a="rgba(255, 0, 0, 0.5)",i=1)=>{const r=t.getContext("2d");r.beginPath(),Array.isArray(e)?(r.moveTo(e[0],e[1]),r.lineTo(e[2],e[3])):(r.moveTo(e.data[0],e.data[1]),r.lineTo(e.data[2],e.data[3])),r.strokeStyle=a,r.lineWidth=i,r.stroke(),r.closePath()},canvasDrawCircle=(t,e,a=5,i="#ff0000")=>{const r=t.getContext("2d");r.beginPath(),r.arc(e[0],e[1],a,0,2*Math.PI),r.strokeStyle=i,r.stroke()},canvasFillCircle=(t,e,a,i="#ff0000")=>{const r=t.getContext("2d");r.beginPath(),r.arc(e[0],e[1],a,0,2*Math.PI),r.fillStyle=i,r.fill()},clearCanvas=t=>{t.getContext("2d").clearRect(0,0,t.width,t.height)},canvasDrawRect=(t,e,a="rgba(255, 0, 0, 1)",i=1,r=!1,n=!1)=>{const o=t.getContext("2d");o.beginPath(),o.moveTo(e.ax,e.ay),o.lineTo(e.bx,e.by),o.lineTo(e.cx,e.cy),o.lineTo(e.dx,e.dy),o.lineTo(e.ax,e.ay),r&&(o.lineTo(e.ax,e.ay),o.lineTo(e.cx,e.cy),o.lineTo(e.bx,e.by),o.lineTo(e.dx,e.dy),o.lineTo(e.ax,e.ay)),o.strokeStyle=a,n&&(o.fillStyle=a,o.fill()),o.stroke(),o.lineWidth=i,o.closePath()};function canvasFill(t,e){const a=t.getContext("2d");a.fillStyle=e,a.fillRect(0,0,t.width,t.height)}const canvasClear=t=>{t.width=t.width,t.height=t.height},canvasInit=(t,e,a)=>{const i=document.querySelector(t);return i.width=e,i.height=a,i},canvasCreate=(t,e)=>{const a=document.createElement("canvas");return a.width=t,a.height=e,a};function imageTensorFromURL(t,e="uint8",a,i=!1){return new Promise((r,n)=>{const o=document.createElement("img"),s=document.createElement("canvas"),l=s.getContext("2d");let c,h;o.src=t,i&&(o.crossOrigin="Anonimus"),o.onload=(()=>{let t;a?(c=a[1],h=a[0]):(c=o.width,h=o.height),s.width=c,s.height=h,l.drawImage(o,0,0,c,h);const i=l.getImageData(0,0,c,h);switch(e){case"uint8":t=new Uint8Array(i.data.buffer);break;case"float32":t=new Float32Array(i.data);break;default:t=i.data}const n=new Tensor(e,[h,c,4],t);r(n)}),o.onerror=n})}function getWidth(t,e){return t*e}function getHeight(t,e){return e/t}function getMaxAvailableSize(t,e,a){if(e){const i=getHeight(t,e);if(i<=a)return{width:e,height:i}}return{width:getWidth(t,a),height:a}}function getMinAvailableSize(t,e,a){if(e){const i=getHeight(t,e);if(i>a)return{width:e,height:i}}return{width:getWidth(t,a),height:a}}class CaptureVideo{static IsAvailable(){const t={video:{width:{min:480,ideal:1080,max:1920},height:{min:480,ideal:1080,max:1920}}};navigator.getUserMedia=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia||navigator.oGetUserMedia;const e=navigator.userAgent;-1!==e.indexOf("Safari")&&-1===e.indexOf("Chrome")&&(delete t.video.width,delete t.video.height);let a=Promise.resolve();return navigator.mediaDevices&&navigator.mediaDevices.getUserMedia?a=a.then(()=>navigator.mediaDevices.getUserMedia(t)):navigator.getUserMedia&&(a=a.then(()=>new Promise(e=>navigator.getUserMedia(t,e)))),a.then(t=>{const e=t.getTracks(),a=e[0].getSettings().deviceId;return e.forEach(t=>t.stop()),a||!0}).catch(()=>Promise.resolve(!1))}static getDevices(){return"mediaDevices"in navigator&&"enumerateDevices"in navigator.mediaDevices?navigator.mediaDevices.enumerateDevices().then(t=>t.filter(t=>"videoinput"===t.kind)):Promise.resolve(null)}constructor(t,e){this.video=document.createElement("video"),this.video.muted=!0,this.video.playsInline=!0,this.canvas=document.createElement("canvas"),this.canvasCtx=this.canvas.getContext("2d"),this.sourceCanvas=document.createElement("canvas"),this.sourceCanvasCtx=this.sourceCanvas.getContext("2d"),this.width=t,this.height=e,this.sourceWidth=t,this.sourceHeight=e,this.setSize(t,e),this.track=null}setSize(t,e){this.width=t,this.height=e,this.canvas.width=t,this.canvas.height=e,this.sourceCanvas.width=t,this.sourceCanvas.height=e,this.sourceMinWidth=t,this.sourceMinHeight=e}setSourceSize(t,e){const a=getMinAvailableSize(t/e,this.width,this.height),i=getMaxAvailableSize(this.width/this.height,t,e),r=getMinAvailableSize(t/e,i.width,i.height);this.sourceMinWidth=a.width,this.sourceMinHeight=a.height,this.sourceWidth=r.width,this.sourceHeight=r.height,this.sourceCanvas.width=i.width,this.sourceCanvas.height=i.height}getDevice(){return this.track?this.track.getSettings().deviceId:null}start(t,e=""){this.started=!0;const a={video:{width:{min:240,ideal:1080,max:1920},height:{min:240,ideal:1080,max:1920},aspectRatio:{exact:this.width/this.height},deviceId:t?{ideal:t}:void 0,facingMode:e?{exact:e}:null}},i=navigator.userAgent;-1!==i.indexOf("Safari")&&-1===i.indexOf("Chrome")&&(delete a.video.width,delete a.video.height,delete a.video.aspectRatio),navigator.getUserMedia=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia||navigator.oGetUserMedia;let r=Promise.resolve();return navigator.mediaDevices&&navigator.mediaDevices.getUserMedia?r=r.then(()=>navigator.mediaDevices.getUserMedia(a)):navigator.getUserMedia&&(r=r.then(()=>new Promise(t=>navigator.getUserMedia(a,t)))),r.then(t=>{if(t){const e=t.getTracks();return this.started?("srcObject"in this.video?this.video.srcObject=t:this.video.src=window.URL.createObjectURL(t),this.track=e[0],this.video.play().then(()=>this.setSourceSize(this.video.videoWidth,this.video.videoHeight))):(e.forEach(t=>t.stop()),null)}throw new Error("getUserMedia not found or no stream was created")})}stop(){this.started=!1,this.track&&(this.track.stop(),this.track=null)}drawImage(t,e,a,i,r){t.drawImage(this.video,(i-e)/-2,(r-a)/-2,i,r)}getImageBuffer(t,e=this.canvasCtx,a=this.width,i=this.height,r=0,n=0,o=a,s=i,l=this.sourceMinWidth,c=this.sourceMinHeight){this.drawImage(e,o,s,l,c);const h=e.getImageData(r,n,o,s);if(t instanceof Tensor)return t.data.set(h.data),t;switch(t){case"uint8":return new Uint8Array(h.data);case"uint8c":return h.data;case"float32":return new Float32Array(h.data);default:return h}}getImageBufferTo(t,e=this.canvasCtx,a=this.width,i=this.height,r=0,n=0,o=a,s=i,l){e.drawImage(this.video,(this.sourceWidth-this.width)/-2,(this.sourceHeight-this.height)/-2,this.sourceWidth,this.sourceHeight);const c=e.getImageData(r,n,o,s);l.data=c.data.buffer}getSourceImageBuffer(t,e,a,i,r){return this.getImageBuffer(t,this.sourceCanvasCtx,this.sourceCanvas.width,this.sourceCanvas.height,e,a,i,r,this.sourceWidth,this.sourceHeight)}}var kernel="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/const vec3 k=vec3(0.2128,0.7148,0.0724);vec4 operation(float y,float x){float value=dot(pickValue_tSrc(y,x).rgb,k);return vec4(value,value,value,1.0);}",index=t=>new RegisterOperation("Grayscale").Input("tSrc","uint8").Output("uint8").LoadChunk("pickValue").GLSLKernel(kernel).Compile({tSrc:t}),kernel$1="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float y,float x){const int mSize=int(KERNEL_SIZE);const int kSize=(mSize-1)/2;vec3 finalColour=vec3(0.0);for(int i=-kSize;i<=kSize;i+=1){for(int j=-kSize;j<=kSize;j+=1){float k=pickValue_tKernel(float(i+kSize),float(j+kSize)).a;finalColour+=pickValue_tSrc(y+float(i),x+float(j)).rgb*k;}}return vec4(finalColour,1.0);}",index$1=(t,e=3,a=3)=>(assert$$1(e>=3,"Kernel size should be greater equal 3"),assert$$1(a>0,"Sigma should be greater then 0"),new RegisterOperation("GaussianBlur").Input("tSrc",t.dtype).Input("tKernel","float32").Output(t.dtype).LoadChunk("pickValue").Uniform("uWidth","float",t.shape[0]).Uniform("uHeight","float",t.shape[1]).Constant("KERNEL_SIZE",e).PreCompile(t=>{const i=new Tensor("float32",[e,e]),r=e/2,n=new Tensor("float32",[e,e,4]);let o=0;for(let t=0;t<e;t+=1)for(let n=0;n<e;n+=1){const e=Math.exp(-.5*(((t-r)/a)**2+((n-r)/a)**2))/(2*Math.PI*a*a);i.set(t,n,e),o+=i.get(t,n)}for(let t=0;t<e;t+=1)for(let a=0;a<e;a+=1)n.set(t,a,3,i.get(t,a)/o);t.assignInput("tKernel",n)}).GLSLKernel(kernel$1).Compile({tSrc:t})),kernel$2="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float y,float x){float value=0.0;for(float dx=0.0;dx<K;dx+=1.0){for(float dy=0.0;dy<K;dy+=1.0){float v=pickValue_tSrc((y*K)-dy,(x*K)-dx).r;if(S==0.0){if(v>0.0){value=v;}}if(S==1.0){value+=v;}}}if(S==1.0){value/=K*K;}return vec4(value,value,value,1.0);}",index$2=(t,e=2,a="mean")=>{assert$$1("mean"===a||"max"===a,"DownsampleOp: Unsupported type of operation. Currently sup");let i=0;return"max"===a?i=0:"mean"===a&&(i=1),new RegisterOperation("Downsample").Input("tSrc","uint8").Output("uint8").Constant("K",e).Constant("S",i).SetShapeFn(()=>{const a=[~~(t.shape[0]/e),~~(t.shape[1]/e),4];return assert$$1(isValidOperationShape$$1(a),"DownsampleOperation: Invalid operation shape"),a}).LoadChunk("pickValue").GLSLKernel(kernel$2).Compile({tSrc:t})},kernel$3="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float y,float x){float wk=1.0;float hk=1.0;float dx=0.0;float dy=0.0;/*-1 0+1-2 0+2-1 0+1*/dx+=-1.0*pickScalarValue_tSrc(y-hk,x-wk);dx+=-2.0*pickScalarValue_tSrc(y,x-wk);dx+=-1.0*pickScalarValue_tSrc(y+wk,x-wk);dx+=+1.0*pickScalarValue_tSrc(y-wk,x+wk);dx+=+2.0*pickScalarValue_tSrc(y,x+wk);dx+=+1.0*pickScalarValue_tSrc(y+wk,x+wk);/*-1-2-10 0  0+1+2+1*/dy+=-1.0*pickScalarValue_tSrc(y-wk,x-wk);dy+=-2.0*pickScalarValue_tSrc(y-wk,x);dy+=-1.0*pickScalarValue_tSrc(y-wk,x+wk);dy+=+1.0*pickScalarValue_tSrc(y+wk,x-wk);dy+=+2.0*pickScalarValue_tSrc(y+wk,x);dy+=+1.0*pickScalarValue_tSrc(y+wk,x+wk);float magniture=sqrt((dx*dx)+(dy*dy));float theta=atan(dy/dx);return vec4(magniture,dx,dy,theta);}",index$3=t=>new RegisterOperation("SobelOperator").Input("tSrc",t.dtype).Output("float32").Uniform("uWidth","float",t.shape[0]).Uniform("uHeight","float",t.shape[1]).Constant("PI",Math.PI).GLSLKernel(kernel$3).LoadChunk("pickValue").Compile({tSrc:t}),dirrectionKernel="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float y,float x){float dx=pickValue_tSrc(y,x+1.0).r-pickValue_tSrc(y,x-1.0).r;float dy=pickValue_tSrc(y+1.0,x).r-pickValue_tSrc(y-1.0,x).r;float magniture=sqrt((dx*dx)+(dy*dy));return vec4(magniture,atan(dy/dx),dx,dy);}",groupKernel="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/float A=180.0/9.0;float S=3.0;vec4 operation(float y,float x){float my=y-(S*floor(y/S));float mx=x-(S*floor(x/S));x=x/S;y=y/S;float index=mx+(my*S);float sum=0.0;for(float dx=0.0;dx<K;dx+=1.0){for(float dy=0.0;dy<K;dy+=1.0){vec4 v=pickValue_tSrc(((y*K)+dy),((x*K)+dx));float theta=abs(PI/2.0-v.g);float deg=theta*(180.0/PI);float i=floor(deg/A);if(i==index){sum+=v.r;}}}float rad=(index/9.0*PI);return vec4(sum,rad,0.0,0.0);}",groupMaxKernel="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/const int w=int(W);const int h=int(H);const int k=int(K);const float S=3.0;float A=180.0/9.0;vec4 getPixel(float y,float x){float x1=x/float(w);float y1=y/float(h);return pickValue_tSrc(floor(y1*uSrcHeight),floor(x1*uSrcWidth));}vec4 getPixel(float y,float x,float xOffset,float yOffset){float x1=x/float(w);float y1=y/float(h);return pickValue_tSrc(floor(y1*uSrcHeight)+yOffset,floor(x1*uSrcWidth)+xOffset);}vec4 operation(float y,float x){float x1=x/W;float y1=y/H;float res=0.0;float tmpx=x/S;float tmpy=y/S;float sum[9];int count=0;vec4 value=getPixel(y,x);for(int _x=0;_x<k;_x+=1){for(int _y=0;_y<k;_y+=1){vec4 v=getPixel(y,x,float(_y),float(_x));float theta=abs(PI/2.0-v.g);float deg=theta*(180.0/PI);int i=int(floor(deg/A));if(i==1){sum[1]+=v.r;}if(i==2){sum[2]+=v.r;}if(i==3){sum[3]+=v.r;}if(i==4){sum[4]+=v.r;}if(i==5){sum[5]+=v.r;}if(i==6){sum[6]+=v.r;}if(i==7){sum[7]+=v.r;}if(i==8){sum[8]+=v.r;}}}int maxI=0;float maxV=0.0;for(int i=0;i<9;i++){if(maxV<sum[i]){maxI=i;maxV=sum[i];}}return vec4(maxI,maxV,0.0,0.0);}";const hogDirrection=t=>new RegisterOperation("HOGDirection").Input("tSrc","uint8").Output("float32").Uniform("uWidth","float",t.shape[1]).Uniform("uHeight","float",t.shape[0]).LoadChunk("pickValue").GLSLKernel(dirrectionKernel).Compile({tSrc:t}),hogGroup=(t,e)=>new RegisterOperation("HOG").Input("tSrc","uint8").Output("float32").Uniform("uSrcWidth","float",t.shape[1]).Uniform("uSrcHeight","float",t.shape[0]).Uniform("uWidth","float",3*~~(t.shape[1]/e)).Uniform("uHeight","float",3*~~(t.shape[0]/e)).Constant("PI",Math.PI).Constant("W",~~(t.shape[1]/e)).Constant("H",~~(t.shape[0]/e)).Constant("K",e).LoadChunk("pickValue").SetShapeFn(()=>[3*~~(t.shape[0]/e),3*~~(t.shape[1]/e),4]).GLSLKernel(groupKernel).Compile({tSrc:t}),hogGroupMax=(t,e)=>new RegisterOperation("HOGMax").Input("tSrc","uint8").Output("float32").Uniform("uSrcWidth","float",t.shape[1]).Uniform("uSrcHeight","float",t.shape[0]).Uniform("uWidth","float",~~(t.shape[1]/e)).Uniform("uHeight","float",~~(t.shape[0]/e)).Constant("PI",Math.PI).Constant("W",~~(t.shape[1]/e)).Constant("H",~~(t.shape[0]/e)).Constant("K",e).LoadChunk("pickValue").SetShapeFn(()=>[~~(t.shape[0]/e),~~(t.shape[1]/e),4]).GLSLKernel(groupMaxKernel).Compile({tSrc:t});var index$4=(t,e=10,a="max")=>{assert$$1("max"===a||"visualize"===a,"Unsupported type of HOG operation.\n     Currently availiable max and visualize.");let i=null;return"max"===a&&(i=hogGroupMax(hogDirrection(t),e)),"visualize"===a&&(i=hogGroup(hogDirrection(t),e)),i},kernel$4="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float y,float x){return pickValue_tSrc(y,x);}",index$5=(t,e=t.dtype)=>new RegisterOperation("Cast").Input("tSrc",t.dtype).Output(e).LoadChunk("pickValue").GLSLKernel(kernel$4).Compile({tSrc:t}),nmsKernel="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/\n#define STROKE uSize\nvec4 operation(float y,float x){vec4 M=pickValue_tSrc(y,x);float N=pickValue_tSrc(y+STROKE,x).r;float S=pickValue_tSrc(y-STROKE,x).r;float W=pickValue_tSrc(y,x-STROKE).r;float E=pickValue_tSrc(y,x+STROKE).r;float SE=pickValue_tSrc(y-STROKE,x+STROKE).r;float NW=pickValue_tSrc(y+STROKE,x-STROKE).r;float NE=pickValue_tSrc(y+STROKE,x+STROKE).r;float SW=pickValue_tSrc(y-STROKE,x-STROKE).r;float H=0.0;float V=M.r;float dx=M.g;float dy=M.b;float theta=atan(dy/dx);float deg=theta*(180.0/PI);float angle=0.0;if(deg<0.0){deg=180.0+deg;}if(deg<22.5||deg>=157.5){if(V>W&&V>E){H+=1.0;}}if(deg<67.5&&deg>=22.5){if(V>SW&&V>NE){H+=1.0;}}if(deg<112.5&&deg>=67.5){if(V>N&&V>S){H+=1.0;}}if(deg<157.5&&deg>=112.5){if(V>NW&&V>SE){H+=1.0;}}if(H==1.0){return vec4(V,V,V,255);}else{return vec4(0,0,0,255);}}",hysteresisKernel="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/\n#define STROKE uSize\nvec4 operation(float y,float x){vec4 M=pickValue_tSrc(y,x);float N=pickValue_tSrc(y+STROKE,x).r;float S=pickValue_tSrc(y-STROKE,x).r;float W=pickValue_tSrc(y,x-STROKE).r;float E=pickValue_tSrc(y,x+STROKE).r;float SE=pickValue_tSrc(y-STROKE,x+STROKE).r;float NW=pickValue_tSrc(y+STROKE,x-STROKE).r;float NE=pickValue_tSrc(y+STROKE,x+STROKE).r;float SW=pickValue_tSrc(y-STROKE,x-STROKE).r;float V=M.r;float H=0.0;if(V>uThresholdHigh){H+=1.0;}if(V>uThresholdLow&&V<uThresholdHigh){if(N>0.0||S>0.0||W>0.0||E>0.0||SE>0.0||NW>0.0||NE>0.0||SW>0.0){H+=1.0;}}if(H==1.0){return vec4(255,255,255,255);}else{return vec4(0,0,0,255);}}";const CannyNMS=t=>new RegisterOperation("ImageCannyEdgesNMS").Input("tSrc",t.dtype).Output(t.dtype).LoadChunk("pickValue").Uniform("uSize","float",1).Constant("PI",Math.PI).GLSLKernel(nmsKernel).Compile({tSrc:t}),CannyHysteresis=(t,e,a)=>(assert$$1(e>=0,"Canny low threshold should be greater equal 0"),assert$$1(a<=1,"Canny high threshold should be less equal 1"),new RegisterOperation("ImageCannyEdgesHysteresis").Input("tSrc",t.dtype).Output(t.dtype).LoadChunk("pickValue").Uniform("uSize","float",1).Uniform("uThresholdLow","float",e).Uniform("uThresholdHigh","float",a).GLSLKernel(hysteresisKernel).Compile({tSrc:t}));var index$6=(t,e=.25,a=.75)=>CannyHysteresis(CannyNMS(t),e,a),kernel$5="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/const float _step=1.0/CLUSTERS;vec4 operation(float y,float x){float minDistance=256.0;float label=0.0;vec3 value=pickValue_tSrc(y,x).rgb;for(int i=0;i<int(CLUSTERS);i+=1){vec3 curr=pickValue_tCentroids(float(i),0.0).rgb;float distance=sqrt(((value.r-curr.r)*(value.r-curr.r)));if(distance<minDistance){minDistance=distance;label=float(i)/CLUSTERS;}}return vec4(label,label,label,1.0);}",index$7=(t,e=3)=>(assert$$1("uint8"===t.dtype,"Color Segmentation currently available for uint8 image input"),assert$$1(e>1,"Number of clusters should be greater than 1"),new RegisterOperation("ImageColorSegmentation").Input("tSrc","uint8").Input("tCentroids","uint8").Output("uint8").LoadChunk("pickValue").Constant("CLUSTERS",e).GLSLKernel(kernel$5).PreCompile(t=>{const a=~~(256/e);t.centroids=new Tensor("uint8",[e,1,4]);for(let i=0;i<e;i+=1)t.centroids.set(i,0,0,i*a);t.assignInput("tCentroids",t.centroids)}).Compile({tSrc:t}));function parallelReductionCheckSteps(t=1,e=[1]){let a=t;for(let t=0;t<e.length;t+=1)a/=e[t];return 1===a}function parallelReductionCheckSteps2d(t=[1,1],e=[[1,1]]){return parallelReductionCheckSteps(t[0],e.map(t=>t[0]))&&parallelReductionCheckSteps(t[0],e.map(t=>t[1]))}function parallelReductionGetSteps(t=1,e=1,a=!0,i=t){const r=t**(1/e);if(t%1!=0)throw new RangeError(`Can't get parallel reduction steps for non-integer, got "${t}"`);if(i<1)throw new RangeError(`Can't get parallel reduction steps for maxLayerSize below less than 1, got "${i}"`);if(r%1==0&&r<i)return new Array(e).fill(r);const n=[];let o=t,s=r;for(let t=0;t<e;t+=1){s=o**(1/(e-t));let r=Math.ceil(s);for(;(o%r!=0||o/r>i)&&o/r!=1;)4===i&&console.log(r,o/r,i),r+=1;if(1===r&&a)break;o/=r,4===i&&console.log(r,n),n.push(r)}return n}function parallelReductionGetSteps2d(t=[1,1],e=1,a=!0,i=t){const r=parallelReductionGetSteps(t[0],e,a,i[0]),n=parallelReductionGetSteps(t[1],e,a,i[1]),o=[];for(let t=0;t<e&&(r[t]||n[t]);t+=1)o.push([r[t]||1,n[t]||1]);return o}function clacConvolution(t,e,a=1){return Math.ceil((t-e+1)/a)}var getMean="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/const int kx=int(KX);const int ky=int(KY);const int w=int(WIDTH);const int h=int(HEIGHT);vec4 operation(float gly,float glx){float size=KY*KX;float mean=0.0;float std=0.0;vec3 color=vec3(0.0,0.0,0.0);for(int y=0;y<ky;y+=1){for(int x=0;x<kx;x+=1){vec3 value=pickValue_tSrc(gly*KY+float(y),glx*KX+float(x)).rgb;color+=value.rgb;}}color/=size;mean=color.r;for(int y=0;y<ky;y+=1){for(int x=0;x<kx;x+=1){vec3 value=pickValue_tSrc(gly*KY+float(y),glx*KX+float(x)).rgb;std+=(value.r-mean)*(value.r-mean);}}std/=size;std=sqrt(std);if(std==0.0){std=1.0;}return vec4(color,255.0);}",getStd="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/const int kx=int(KX);const int ky=int(KY);const int w=int(WIDTH);const int h=int(HEIGHT);vec4 operation(float gly,float glx){float size=KX*KY;vec3 std=vec3(0.0,0.0,0.0);vec3 mean=pickValue_tMean(0.0,0.0).rgb;for(int y=0;y<ky;y+=1){for(int x=0;x<kx;x+=1){vec3 value=pickValue_tSrc(gly*KY+float(y),glx*KX+float(x)).rgb;std+=(value-mean)*(value-mean);}}std/=size;std=sqrt(std);if(std.r==0.0){std.r=255.0;}if(std.g==0.0){std.g=255.0;}if(std.b==0.0){std.b=255.0;}return vec4(std,255.0);}",reduceStd="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/const int kx=int(KX);const int ky=int(KY);const int w=int(WIDTH);const int h=int(HEIGHT);vec4 operation(float gly,float glx){float size=KX*KY;vec3 std=vec3(0.0,0.0,0.0);for(int y=0;y<ky;y+=1){for(int x=0;x<kx;x+=1){vec3 mstd=pickValue_tStd(gly*KY+float(y),glx*KX+float(x)).rgb;std+=mstd*mstd;}}std/=size;std=sqrt(std);if(std.r==0.0){std.r=255.0;}if(std.g==0.0){std.g=255.0;}if(std.b==0.0){std.b=255.0;}return vec4(std,255.0);}",joinKernel="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float gly,float glx){if(gly==0.0){return texture2D(tMean,vec2(0,0));}else{return texture2D(tStd,vec2(0,0));}}";const ImageReduceStd=(t,e)=>new RegisterOperation("ImageReduceStd").Input("tStd",t.dtype).Output(t.dtype).Constant("WIDTH",t.shape[1]).Constant("HEIGHT",t.shape[0]).Uniform("uWidth","float",t.shape[1]/e[1]).Uniform("uHeight","float",t.shape[0]/e[0]).Constant("KX",e[1]).Constant("KY",e[0]).LoadChunk("pickValue").SetShapeFn(()=>[~~(t.shape[0]/e[0]),~~(t.shape[1]/e[1]),4]).GLSLKernel(reduceStd).Compile({tStd:t}),ImageExtractStd=(t,e,a)=>new RegisterOperation("ImageExtractStd").Input("tSrc",t.dtype).Input("tMean",e.dtype).Output(t.dtype).Constant("WIDTH",t.shape[1]).Constant("HEIGHT",t.shape[0]).Uniform("uWidth","float",t.shape[1]/a[1]).Uniform("uHeight","float",t.shape[0]/a[0]).Constant("KX",a[1]).Constant("KY",a[0]).LoadChunk("pickValue").SetShapeFn(()=>[~~(t.shape[0]/a[0]),~~(t.shape[1]/a[1]),4]).GLSLKernel(getStd).Compile({tSrc:t,tMean:e}),ImageExtractMean=(t,e)=>new RegisterOperation("ImageExtractMean").Input("tSrc",t.dtype).Output(t.dtype).Constant("WIDTH",t.shape[1]).Constant("HEIGHT",t.shape[0]).Uniform("uWidth","float",t.shape[1]/e[1]).Uniform("uHeight","float",t.shape[0]/e[0]).Constant("KX",e[1]).Constant("KY",e[0]).LoadChunk("pickValue").SetShapeFn(()=>[~~(t.shape[0]/e[0]),~~(t.shape[1]/e[1]),4]).GLSLKernel(getMean).Compile({tSrc:t}),JoinOp=(t,e)=>new RegisterOperation("ImageJoin").Input("tMean",t.dtype).Input("tStd",e.dtype).Output(t.dtype).SetShapeFn(()=>[2,1,4]).GLSLKernel(joinKernel).Compile({tMean:t,tStd:e});var meanStdOp=(t,e=1,a)=>{let i=[[t.shape[0],t.shape[1]]];Array.isArray(e)?(assert$$1(parallelReductionCheckSteps2d(t.shape,e),"ImageMeanStd: Provided steps doesn't converge in 1 px in ImageExtractMeanStd operation"),i=e):"number"==typeof e&&e>0&&(i=parallelReductionGetSteps2d(t.shape,e));let r=ImageExtractMean(t,i[0]);for(let t=1;t<i.length;t+=1)r=ImageExtractMean(r,i[t]);if(a)return r;let n=ImageExtractStd(t,r,i[0]);for(let t=1;t<i.length;t+=1)n=ImageReduceStd(n,i[t]);return JoinOp(r,n)},getHistogramKernel="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/const int kx=int(KX);const int ky=int(KY);precision highp float;vec4 operation(float gly,float iglx){float size=KX*KY;float glx=floor(iglx/COUNT);float currentIndex=iglx-(glx*COUNT);vec4 count=vec4(0.0);vec4 ones=vec4(1.0);vec4 twos=vec4(2.0);vec4 currentIndex4=vec4(currentIndex);vec4 value;for(int y=0;y<ky;y+=1){for(int x=0;x<kx;x+=1){value=pickValue_tSrc(gly*KY+float(y),glx*KX+float(x));vec4 index=floor((value-MIN)/STEP+0.5);count+=step(twos,ones/(abs(index-currentIndex4)));}}return count;}",reduceKernel="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/const int kx=int(KX);const int ky=int(KY);vec4 operation(float gly,float iglx){float size=KX*KY;float glx=floor(iglx/COUNT);float currentIndex=iglx-(glx*COUNT);vec4 count=vec4(0.0);for(int y=0;y<ky;y+=1){for(int x=0;x<kx;x+=1){count+=pickValue_tSrc(gly*KY+float(y),(glx*KX+float(x))*COUNT+currentIndex);}}return count;}";const ImageExtractHistogram=(t,e,a,i,r,n)=>new RegisterOperation("ImageExtractHistogram").Input("tSrc",t.dtype).Output("float32").Constant("KX",e[1]).Constant("KY",e[0]).LoadChunk("pickValue").Constant("MIN",a).Constant("MAX",i).Constant("STEP",r).Constant("COUNT",n).SetShapeFn(()=>[~~(t.shape[0]/e[0]),~~(t.shape[1]/e[1])*n,4]).GLSLKernel(getHistogramKernel).Compile({tSrc:t}),ImageReduceHistogram=(t,e,a)=>new RegisterOperation("ImageReduceHistogram").Input("tSrc","float32").Output("float32").Constant("KX",e[1]).Constant("KY",e[0]).LoadChunk("pickValue").Constant("COUNT",a).SetShapeFn(()=>[~~(t.shape[0]/e[0]),~~(t.shape[1]/e[1]),4]).GLSLKernel(reduceKernel).Compile({tSrc:t});var histogramOp=(t,e=1,a=0,i=1,r=1/255)=>{let n=[[t.shape[0],t.shape[1]]];const o=~~((i-a+r)/r);Array.isArray(e)?(assert$$1(parallelReductionCheckSteps2d(t.shape,e),"ImageExtractHistogram: Provided steps doesn't converge in 1 px in operation"),n=e):"number"==typeof e&&e>0&&(n=parallelReductionGetSteps2d(t.shape,e,!0,[ENV.MAX_TEXTURE_SIZE,ENV.MAX_TEXTURE_SIZE/256/(ENV.SUPPORTS_FLOAT_TEXTURES?1:4)]));let s=ImageExtractHistogram(t,n[0],a,i,r,o);for(let t=1;t<n.length;t+=1)s=ImageReduceHistogram(s,n[t],o);return s},getMinMax="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/const int kx=int(KX);const int ky=int(KY);const float INF=1.0/0.0;const float h2=OUT_VIEW.y/2.0;vec4 operation(float igly,float glx){float size=KX*KY;vec3 minV=vec3(INF);vec3 maxV=vec3(-INF);float gly=igly;if(gly>=h2){gly-=h2;}for(int y=0;y<ky*2;y+=1){for(int x=0;x<kx;x+=1){vec3 value=pickValue_tSrc(gly*KY+float(y),glx*KX+float(x)).rgb;minV=min(minV,value.rgb);maxV=max(maxV,value.rgb);}}if(igly<h2){return vec4(minV,255.0);}else{return vec4(maxV,255.0);}}",reduceMinMax="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/const int kx=int(KX);const int ky=int(KY);const float INF=1.0/0.0;const float h2=OUT_VIEW.y/2.0;vec4 operation(float gly,float glx){float size=KX*KY;vec3 minV=vec3(INF);vec3 maxV=vec3(-INF);vec3 value;for(int y=0;y<ky;y+=1){for(int x=0;x<kx;x+=1){value=pickValue_tSrc(gly*KY+float(y),glx*KX+float(x)).rgb;minV=min(minV,value);maxV=max(maxV,value);}}if(gly<h2){return vec4(minV,255.0);}return vec4(maxV,255.0);}";const ImageExtractMinMax=(t,e)=>new RegisterOperation("ImageExtractMinMax").Input("tSrc",t.dtype).Output(t.dtype).Constant("KX",e[1]).Constant("KY",e[0]).LoadChunk("pickValue").SetShapeFn(()=>[2*~~(t.shape[0]/e[0]),~~(t.shape[1]/e[1]),4]).GLSLKernel(getMinMax).Compile({tSrc:t}),ImageReduceMinMax=(t,e)=>new RegisterOperation("ImageReduceMinMax").Input("tSrc",t.dtype).Output(t.dtype).Constant("KX",e[1]).Constant("KY",e[0]).LoadChunk("pickValue").SetShapeFn(()=>[~~(t.shape[0]/e[0]),~~(t.shape[1]/e[1]),4]).GLSLKernel(reduceMinMax).Compile({tSrc:t});var minMaxOp=(t,e=1)=>{let a=[[t.shape[0],t.shape[1]]];Array.isArray(e)?(assert$$1(parallelReductionCheckSteps2d(t.shape,e),"ImageMeanStd: Provided steps doesn't converge in 1 px in ImageExtractMeanStd operation"),a=e):"number"==typeof e&&e>0&&(a=parallelReductionGetSteps2d(t.shape,e));let i=ImageExtractMinMax(t,a[0]);for(let t=1;t<a.length;t+=1)i=ImageReduceMinMax(i,a[t]);return i},kernel$6="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float y,float x){vec4 prev=pickValue_tPrev(y,x);vec4 curr=pickValue_tCurr(y,x);float v=sqrt((curr.x-prev.x)*(curr.x-prev.x)+(curr.y-prev.y)*(curr.y-prev.y)+(curr.w-prev.w)*(curr.w-prev.w));return vec4(v,v,v,1.0);}",index$8=(t,e)=>(assert$$1(assertShapesAreEqual$$1(t,e),"MotionDetect: Current and previous input should have the same shape."),new RegisterOperation("MotionDetect").Input("tCurr",t.dtype).Input("tPrev",e.dtype).Output(t.dtype).LoadChunk("pickValue").GLSLKernel(kernel$6).Compile({tCurr:t,tPrev:e})),kernel$7="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float y,float x){vec4 col=pickValue_tSrc(y,x)*255.0;float res=0.0;if((col.r>uRThreshold)&&(col.g>uGThreshold)&&(col.b>uBThreshold)&&(col.r>col.g)&&(col.r>col.b)&&(col.r-min(col.g,col.b)>uRtoMinDiffThreshold)&&(abs(col.r-col.g)>uRtoGDiffThreshold)){res=1.0;}return vec4(res,0.0,0.0,1.0);}",index$9=(t,e={})=>new RegisterOperation("SkinTest").Input("tSrc",t.dtype).Output(t.dtype).Uniform("uRThreshold","float",e.uRThreshold||95).Uniform("uGThreshold","float",e.uGThreshold||40).Uniform("uBThreshold","float",e.uBThreshold||20).Uniform("uRtoMinDiffThreshold","float",e.uRtoMinDiffThreshold||15).Uniform("uRtoGDiffThreshold","float",e.uRtoGDiffThreshold||15).LoadChunk("pickValue").GLSLKernel(kernel$7).Compile({tSrc:t}),kernel$8="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float gly,float glx){float x;float y;if(SWAP_COORDS){x=gly;y=glx;}else{x=glx;y=gly;}float _sy=floor(x/SX);float _sx=x-(_sy*SX);float _y=floor(y/WIN_SIZE_X);float _x=y-(_y*WIN_SIZE_X);return pickValue_tSrc(_sy*STRIDE_Y+_y,_sx*STRIDE_X+_x);}",kernelFlat="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/\n#define WIN_LENGTH WIN_SIZE_X * WIN_SIZE_Y\nvec4 operation(float gly,float glx){float i;if(SWAP_COORDS){i=gly;}else{i=glx;}float x=floor(i/WIN_LENGTH);float y=i-x*WIN_LENGTH;float _sy=floor(x/SX);float _sx=x-(_sy*SX);float _y=floor(y/WIN_SIZE_X);float _x=y-(_y*WIN_SIZE_X);return pickValue_tSrc(_sy*STRIDE_Y+_y,_sx*STRIDE_X+_x);}";function getParam(t,e){if("number"==typeof t&&t>0&&isFinite(t))return[t,t];if(Array.isArray(t)&&2===t.length)return t;throw new Error(`Invalid parameter "${e}", expected a positive finite number or array with 2 those numbers, but got ${String(t)}`)}const slidingWindowOp=(t,e,a=1,i=0)=>{const r=getParam(e,"windowSize"),n=getParam(a,"stride"),o=clacConvolution(t.shape[1],r[0],n[0]),s=clacConvolution(t.shape[0],r[1],n[1]);let l,c,h;switch(i){case 1:l=[o*s,r[0]*r[1],4],h=!0,c=kernel$8;break;case 2:l=[1,o*s*r[0]*r[1],4],h=!1,c=kernelFlat;break;case 3:l=[o*s*r[0]*r[1],1,4],h=!0,c=kernelFlat;break;case 0:default:l=[r[0]*r[1],o*s,4],h=!1,c=kernel$8}return new RegisterOperation("SlidingWindow").Input("tSrc","float32").Output("float32").Constant("WIDTH",t.shape[1]).Constant("HEIGHT",t.shape[0]).Constant("SX",o).Constant("SY",s).Constant("STRIDE_Y",n[1]).Constant("STRIDE_X",n[0]).Constant("WIN_SIZE_X",r[0]).Constant("WIN_SIZE_Y",r[1]).Constant("SWAP_COORDS",h).LoadChunk("pickValue").SetShapeFn(()=>l).GLSLKernel(c).Compile({tSrc:t})};var kernel$9="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 findForAngle(float theta,bool invert,float gly,float glx){const float thetaTreshold=PI/6.0;float PER_STEP=(uStrokeMax-uStrokeMin)/STEPS;if(invert){theta+=PI;}float sn=sin(theta);float cs=cos(theta);float tx=cs*PER_STEP;float ty=sn*PER_STEP;float minX=cs*uStrokeMin;float minY=sn*uStrokeMin;float strokeWidth=0.0;int intersect=0;int cx=0;int cy=0;for(int i=int(STEPS);i>0;i-=1){int nx=int(glx+minX+tx*float(i));int ny=int(gly+minY+ty*float(i));float dist=sqrt(float((nx-int(glx))*(nx-int(glx)))+float((ny-int(gly))*(ny-int(gly))));float cannyValue=pickValue_tCanny(float(ny),float(nx)).r;vec4 sobelValue=pickValue_tSobel(float(ny),float(nx));float theta2=atan(sobelValue.b,sobelValue.g);if(invert){theta2+=PI;}if(cannyValue>0.0&&dist>uStrokeMin&&dist<uStrokeMax&&abs(abs(theta-theta2)-PI)<thetaTreshold){strokeWidth=dist;cx=nx;cy=ny;}}return vec4(strokeWidth,cx,cy,theta);}vec4 operation(float _y,float _x){vec4 sobel=pickValue_tSobel(_y,_x);vec4 canny=pickValue_tCanny(_y,_x);float dx=sobel.g;float dy=sobel.b;float _theta=atan(dy,dx);vec4 result=findForAngle(_theta,INVERT>0.0,_y,_x);float strokeWidth=result.r;int cx=int(result.g);int cy=int(result.b);float theta=result.a;float a=float(cx)-_x;float b=float(cy)-_y;if(C>0.0){if(canny.r>0.0&&cx>0&&cy>0){return vec4(strokeWidth,theta,int(cx),int(cy));}else{return vec4(0,0,0,0);}}if(canny.r>0.0&&cx>0&&cy>0){return vec4(strokeWidth,theta,0,1.0);}else{return vec4(0,0,0,0);}}",index$a=(t,e,a=3,i=10,r=10,n=!1,o=!0)=>new RegisterOperation("ImageStrokeWidthTransform").Input("tSobel","float32").Input("tCanny","uint8").Output("float32").LoadChunk("pickValue").Uniform("uStrokeMin","float",a).Uniform("uStrokeMax","float",i).Uniform("uWidth","float",t.shape[0]).Uniform("uHeight","float",t.shape[1]).Constant("STEPS",r).Constant("C",n?1:0).Constant("INVERT",o?1:0).Constant("PI",Math.PI).GLSLKernel(kernel$9).Compile({tCanny:e,tSobel:t}),kernel$a="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float y,float x){vec4 chanels1=pickValue_tA(y,x);vec4 chanels2=pickValue_tB(y,x);return RESULT;}",index$b=(t,e,a=["1.r","1.g","2.b","2.a"])=>{assert$$1(t.dtype===e.dtype,`Concat operation: inputs should have the same dtype, got ${t.dtype} and ${e.dtype}`),assert$$1(4===a.length,"Concat operation: wrong input");for(let t=0;t<a.length;t+=1)assert$$1("string"==typeof a[t]||!/^\d\.(r|g|b|a|x|y|z|w)$/.test(a[t]),"Concat operation: wrong input");return new RegisterOperation("Concat").Input("tA",t).Input("tB",e).Output(t.dtype).LoadChunk("pickValue").GLSLKernel(kernel$a.replace("RESULT",`vec4(${a.map(t=>`chanels${t}`).join(", ")})`)).Compile({tA:t,tB:e})},l2Kernel="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float y,float x){vec3 chanels=pickValue_tSrc(y,x).rgb;vec3 mean=pickValue_tStdMean(0.0,0.0).rgb;vec3 std=pickValue_tStdMean(1.0,0.0).rgb;vec3 value=(chanels-mean)/std;return vec4(value,1.0);}",minMaxKernel="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float y,float x){vec3 chanels=pickValue_tSrc(y,x).rgb;vec3 minV=pickValue_tMinMax(0.0,0.0).rgb;vec3 maxV=pickValue_tMinMax(1.0,0.0).rgb;vec3 value=(chanels-minV)/(maxV-minV);return vec4(value,1.0);}";const l2Norm=(t,e)=>new RegisterOperation("l2Norm").Input("tSrc","uint8").Input("tStdMean","uint8").Output("uint8").LoadChunk("pickValue").GLSLKernel(l2Kernel).Compile({tSrc:t,tStdMean:e}),minMaxNorm=(t,e)=>new RegisterOperation("minMaxNorm").Input("tSrc","uint8").Input("tMinMax","uint8").Output("uint8").LoadChunk("pickValue").GLSLKernel(minMaxKernel).Compile({tSrc:t,tMinMax:e});var norm=(t,e,a=2)=>{assert$$1("l2"===e||"minmax"===e,"Unsupported type of normalization operation.\n     Currently availiable max and visualize.");let i=null;return"l2"===e&&(i=l2Norm(t,meanStdOp(t,a))),"minmax"===e&&(i=minMaxNorm(t,minMaxOp(t,a))),i},histKernel="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/const float norm=1.0/(OUT_VIEW.x*OUT_VIEW.y);vec4 operation(float y,float x){vec4 histBase=pickValue_tSrc(y,x)*255.0;float r=pickValue_tHist(0.0,histBase.r).r;float g=pickValue_tHist(0.0,histBase.g).g;float b=pickValue_tHist(0.0,histBase.b).b;float a=pickValue_tHist(0.0,histBase.a).a;return vec4(r,g,b,255.0/norm)*norm;}",histCumulateKernel="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float y,float x){vec4 sum=vec4(0.0);for(float i=0.0;i<255.0;i+=1.0){vec4 value=pickValue_tSrc(0.0,i);if(i<=x){sum+=value;}else{break;}}return sum;}";const cumulateHistEq=t=>new RegisterOperation("histogramCumulation").Input("tSrc","float32").Output("float32").LoadChunk("pickValue").GLSLKernel(histCumulateKernel).Compile({tSrc:t}),histEq=(t,e)=>new RegisterOperation("histogramEqualization").Input("tSrc","uint8").Input("tHist","float32").Output("uint8").LoadChunk("pickValue").GLSLKernel(histKernel).Compile({tSrc:t,tHist:e});var index$c=(t,e=2)=>histEq(t,cumulateHistEq(histogramOp(t,e))),kernel$b="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 getPoint(vec2 p){return pickValue_tSrc(p.y,p.x);}mat3 getTransformMatrix(){vec3 r1=pickValue_tTransform(0.0,0.0).rgb;vec3 r2=pickValue_tTransform(1.0,0.0).rgb;vec3 r3=pickValue_tTransform(3.0,0.0).rgb;return mat3(r1,r2,r3);}vec4 operation(float y,float x){mat3 m=getTransformMatrix();float off=0.0;float ixs=0.0;float iys=0.0;float xs=0.0;float ys=0.0;float xs0=0.0;float ys0=0.0;float ws=0.0;float sc=0.0;float a=0.0;float b=0.0;xs0=m[0][1]*y+m[0][2];ys0=m[1][1]*y+m[1][2];ws=m[2][1]*y+m[2][2];xs0+=m[0][0]*x;ys0+=m[1][0]*x;ws+=m[2][0]*x;sc=1.0/ws;xs=xs0*sc;ys=ys0*sc;ixs=xs;iys=ys;a=max(xs-ixs,0.0);b=max(ys-iys,0.0);vec2 mvec=vec2(ixs,iys);vec2 ox=vec2(1.0,0.0);vec2 oy=vec2(1.0,1.0);vec4 p0=getPoint(mvec)+a*(getPoint(mvec+ox)-getPoint(mvec));vec4 p1=getPoint(mvec+oy)+a*(getPoint(mvec+ox+oy)-getPoint(mvec+oy));vec4 pres=p0+b*(p1-p0);return pres;}",index$d=(t,e,a=[10,10,4],i=t.dtype)=>new RegisterOperation("PerspectiveProjection").Input("tSrc",t.dtype).Input("tTransform","float32").Output(i).LoadChunk("pickValue").Uniform("uSrcWidth","float",t.shape[1]).Uniform("uSrcHeight","float",t.shape[0]).Uniform("uWidth","float",a[1]).Uniform("uHeight","float",a[0]).SetShapeFn(()=>a).GLSLKernel(kernel$b).Compile({tSrc:t,tTransform:e}),transformKernel="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/precision highp float;float intersectionX(vec4 line,float x){return((x-line.x)/(line.z-line.x)*(line.w-line.y)+line.y);}float intersectionY(vec4 line,float y){return((y-line.y)/(line.w-line.y)*(line.z-line.x)+line.x);}vec4 findSide(float x1,float y1,float x2,float y2){int i=0;vec2 i0=vec2(0,0);vec2 i1=vec2(0,0);float ax=0.0;float ay=intersectionY(vec4(x1,y1,x2,y2),ax);float by=0.0;float bx=intersectionX(vec4(x1,y1,x2,y2),by);float cx=MAX_DIST;float cy=intersectionY(vec4(x1,y1,x2,y2),cx);float dy=MAX_DIST;float dx=intersectionX(vec4(x1,y1,x2,y2),dy);if(ay<=MAX_DIST&&ay>=0.0){if(i==0){i0=vec2(ax,ay);i+=1;}}if(cy<=MAX_DIST&&cy>=0.0){if(i==0){i0=vec2(cx,cy);i+=1;}else{i1=vec2(cx,cy);}}if(bx<=MAX_DIST&&bx>=0.0){if(i==0){i0=vec2(bx,by);i+=1;}else{i1=vec2(bx,by);}}if(dx<=MAX_DIST&&dx>=0.0){if(i==0){i0=vec2(dx,dy);i+=1;}else{i1=vec2(dx,dy);}}return vec4(i0.x,i0.y,i1.x,i1.y);}float pow(float a){return a*a;}vec4 getStraight(float aIndex,float v,float dist,float angles){float y1;float y2;if(aIndex>angles){aIndex-=angles;y1=MAX_ANGLE-(angles*v/aIndex);y2=(-1.0+angles/aIndex)*uWidth+y1;}else{aIndex=angles-aIndex;y1=(angles*v/aIndex);y2=(1.0-angles/aIndex)*uWidth+y1;}return vec4(0.0,y1,uWidth,y2);}float getValue(float i,float lx,float ly,vec4 side){float xx=0.0;float yy=0.0;if(lx<ly){xx=i;yy=intersectionY(side,xx);}else{yy=i;xx=intersectionX(side,yy);}if(xx>0.0&&xx<uWidth&&yy>0.0&&yy<uHeight){float a=pickScalarValue_tSrc(yy,xx);if(a>0.0){return 1.0;}}return 0.0;}vec4 operation(float y,float x){float v_out=0.0;vec4 straight=getStraight(x,y,MAX_DIST,MAX_ANGLE/2.0);vec4 side=findSide(straight.x,straight.y,straight.z,straight.w);float lx=abs(side.z-side.x);float ly=abs(side.w-side.y);float k=1.0/D;for(float i=0.0;i<=D;i+=STEP){float a=getValue(i,lx,ly,side);if(a>0.0){v_out+=k;}}return vec4(v_out,v_out,v_out,255.0);}",enhanceKernel="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/\n#define X_STEPS 10.0\n#define Y_STEPS 10.0\nvec4 operation(float y,float x){float value=pickValue_tSrc(y,x).r;float c=value*value;float sum=0.0;for(float j=0.0;j<Y_STEPS;j+=1.0){for(float i=0.0;i<X_STEPS;i+=1.0){sum+=pickValue_tSrc((y-Y_STEPS/2.0)+j,(x-X_STEPS/2.0)+i).r;}}float v=(c/sum)*X_STEPS*Y_STEPS;return vec4(v,v,v,1);}",peaksKernel="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/const int w=int(W);const int h=int(H);vec4 operation(float _y,float _x){float sum=0.0;float mmax=0.0;float maxX=0.0;float maxY=0.0;float sy=_y*H;float sx=_x*W;for(int x=0;x<w;x+=1){for(int y=0;y<h;y+=1){vec4 value;if(uWidth==uSrcWidth){value=pickValue_tSrc(_y,_x);}else{value=pickValue_tSrc(float(y)+sy,float(x)+sx);}if(value.r>mmax){mmax=value.r;if(uF==0.0){maxX=float(x)+sx;maxY=float(y)+sy;}else{maxX=value.g;maxY=value.b;}}}}return vec4(mmax,maxX,maxY,255.0);}";const TopKCandidates=(t,e=10,a=0)=>new RegisterOperation("ExtractPeaks").Input("tSrc","uint8").Output("float32").Uniform("uSrcWidth","float",t.shape[1]).Uniform("uWidth","float",t.shape[1]/e).Uniform("uHeight","float",t.shape[0]/e).Uniform("uF","float",a).LoadChunk("pickValue").Constant("SIZE",~~(t.shape[0]/e)*~~(t.shape[1]/e)).Constant("W",e).Constant("H",e).Constant("K",1/e).SetShapeFn(()=>[~~(t.shape[0]/e),~~(t.shape[1]/e),4]).GLSLKernel(peaksKernel).Compile({tSrc:t}),PCLinesTransform=(t,e=.1,a=3)=>{const i=Math.max(t.shape[0],t.shape[1]);return new RegisterOperation("PCLinesTransform").Input("tSrc","float32").Output("uint8").Uniform("uWidth","float",t.shape[1]).Uniform("uHeight","float",t.shape[0]).Uniform("uLineLength","float",e).Constant("PI",Math.PI).Constant("D",i).Constant("STEP",a).Constant("MAX_DIST",i).Constant("MAX_ANGLE",i).LoadChunk("pickValue").SetShapeFn(()=>[i,i,4]).GLSLKernel(transformKernel).Compile({tSrc:t})},EnhancePCLines=t=>new RegisterOperation("PCLinesTransformEnhanced").Input("tSrc","uint8").Output("uint8").Uniform("uWidth","float",t.shape[0]).Uniform("uHeight","float",t.shape[0]).LoadChunk("pickValue").GLSLKernel(enhanceKernel).Compile({tSrc:t});var index$e=t=>{let e=t;return e=PCLinesTransform(e,0,1),e=EnhancePCLines(e),e=norm(e,"minmax"),e=TopKCandidates(e,2),e=TopKCandidates(e,2,1)},RGBToHSVKernel="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec3 rgb2hsv(vec3 c){vec4 K=vec4(0.0,-1.0/3.0,2.0/3.0,-1.0);vec4 p=mix(vec4(c.bg,K.wz),vec4(c.gb,K.xy),step(c.b,c.g));vec4 q=mix(vec4(p.xyw,c.r),vec4(c.r,p.yzx),step(p.x,c.r));float d=q.x-min(q.w,q.y);float e=1.0e-10;return vec3(abs(q.z+(q.w-q.y)/(6.0*d+e)),d/(q.x+e),q.x);}vec4 operation(float y,float x){return vec4(rgb2hsv(pickValue_tSrc(y,x).rgb),1);}",HSVToRGBKernel="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec3 hsv2rgb(vec3 c){vec4 K=vec4(1.0,2.0/3.0,1.0/3.0,3.0);vec3 p=abs(fract(c.xxx+K.xyz)*6.0-K.www);return c.z*mix(K.xxx,clamp(p-K.xxx,0.0,1.0),c.y);}vec4 operation(float y,float x){return vec4(hsv2rgb(pickValue_tSrc(y,x).rgb),1);}",index$f=(t,e="rgb_to_hsv")=>{assert$$1("rgb_to_hsv"===e||"hsv_to_rgb"===e,`Unsupported type ${e}, currenlty avaliable: rgb_to_hsv, hsv_to_rgb.`);let a=null;return"rgb_to_hsv"===e&&(a=RGBToHSVKernel),"hsv_to_rgb"===e&&(a=HSVToRGBKernel),new RegisterOperation("HSV").Input("tSrc",t.dtype).Output(t.dtype).LoadChunk("pickValue").GLSLKernel(a).Compile({tSrc:t})},kernel$c="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float y,float x){vec4 pixel=pickValue_tSrc(y,x);if(pixel[int(C)]>uT){return vec4(1.0,1.0,1.0,1.0);}else{return vec4(0.0,0.0,0.0,1.0);}}",index$g=(t,e=.5,a=0)=>(assert$$1("number"==typeof e,"Only number available as a threshold value."),assert$$1(0===a||1===a||2===a||3===a,"Only RGBA available: 0, 1, 2, 3"),new RegisterOperation("Threshold").Input("tSrc",t.dtype).Output(t.dtype).Constant("C",a).Uniform("uT","float",e).LoadChunk("pickValue").GLSLKernel(kernel$c).Compile({tSrc:t})),kernel$d="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/float HKW=floor(KW/2.0);float HKH=floor(KW/2.0);vec4 operation(float y,float x){float R=10000.0;float G=10000.0;float B=10000.0;y=y+HKH;x=x+HKW;for(float dx=0.0;dx<KW;dx+=1.0){for(float dy=0.0;dy<KH;dy+=1.0){vec4 v=pickValue_tSrc((y-dy),(x-dx));vec4 m=pickValue_tKernel(dy,dx);if(v.r<R&&m.r>0.0){R=v.r;}if(v.g<G&&m.g>0.0){G=v.g;}if(v.b<B&&m.b>0.0){B=v.b;}}}return vec4(R,G,B,1.0);}",erode=(t,e=[2,2],a=!1)=>{if(assert$$1(2===e.length,"Erosion: Kernel size should be shape of rank 2"),isTensor$$1(a)&&assert$$1(e[0]===a.shape[0]&&e[1]===a.shape[1],"Erosion: Structure element has wrong size"),!a){a=new Tensor("float32",[e[0],e[1],4]);for(let t=0;t<e[0];t+=1)for(let i=0;i<e[1];i+=1)a.set(t,i,0,1),a.set(t,i,1,1),a.set(t,i,2,1),a.set(t,i,3,1)}return new RegisterOperation("Erosion").Input("tSrc",t.dtype).Input("tKernel","float32").Output(t.dtype).Constant("KW",e[0]).Constant("KH",e[1]).LoadChunk("pickValue").GLSLKernel(kernel$d).Compile({tSrc:t,tKernel:a})},kernel$e="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/float HKW=floor(KW/2.0);float HKH=floor(KW/2.0);vec4 operation(float y,float x){float R=0.0;float G=0.0;float B=0.0;y=y+HKH;x=x+HKW;for(float dx=0.0;dx<KW;dx+=1.0){for(float dy=0.0;dy<KH;dy+=1.0){vec4 v=pickValue_tSrc((y-dy),(x-dx));vec4 m=pickValue_tKernel(dy,dx);if(v.r>R&&m.r>0.0){R=v.r;}if(v.g>G&&m.g>0.0){G=v.g;}if(v.b>B&&m.b>0.0){B=v.b;}}}return vec4(R,G,B,1.0);}",dilate=(t,e=[2,2],a=!1)=>{if(assert$$1(2===e.length,"Dilation: Kernel size should be shape of rank 2"),isTensor$$1(a)&&assert$$1(e[0]===a.shape[0]&&e[1]===a.shape[1],"Dilation: Structure element has wrong size"),!a){a=new Tensor("float32",[e[0],e[1],4]);for(let t=0;t<e[0];t+=1)for(let i=0;i<e[1];i+=1)a.set(t,i,0,1),a.set(t,i,1,1),a.set(t,i,2,1),a.set(t,i,3,1)}return new RegisterOperation("Dilation").Input("tSrc",t.dtype).Input("tKernel","float32").Output(t.dtype).Constant("KW",e[0]).Constant("KH",e[1]).LoadChunk("pickValue").GLSLKernel(kernel$e).Compile({tSrc:t,tKernel:a})},kernel$f="/***@license MIT*@author Arkadiy Pilguk(apilguk@gmail.com)*@author Mihail Zachepilo(mihailzachepilo@gmail.com)*Copyright 2018 Peculiar Ventures and Pentatonica.*All rights reserved.*/vec4 operation(float y,float x){vec4 A=pickValue_tA(y,x);vec4 B=pickValue_tB(y,x);return vec4(A.rgb-B.rgb,1.0);}",sub=(t,e)=>(assert$$1(t.dtype===e.dtype,`Substract: inputs should have the same dtype, got ${t.dtype} and ${e.dtype}`),assert$$1(t.shape[0]===e.shape[0]&&t.shape[1]===e.shape[1]&&t.shape[3]===e.shape[3],`Substract: inputs should have the same shapes, got ${t.shape} and ${e.shape}`),new RegisterOperation("Substract").Input("tA",t).Input("tB",e).Output(t.dtype).LoadChunk("pickValue").GLSLKernel(kernel$f).Compile({tA:t,tB:e})),index$h=(t,e="open",a=[2,2],i=!1)=>{switch(e){case"open":return dilate(erode(t,a,i),a,i);case"close":return erode(dilate(t,a,i),a,i);case"gradient":return sub(dilate(t,a,i),erode(t,a,i));case"tophat":return sub(t,dilate(erode(t,a,i),a,i));case"blackhat":return sub(erode(dilate(t,a,i),a,i),t);default:return new Error(`MorphTransform: unsopported operation type ${e}`)}};exports.Rect=Rect,exports.Line=Line,exports.TypedPool=TypedPool,exports.Session=Session,exports.GLTexture=GPUTexture,exports.RegisterOperation=RegisterOperation,exports.Tensor=Tensor,exports.Operation=Operation,exports.initDrawable=initDrawable,exports.initMouseTracking=initMouseTracking,exports.toImageData=toImageData,exports.getImageData=getImageData,exports.putImageData=putImageData,exports.canvasFromTensor=canvasFromTensor,exports.canvasToTensor=canvasToTensor,exports.canvasDrawLine=canvasDrawLine,exports.canvasDrawCircle=canvasDrawCircle,exports.canvasFillCircle=canvasFillCircle,exports.clearCanvas=clearCanvas,exports.canvasDrawRect=canvasDrawRect,exports.canvasFill=canvasFill,exports.canvasClear=canvasClear,exports.canvasInit=canvasInit,exports.canvasCreate=canvasCreate,exports.imageTensorFromURL=imageTensorFromURL,exports.CaptureVideo=CaptureVideo,exports.assert=assert$$1,exports.assertShapesAreEqual=assertShapesAreEqual$$1,exports.isValidShape=isValidShape$$1,exports.isOperation=isOperation$$1,exports.isTensor=isTensor$$1,exports.isValidGLSLChunk=isValidGLSLChunk$$1,exports.isValidGLSLVariableName=isValidGLSLVariableName$$1,exports.isValidOperationShape=isValidOperationShape$$1,exports.DeprecationError=DeprecationError$$1,exports.deprecationWarning=deprecationWarning$$1,exports.deprecationError=deprecationError$$1,exports.grayscale=index,exports.gaussianBlur=index$1,exports.downsample=index$2,exports.sobelOperator=index$3,exports.hog=index$4,exports.cast=index$5,exports.cannyEdges=index$6,exports.colorSegmentation=index$7,exports.meanStd=meanStdOp,exports.histogram=histogramOp,exports.minMax=minMaxOp,exports.motionDetect=index$8,exports.skinTest=index$9,exports.slidingWindow=slidingWindowOp,exports.swt=index$a,exports.concat=index$b,exports.norm=norm,exports.histogramEqualization=index$c,exports.perspectiveProjection=index$d,exports.pcLines=index$e,exports.HSVColor=index$f,exports.threshold=index$g,exports.erode=erode,exports.dilate=dilate,exports.sub=sub,exports.morphologyEx=index$h,exports.range=range,exports.tensorFrom=tensorFrom,exports.tensorClone=tensorClone,exports.tensorInvert=tensorInvert,exports.tensorAssertEqual=tensorAssertEqual,exports.tensorAssertCloseEqual=tensorAssertCloseEqual,exports.tensorAssertMSEEqual=tensorAssertMSEEqual,exports.flipTensor=flipTensor,exports.invertTensor=invertTensor,exports.tensorMap=tensorMap,exports.tensorOnes=tensorOnes,exports.sortPoints=sortPoints,exports.angleBetweenLines=angleBetweenLines,exports.transfromPoint=transfromPoint,exports.genetateTransformMatrix=genetateTransformMatrix;
},{}],"l8Dw":[function(require,module,exports) {
"use strict";function e(e){if(2!==e.length)throw new Error("Invalid rank, expected two-dimensional tensor\n      for example - [100, 2]\n      actually - ["+e+"]");if(2!==e[1])throw new Error("Invalid second shape argument\n      expected - 2\n      actually - "+e[1])}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=e;
},{}],"VNNP":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var i=require("gammacv"),e=r(i),t=require("./utils"),n=a(t);function a(i){return i&&i.__esModule?i:{default:i}}function r(i){if(i&&i.__esModule)return i;var e={};if(null!=i)for(var t in i)Object.prototype.hasOwnProperty.call(i,t)&&(e[t]=i[t]);return e.default=i,e}var o={dataStyle:{lineWidth:null,lineColor:"#cccccc",pointSize:4,pointColor:"#ff0000",pointBorder:null,bgColor:null},legendGrid:[3,7],indent:{xAxis:30,yAxis:40,xMark:10,yMark:5},bottomPadding:20,size:[800,400]},x=function(i,e){for(var t=1/0,n=-1/0,a=0;a<e.shape[0];a+=1){var r=e.get(a,"x"===i?0:1);r<t&&(t=r),r>n&&(n=r)}return{min:t,max:n}},s=function(i,t,n,a,r){var x=n.min,s=n.max,l=n.roundedMax,d=a.font,h=a.legendFontSize,g=a.legendFontColor,c=a.legendRulerColor,f=a.legendGuidesColor,u=a.xAxisLabels,A=a.showRulerY,y=a.indent,m=a.yAxisFromMinVal,v=a.legendGrid,w=a.showMinY,p=o.bottomPadding;p="histogram"===r?0:p;for(var C="x"===i,M="y"===i,b=v?v[C?1:0]:o.legendGrid[C?1:0],P=y||o.indent,D=((C?t.width:t.height-p)-2*P[i+"Axis"])/b,L=(M?(M?l:s)-x:s)/(C?b-1:b),S=L.toString().split(".")[1],k=S?S.length:0,G=new Array(b),z=x,F=0;F<b;F+=1){var R=0;R=0===F?m?x:0:z+=L,G[F]=R.toFixed(k>=2?2:k)}for(var _=0;_<b;_+=1){var O=C?D*_+P.xAxis:P.xAxis,j=C?t.height-P.yAxis:t.height-(D*_+P.yAxis);(A&&M||C)&&(e.canvasDrawLine(t,[O,C?j:j-p,C?O+D:O,C?j:j-D-p],c),e.canvasDrawLine(t,[O,C?j:j-p,C?O:P.xAxis-10,C?t.height-P.yAxis+10:j-p],c),_===b-1&&e.canvasDrawLine(t,[C?O+D:O,C?j:j-D-p,C?O+D:P.xAxis-10,C?t.height-P.yAxis+10:j-D-p],c)),(M&&0!==_||C&&"histogram"!==r)&&e.canvasDrawLine(t,[C?O+D/2:O,C?j:j-p,C?O+D/2:t.width-P.xAxis,C?P.yAxis:j-p],f),_===b-1&&M&&e.canvasDrawLine(t,[O,j-D-p,t.width-P.xAxis,j-D-p],f);var B=t.getContext("2d"),q=u&&u[_]&&C?u[_].toUpperCase():G[_];B.beginPath(),B.fillStyle=g,B.font=h+"pt "+d,B.textAlign=C?"center":"end",B.textBaseline="middle",!w&&0===_&&M||(B.fillText(q,C?O+D/2:P.xAxis-P.yMark,C?t.height-P.yAxis+P.xMark:j-p),_===b-1&&M&&B.fillText(l,P.xAxis-P.yMark,j-D-p))}},l=function(i,t,n,a,r,x,s){for(var l=x.x,d=x.y,h=r.dataStyles,g=r.indent,c=r.yAxisFromMinVal,f=r.legendGrid,u=o.bottomPadding,A=h&&h[i]?h[i]:o.dataStyle,y=A.lineWidth,m=A.lineColor,v=A.pointSize,w=A.pointBorder,p=A.pointColor,C=100*(d.max-d.min)/d.roundedMax,M=g||o.indent,b=c||d.min<0?d.min:0,P=(n.height-2*M.yAxis-u)*C/100,D=f?f[1]:o.legendGrid[1],L=(n.width-2*M.xAxis)/D,S=new Array(a.shape[0]),k=new Array(a.shape[0]),G=0;G<a.shape[0];G+=1)S[G]=(a.get(G,0)-l.min)/(l.max-l.min)*(n.width-2*M.xAxis-L),k[G]=n.height-(a.get(G,1)-b)/(d.max-b)*P;if("scatter"!==s&&"histogram"!==s)for(var z=0;z<a.shape[0];z+=1)e.canvasDrawLine(n,[S[z]+M.xAxis+L/2,k[z]-u-M.yAxis,S[z+1]+M.xAxis+L/2,k[z+1]-u-M.yAxis],m,y);if("histogram"===s)for(var F=L/t,R=0;R<a.shape[0];R+=1)e.canvasDrawLine(n,[M.xAxis+L*R+F/2+F*i,k[R]-M.yAxis,M.xAxis+L*R+F/2+F*i,n.height-M.yAxis],A.bgColor,F);if("histogram"!==s)for(var _=0;_<a.shape[0];_+=1)e.canvasFillCircle(n,[S[_]+M.xAxis+L/2,k[_]-u-M.yAxis],v,p),w&&e.canvasDrawCircle(n,[S[_]+M.xAxis+L/2,k[_]-u-M.yAxis],v+1,w)},d=function(i,t,a,r){var d=t.size,h=t.legendGrid,g=d||o.size,c=a||e.canvasCreate();c.width=g[0]*window.devicePixelRatio,c.height=g[1]*window.devicePixelRatio,c.style.width=g[0]+"px",c.style.height=g[1]+"px",c.getContext("2d").scale(window.devicePixelRatio,window.devicePixelRatio);for(var f={width:g[0],height:g[1],getContext:function(){return c.getContext("2d")}},u={x:{min:1/0,max:-1/0},y:{min:1/0,max:-1/0,roundedMax:null}},A=function(e){Object.keys(u).forEach(function(t){var n=x(t,i[e]),a=n.min,r=n.max;a<u[t].min&&(u[t].min=a),r>u[t].max&&(u[t].max=r)})},y=0;y<i.length;y+=1)A(y);u.y.roundedMax=Math.ceil((u.y.max+1)/h[0])*h[0],Object.keys(u).forEach(function(i){s(i,f,u[i],t,r)});for(y=0;y<i.length;y+=1)(0,n.default)(i[y].shape),l(y,i.length,f,i[y],t,u,r)};exports.default=d;
},{"gammacv":"AYih","./utils":"l8Dw"}],"Zdfz":[function(require,module,exports) {
"use strict";var e=require("gammacv"),o=i(e),r=require("../lib"),n=t(r);function t(e){return e&&e.__esModule?e:{default:e}}function i(e){if(e&&e.__esModule)return e;var o={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(o[r]=e[r]);return o.default=e,o}for(var l=document.getElementById("plot"),f=document.getElementById("scatter"),a=document.getElementById("histogram"),d=6,s=10,g=[],u={dataStyles:[{lineWidth:2,lineColor:"rgba(20, 110, 255, 0.2)",pointSize:5,pointColor:"#146eff",pointBorder:"#ffffff"},{lineWidth:2,lineColor:"rgba(252, 208, 15, 0.2)",pointSize:5,pointColor:"rgb(252, 208, 15)",pointBorder:"#ffffff"},{lineWidth:2,lineColor:"rgba(168, 168, 168, 0.2)",pointSize:5,pointColor:"rgb(168, 168, 168)",pointBorder:"#ffffff"}],showRulerY:!1,font:"Open Sans",legendGrid:[3,10],legendFontSize:10,legendFontColor:"rgba(7, 15, 82, 0.8)",legendGuidesColor:"rgba(7, 15, 82, 0.1)",legendRulerColor:"rgba(7, 15, 82, 0.4)",indent:{xAxis:40,yAxis:22,xMark:15,yMark:6},xAxisLabels:["mon","tue","wed","thu","fri","sat","sun"],yAxisFromMinVal:!0,showMinY:!1,roundMax:!0},p={dataStyles:[{pointSize:5,pointColor:"#146eff",pointBorder:"#ffffff"},{pointSize:5,pointColor:"rgb(252, 208, 15)",pointBorder:"#ffffff"},{pointSize:5,pointColor:"rgb(168, 168, 168)",pointBorder:"#ffffff"}],showRulerY:!1,font:"Open Sans",legendGrid:[3,10],legendFontSize:10,legendFontColor:"rgba(7, 15, 82, 0.8)",legendGuidesColor:"rgba(7, 15, 82, 0.1)",legendRulerColor:"rgba(7, 15, 82, 0.4)",indent:{xAxis:40,yAxis:22,xMark:15,yMark:6},yAxisFromMinVal:!0,showMinY:!1,roundMax:!0},b={dataStyles:[{bgColor:"#146eff"},{bgColor:"rgb(252, 208, 15)"},{bgColor:"rgb(168, 168, 168)"}],showRulerY:!1,font:"Open Sans",legendGrid:[3,s],legendFontSize:10,legendFontColor:"rgba(7, 15, 82, 0.8)",legendGuidesColor:"rgba(7, 15, 82, 0.1)",legendRulerColor:"rgba(7, 15, 82, 0.4)",indent:{xAxis:40,yAxis:22,xMark:15,yMark:6},xAxisLabels:["mon","tue","wed","thu","fri","sat","sun"],yAxisFromMinVal:!0,showMinY:!1,roundMax:!0},x=0;x<d;x+=1){for(var C=new o.Tensor("float32",[s,2]),M=0;M<s;M+=1)C.set(M,0,M),C.set(M,1,20*Math.random());g.push(C)}(0,n.default)(g,u,l,"plot"),(0,n.default)(g,p,f,"scatter"),(0,n.default)(g,b,a,"histogram");
},{"gammacv":"AYih","../lib":"VNNP"}]},{},["Zdfz"], null)
//# sourceMappingURL=example.b3911a91.map